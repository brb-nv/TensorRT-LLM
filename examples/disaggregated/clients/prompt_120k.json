["The following text is a long document for which I need a summary:\n\nCUDA C++ Programming Guide\n1. Overview\uf0c1\n\nCUDA is a parallel computing platform and programming model developed by NVIDIA that enables dramatic increases in computing performance by harnessing the power of the GPU. It allows developers to accelerate compute-intensive applications using C, C++, and Fortran, and is widely adopted in fields such as deep learning, scientific computing, and high-performance computing (HPC).\n2. What Is the CUDA C Programming Guide?\uf0c1\n\nThe CUDA C Programming Guide is the official, comprehensive resource that explains how to write programs using the CUDA platform. It provides detailed documentation of the CUDA architecture, programming model, language extensions, and performance guidelines. Whether you\u2019re just getting started or optimizing complex GPU kernels, this guide is an essential reference for effectively leveraging CUDA\u2019s full capabilities.\n\n3. Introduction\uf0c1\n3.1. The Benefits of Using GPUs\uf0c1\n\nThe Graphics Processing Unit (GPU)1 provides much higher instruction throughput and memory bandwidth than the CPU within a similar price and power envelope. Many applications leverage these higher capabilities to run faster on the GPU than on the CPU (see GPU Applications). Other computing devices, like FPGAs, are also very energy efficient, but offer much less programming flexibility than GPUs.\n\nThis difference in capabilities between the GPU and the CPU exists because they are designed with different goals in mind. While the CPU is designed to excel at executing a sequence of operations, called a thread, as fast as possible and can execute a few tens of these threads in parallel, the GPU is designed to excel at executing thousands of them in parallel (amortizing the slower single-thread performance to achieve greater throughput).\n\nThe GPU is specialized for highly parallel computations and therefore designed such that more transistors are devoted to data processing rather than data caching and flow control. The schematic Figure 1 shows an example distribution of chip resources for a CPU versus a GPU.\nThe GPU Devotes More Transistors to Data Processing\n\nFigure 1 The GPU Devotes More Transistors to Data Processing\uf0c1\n\nDevoting more transistors to data processing, for example, floating-point computations, is beneficial for highly parallel computations; the GPU can hide memory access latencies with computation, instead of relying on large data caches and complex flow control to avoid long memory access latencies, both of which are expensive in terms of transistors.\n\nIn general, an application has a mix of parallel parts and sequential parts, so systems are designed with a mix of GPUs and CPUs in order to maximize overall performance. Applications with a high degree of parallelism can exploit this massively parallel nature of the GPU to achieve higher performance than on the CPU.\n\n1\n\n    The graphics qualifier comes from the fact that when the GPU was originally created, two decades ago, it was designed as a specialized processor to accelerate graphics rendering. Driven by the insatiable market demand for real-time, high-definition, 3D graphics, it has evolved into a general processor used for many more workloads than just graphics rendering.\n\n3.2. CUDA\u00ae: A General-Purpose Parallel Computing Platform and Programming Model\uf0c1\n\nIn November 2006, NVIDIA\u00ae introduced CUDA\u00ae, a general purpose parallel computing platform and programming model that leverages the parallel compute engine in NVIDIA GPUs to solve many complex computational problems in a more efficient way than on a CPU.\n\nCUDA comes with a software environment that allows developers to use C++ as a high-level programming language. As illustrated by Figure 2, other languages, application programming interfaces, or directives-based approaches are supported, such as FORTRAN, DirectCompute, OpenACC.\nGPU Computing Applications. CUDA is designed to support various languages and application programming interfaces.\n\nFigure 2 GPU Computing Applications. CUDA is designed to support various languages and application programming interfaces.\uf0c1\n3.3. A Scalable Programming Model\uf0c1\n\nThe advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems. The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as 3D graphics applications transparently scale their parallelism to manycore GPUs with widely varying numbers of cores.\n\nThe CUDA parallel programming model is designed to overcome this challenge while maintaining a low learning curve for programmers familiar with standard programming languages such as C.\n\nAt its core are three key abstractions \u2014 a hierarchy of thread groups, shared memories, and barrier synchronization \u2014 that are simply exposed to the programmer as a minimal set of language extensions.\n\nThese abstractions provide fine-grained data parallelism and thread parallelism, nested within coarse-grained data parallelism and task parallelism. They guide the programmer to partition the problem into coarse sub-problems that can be solved independently in parallel by blocks of threads, and each sub-problem into finer pieces that can be solved cooperatively in parallel by all threads within the block.\n\nThis decomposition preserves language expressivity by allowing threads to cooperate when solving each sub-problem, and at the same time enables automatic scalability. Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by Figure 3, and only the runtime system needs to know the physical multiprocessor count.\n\nThis scalable programming model allows the GPU architecture to span a wide market range by simply scaling the number of multiprocessors and memory partitions: from the high-performance enthusiast GeForce GPUs and professional Quadro and Tesla computing products to a variety of inexpensive, mainstream GeForce GPUs (see CUDA-Enabled GPUs for a list of all CUDA-enabled GPUs).\nAutomatic Scalability\n\nFigure 3 Automatic Scalability\uf0c1\n\nNote\n\nA GPU is built around an array of Streaming Multiprocessors (SMs) (see Hardware Implementation for more details). A multithreaded program is partitioned into blocks of threads that execute independently from each other, so that a GPU with more multiprocessors will automatically execute the program in less time than a GPU with fewer multiprocessors.\n\n\n4. Changelog\uf0c1\nTable 1 Change Log\uf0c1\n\nVersion\n\t\n\nChanges\n\n13.0\n\t\n\nMoved the instruction throughput table from the Performance Guidelines section of the CUDA C++ Programming Guide to the Instruction-optimization section of the CUDA C++ Best Practices Guide. Removed unsupported architectures and corrected entries for integer arithmetic and type conversion.\n\n12.9\n\t\n\nAdded section Error Log Management and CUDA_LOG_FILE to CUDA Environment Variables\n\n12.8\n\t\n\nAdded section TMA Swizzle\n5. Programming Model\uf0c1\n\nThis chapter introduces the main concepts behind the CUDA programming model by outlining how they are exposed in C++.\n\nAn extensive description of CUDA C++ is given in Programming Interface.\n\nFull code for the vector addition example used in this chapter and the next can be found in the vectorAdd CUDA sample.\n5.1. Kernels\uf0c1\n\nCUDA C++ extends C++ by allowing the programmer to define C++ functions, called kernels, that, when called, are executed N times in parallel by N different CUDA threads, as opposed to only once like regular C++ functions.\n\nA kernel is defined using the __global__ declaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new <<<...>>>execution configuration syntax (see Execution Configuration). Each thread that executes the kernel is given a unique thread ID that is accessible within the kernel through built-in variables.\n\nAs an illustration, the following sample code, using the built-in variable threadIdx, adds two vectors A and B of size N and stores the result into vector C.\n\n// Kernel definition\n__global__ void VecAdd(float* A, float* B, float* C)\n{\n    int i = threadIdx.x;\n    C[i] = A[i] + B[i];\n}\n\nint main()\n{\n    ...\n    // Kernel invocation with N threads\n    VecAdd<<<1, N>>>(A, B, C);\n    ...\n}\n\nHere, each of the N threads that execute VecAdd() performs one pair-wise addition.\n5.2. Thread Hierarchy\uf0c1\n\nFor convenience, threadIdx is a 3-component vector, so that threads can be identified using a one-dimensional, two-dimensional, or three-dimensional thread index, forming a one-dimensional, two-dimensional, or three-dimensional block of threads, called a thread block. This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume.\n\nThe index of a thread and its thread ID relate to each other in a straightforward way: For a one-dimensional block, they are the same; for a two-dimensional block of size (Dx, Dy), the thread ID of a thread of index (x, y) is (x + y Dx); for a three-dimensional block of size (Dx, Dy, Dz), the thread ID of a thread of index (x, y, z) is (x + y Dx + z Dx Dy).\n\nAs an example, the following code adds two matrices A and B of size NxN and stores the result into matrix C.\n\n// Kernel definition\n__global__ void MatAdd(float A[N][N], float B[N][N],\n                       float C[N][N])\n{\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    C[i][j] = A[i][j] + B[i][j];\n}\n\nint main()\n{\n    ...\n    // Kernel invocation with one block of N * N * 1 threads\n    int numBlocks = 1;\n    dim3 threadsPerBlock(N, N);\n    MatAdd<<<numBlocks, threadsPerBlock>>>(A, B, C);\n    ...\n}\n\nThere is a limit to the number of threads per block, since all threads of a block are expected to reside on the same streaming multiprocessor core and must share the limited memory resources of that core. On current GPUs, a thread block may contain up to 1024 threads.\n\nHowever, a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.\n\nBlocks are organized into a one-dimensional, two-dimensional, or three-dimensional grid of thread blocks as illustrated by Figure 4. The number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system.\nGrid of Thread Blocks\n\nFigure 4 Grid of Thread Blocks\uf0c1\n\nThe number of threads per block and the number of blocks per grid specified in the <<<...>>> syntax can be of type int or dim3. Two-dimensional blocks or grids can be specified as in the example above.\n\nEach block within the grid can be identified by a one-dimensional, two-dimensional, or three-dimensional unique index accessible within the kernel through the built-in blockIdx variable. The dimension of the thread block is accessible within the kernel through the built-in blockDim variable.\n\nExtending the previous MatAdd() example to handle multiple blocks, the code becomes as follows.\n\n// Kernel definition\n__global__ void MatAdd(float A[N][N], float B[N][N],\nfloat C[N][N])\n{\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    int j = blockIdx.y * blockDim.y + threadIdx.y;\n    if (i < N && j < N)\n        C[i][j] = A[i][j] + B[i][j];\n}\n\nint main()\n{\n    ...\n    // Kernel invocation\n    dim3 threadsPerBlock(16, 16);\n    dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);\n    MatAdd<<<numBlocks, threadsPerBlock>>>(A, B, C);\n    ...\n}\n\nA thread block size of 16x16 (256 threads), although arbitrary in this case, is a common choice. The grid is created with enough blocks to have one thread per matrix element as before. For simplicity, this example assumes that the number of threads per grid in each dimension is evenly divisible by the number of threads per block in that dimension, although that need not be the case.\n\nThread blocks are required to execute independently. It must be possible to execute blocks in any order, in parallel or in series. This independence requirement allows thread blocks to be scheduled in any order and across any number of cores as illustrated by Figure 3, enabling programmers to write code that scales with the number of cores.\n\nThreads within a block can cooperate by sharing data through some shared memory and by synchronizing their execution to coordinate memory accesses. More precisely, one can specify synchronization points in the kernel by calling the __syncthreads() intrinsic function; __syncthreads() acts as a barrier at which all threads in the block must wait before any is allowed to proceed. Shared Memory gives an example of using shared memory. In addition to __syncthreads(), the Cooperative Groups API provides a rich set of thread-synchronization primitives.\n\nFor efficient cooperation, shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and __syncthreads() is expected to be lightweight.\n5.2.1. Thread Block Clusters\uf0c1\n\nWith the introduction of NVIDIA Compute Capability 9.0, the CUDA programming model introduces an optional level of hierarchy called Thread Block Clusters that are made up of thread blocks. Similar to how threads in a thread block are guaranteed to be co-scheduled on a streaming multiprocessor, thread blocks in a cluster are also guaranteed to be co-scheduled on a GPU Processing Cluster (GPC) in the GPU.\n\nSimilar to thread blocks, clusters are also organized into a one-dimension, two-dimension, or three-dimension grid of thread block clusters as illustrated by Figure 5. The number of thread blocks in a cluster can be user-defined, and a maximum of 8 thread blocks in a cluster is supported as a portable cluster size in CUDA. Note that on GPU hardware or MIG configurations which are too small to support 8 multiprocessors the maximum cluster size will be reduced accordingly. Identification of these smaller configurations, as well as of larger configurations supporting a thread block cluster size beyond 8, is architecture-specific and can be queried using the cudaOccupancyMaxPotentialClusterSize API.\nGrid of Thread Block Clusters\n\nFigure 5 Grid of Thread Block Clusters\uf0c1\n\nNote\n\nIn a kernel launched using cluster support, the gridDim variable still denotes the size in terms of number of thread blocks, for compatibility purposes. The rank of a block in a cluster can be found using the Cluster Group API.\n\nA thread block cluster can be enabled in a kernel either using a compile-time kernel attribute using __cluster_dims__(X,Y,Z) or using the CUDA kernel launch API cudaLaunchKernelEx. The example below shows how to launch a cluster using a compile-time kernel attribute. The cluster size using kernel attribute is fixed at compile time and then the kernel can be launched using the classical <<< , >>>. If a kernel uses compile-time cluster size, the cluster size cannot be modified when launching the kernel.\n\n// Kernel definition\n// Compile time cluster size 2 in X-dimension and 1 in Y and Z dimension\n__global__ void __cluster_dims__(2, 1, 1) cluster_kernel(float *input, float* output)\n{\n\n}\n\nint main()\n{\n    float *input, *output;\n    // Kernel invocation with compile time cluster size\n    dim3 threadsPerBlock(16, 16);\n    dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);\n\n    // The grid dimension is not affected by cluster launch, and is still enumerated\n    // using number of blocks.\n    // The grid dimension must be a multiple of cluster size.\n    cluster_kernel<<<numBlocks, threadsPerBlock>>>(input, output);\n}\n\nA thread block cluster size can also be set at runtime and the kernel can be launched using the CUDA kernel launch API cudaLaunchKernelEx. The code example below shows how to launch a cluster kernel using the extensible API.\n\n// Kernel definition\n// No compile time attribute attached to the kernel\n__global__ void cluster_kernel(float *input, float* output)\n{\n\n}\n\nint main()\n{\n    float *input, *output;\n    dim3 threadsPerBlock(16, 16);\n    dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);\n\n    // Kernel invocation with runtime cluster size\n    {\n        cudaLaunchConfig_t config = {0};\n        // The grid dimension is not affected by cluster launch, and is still enumerated\n        // using number of blocks.\n        // The grid dimension should be a multiple of cluster size.\n        config.gridDim = numBlocks;\n        config.blockDim = threadsPerBlock;\n\n        cudaLaunchAttribute attribute[1];\n        attribute[0].id = cudaLaunchAttributeClusterDimension;\n        attribute[0].val.clusterDim.x = 2; // Cluster size in X-dimension\n        attribute[0].val.clusterDim.y = 1;\n        attribute[0].val.clusterDim.z = 1;\n        config.attrs = attribute;\n        config.numAttrs = 1;\n\n        cudaLaunchKernelEx(&config, cluster_kernel, input, output);\n    }\n}\n\nIn GPUs with compute capability 9.0, all the thread blocks in the cluster are guaranteed to be co-scheduled on a single GPU Processing Cluster (GPC) and allow thread blocks in the cluster to perform hardware-supported synchronization using the Cluster Group API cluster.sync(). Cluster group also provides member functions to query cluster group size in terms of number of threads or number of blocks using num_threads() and num_blocks() API respectively. The rank of a thread or block in the cluster group can be queried using dim_threads() and dim_blocks() API respectively.\n\nThread blocks that belong to a cluster have access to the Distributed Shared Memory. Thread blocks in a cluster have the ability to read, write, and perform atomics to any address in the distributed shared memory. Distributed Shared Memory gives an example of performing histograms in distributed shared memory.\n5.2.2. Blocks as Clusters\uf0c1\n\nWith __cluster_dims__, the number of launched clusters is kept implicit and can only be calculated manually.\n\n__cluster_dims__((2, 2, 2)) __global__ void foo();\n\n// 8x8x8 clusters each with 2x2x2 thread blocks.\nfoo<<<dim3(16, 16, 16), dim3(1024, 1, 1)>>>();\n\nIn the above example, the kernel is launched as a grid of 16x16x16 thread blocks, or in fact a grid of 8x8x8 clusters. Alternatively, with another compile-time kernel attribute __block_size__, one is allowed to launch a grid explicitly configured with the number of thread block clusters.\n\n// Implementation detail of how many threads per block and blocks per cluster\n// is handled as an attribute of the kernel.\n__block_size__((1024, 1, 1), (2, 2, 2)) __global__ void foo();\n\n// 8x8x8 clusters.\nfoo<<<dim3(8, 8, 8)>>>();\n\n__block_size__ requires two fields each being a tuple of 3 elements. The first tuple denotes block dimension and second cluster size. The second tuple is assumed to be (1,1,1) if it\u2019s not passed. To specify the stream, one must pass 1 and 0 as the second and third arguments within <<<>>> and lastly the stream. Passing other values would lead to undefined behavior.\n\nNote that it is illegal for the second tuple of __block_size__ and __cluster_dims__ to be specified at the same time. When the second tuple of __block_size__ is specified, it implies the \u201cBlocks as Clusters\u201d being enabled and the compiler would recognize the first argument inside <<<>>> as the number of clusters instead of thread blocks.\n5.3. Memory Hierarchy\uf0c1\n\nCUDA threads may access data from multiple memory spaces during their execution as illustrated by Figure 6. Each thread has private local memory. Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block. Thread blocks in a thread block cluster can perform read, write, and atomics operations on each other\u2019s shared memory. All threads have access to the same global memory.\n\nThere are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces. The global, constant, and texture memory spaces are optimized for different memory usages (see Device Memory Accesses). Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see Texture and Surface Memory).\n\nThe global, constant, and texture memory spaces are persistent across kernel launches by the same application.\nMemory Hierarchy\n\nFigure 6 Memory Hierarchy\uf0c1\n5.4. Heterogeneous Programming\uf0c1\n\nAs illustrated by Figure 7, the CUDA programming model assumes that the CUDA threads execute on a physically separate device that operates as a coprocessor to the host running the C++ program. This is the case, for example, when the kernels execute on a GPU and the rest of the C++ program executes on a CPU.\n\nThe CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as host memory and device memory, respectively. Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in Programming Interface). This includes device memory allocation and deallocation as well as data transfer between host and device memory.\n\nUnified Memory provides managed memory to bridge the host and device memory spaces. Managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. This capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device. See Unified Memory Programming for an introduction to Unified Memory.\nHeterogeneous Programming\n\nFigure 7 Heterogeneous Programming\uf0c1\n\nNote\n\nSerial code executes on the host while parallel code executes on the device.\n5.5. Asynchronous SIMT Programming Model\uf0c1\n\nIn the CUDA programming model a thread is the lowest level of abstraction for doing a computation or a memory operation. Starting with devices based on the NVIDIA Ampere GPU Architecture, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model. The asynchronous programming model defines the behavior of asynchronous operations with respect to CUDA threads.\n\nThe asynchronous programming model defines the behavior of Asynchronous Barrier for synchronization between CUDA threads. The model also explains and defines how cuda::memcpy_async can be used to move data asynchronously from global memory while computing in the GPU.\n5.5.1. Asynchronous Operations\uf0c1\n\nAn asynchronous operation is defined as an operation that is initiated by a CUDA thread and is executed asynchronously as-if by another thread. In a well formed program one or more CUDA threads synchronize with the asynchronous operation. The CUDA thread that initiated the asynchronous operation is not required to be among the synchronizing threads.\n\nSuch an asynchronous thread (an as-if thread) is always associated with the CUDA thread that initiated the asynchronous operation. An asynchronous operation uses a synchronization object to synchronize the completion of the operation. Such a synchronization object can be explicitly managed by a user (e.g., cuda::memcpy_async) or implicitly managed within a library (e.g., cooperative_groups::memcpy_async).\n\nA synchronization object could be a cuda::barrier or a cuda::pipeline. These objects are explained in detail in Asynchronous Barrier and Asynchronous Data Copies using cuda::pipeline. These synchronization objects can be used at different thread scopes. A scope defines the set of threads that may use the synchronization object to synchronize with the asynchronous operation. The following table defines the thread scopes available in CUDA C++ and the threads that can be synchronized with each.\n\nThread Scope\n\t\n\nDescription\n\ncuda::thread_scope::thread_scope_thread\n\t\n\nOnly the CUDA thread which initiated asynchronous operations synchronizes.\n\ncuda::thread_scope::thread_scope_block\n\t\n\nAll or any CUDA threads within the same thread block as the initiating thread synchronizes.\n\ncuda::thread_scope::thread_scope_device\n\t\n\nAll or any CUDA threads in the same GPU device as the initiating thread synchronizes.\n\ncuda::thread_scope::thread_scope_system\n\t\n\nAll or any CUDA or CPU threads in the same system as the initiating thread synchronizes.\n\nThese thread scopes are implemented as extensions to standard C++ in the CUDA Standard C++ library.\n5.6. Compute Capability\uf0c1\n\nThe compute capability of a device is represented by a version number, also sometimes called its \u201cSM version\u201d. This version number identifies the features supported by the GPU hardware and is used by applications at runtime to determine which hardware features and/or instructions are available on the present GPU.\n\nThe compute capability comprises a major revision number X and a minor revision number Y and is denoted by X.Y.\n\nThe major revision number indicates the core GPU architecture of a device. Devices with the same major revision number share the same fundamental architecture. The table below lists the major revision numbers corresponding to each NVIDIA GPU architecture.\nTable 2 GPU Architecture and Major Revision Numbers\uf0c1\n\nMajor Revision Number\n\t\n\nNVIDIA GPU Architecture\n\n9\n\t\n\nNVIDIA Hopper GPU Architecture\n\n8\n\t\n\nNVIDIA Ampere GPU Architecture\n\n7\n\t\n\nNVIDIA Volta GPU Architecture\n\n6\n\t\n\nNVIDIA Pascal GPU Architecture\n\n5\n\t\n\nNVIDIA Maxwell GPU Architecture\n\n3\n\t\n\nNVIDIA Kepler GPU Architecture\n\nThe minor revision number corresponds to an incremental improvement to the core architecture, possibly including new features.\nTable 3 Incremental Updates in GPU Architectures\uf0c1\n\nCompute Capability\n\t\n\nNVIDIA GPU Architecture\n\t\n\nBased On\n\n7.5\n\t\n\nNVIDIA Turing GPU Architecture\n\t\n\nNVIDIA Volta GPU Architecture\n\nCUDA-Enabled GPUs lists of all CUDA-enabled devices along with their compute capability. Compute Capabilities gives the technical specifications of each compute capability.\n\nNote\n\nThe compute capability version of a particular GPU should not be confused with the CUDA version (for example, CUDA 7.5, CUDA 8, CUDA 9), which is the version of the CUDA software platform. The CUDA platform is used by application developers to create applications that run on many generations of GPU architectures, including future GPU architectures yet to be invented. While new versions of the CUDA platform often add native support for a new GPU architecture by supporting the compute capability version of that architecture, new versions of the CUDA platform typically also include software features that are independent of hardware generation.\n\nThe Tesla and Fermi architectures are no longer supported starting with CUDA 7.0 and CUDA 9.0, respectively.\n6. Programming Interface\uf0c1\n\nCUDA C++ provides a simple path for users familiar with the C++ programming language to easily write programs for execution by the device.\n\nIt consists of a minimal set of extensions to the C++ language and a runtime library.\n\nThe core language extensions have been introduced in Programming Model. They allow programmers to define a kernel as a C++ function and use some new syntax to specify the grid and block dimension each time the function is called. A complete description of all extensions can be found in C++ Language Extensions. Any source file that contains some of these extensions must be compiled with nvcc as outlined in Compilation with NVCC.\n\nThe runtime is introduced in CUDA Runtime. It provides C and C++ functions that execute on the host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc. A complete description of the runtime can be found in the CUDA reference manual.\n\nThe runtime is built on top of a lower-level C API, the CUDA driver API, which is also accessible by the application. The driver API provides an additional level of control by exposing lower-level concepts such as CUDA contexts - the analogue of host processes for the device - and CUDA modules - the analogue of dynamically loaded libraries for the device. Most applications do not use the driver API as they do not need this additional level of control and when using the runtime, context and module management are implicit, resulting in more concise code. As the runtime is interoperable with the driver API, most applications that need some driver API features can default to use the runtime API and only use the driver API where needed. The driver API is introduced in Driver API and fully described in the reference manual.\n6.1. Compilation with NVCC\uf0c1\n\nKernels can be written using the CUDA instruction set architecture, called PTX, which is described in the PTX reference manual. It is however usually more effective to use a high-level programming language such as C++. In both cases, kernels must be compiled into binary code by nvcc to execute on the device.\n\nnvcc is a compiler driver that simplifies the process of compiling C++ or PTX code: It provides simple and familiar command line options and executes them by invoking the collection of tools that implement the different compilation stages. This section gives an overview of nvcc workflow and command options. A complete description can be found in the nvcc user manual.\n6.1.1. Compilation Workflow\uf0c1\n6.1.1.1. Offline Compilation\uf0c1\n\nSource files compiled with nvcc can include a mix of host code (i.e., code that executes on the host) and device code (i.e., code that executes on the device). nvcc\u2019s basic workflow consists in separating device code from host code and then:\n\n    compiling the device code into an assembly form (PTX code) and/or binary form (cubin object),\n\n    and modifying the host code by replacing the <<<...>>> syntax introduced in Kernels (and described in more details in Execution Configuration) by the necessary CUDA runtime function calls to load and launch each compiled kernel from the PTX code and/or cubin object.\n\nThe modified host code is output either as C++ code that is left to be compiled using another tool or as object code directly by letting nvcc invoke the host compiler during the last compilation stage.\n\nApplications can then:\n\n    Either link to the compiled host code (this is the most common case),\n\n    Or ignore the modified host code (if any) and use the CUDA driver API (see Driver API) to load and execute the PTX code or cubin object.\n\n6.1.1.2. Just-in-Time Compilation\uf0c1\n\nAny PTX code loaded by an application at runtime is compiled further to binary code by the device driver. This is called just-in-time compilation. Just-in-time compilation increases application load time, but allows the application to benefit from any new compiler improvements coming with each new device driver. It is also the only way for applications to run on devices that did not exist at the time the application was compiled, as detailed in Application Compatibility.\n\nWhen the device driver just-in-time compiles some PTX code for some application, it automatically caches a copy of the generated binary code in order to avoid repeating the compilation in subsequent invocations of the application. The cache - referred to as compute cache - is automatically invalidated when the device driver is upgraded, so that applications can benefit from the improvements in the new just-in-time compiler built into the device driver.\n\nEnvironment variables are available to control just-in-time compilation as described in CUDA Environment Variables\n\nAs an alternative to using nvcc to compile CUDA C++ device code, NVRTC can be used to compile CUDA C++ device code to PTX at runtime. NVRTC is a runtime compilation library for CUDA C++; more information can be found in the NVRTC User guide.\n6.1.2. Binary Compatibility\uf0c1\n\nBinary code is architecture-specific. A cubin object is generated using the compiler option -code that specifies the targeted architecture: For example, compiling with -code=sm_80 produces binary code for devices of compute capability 8.0. Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions. In other words, a cubin object generated for compute capability X.y will only execute on devices of compute capability X.z where z\u2265y.\n\nNote\n\nBinary compatibility is supported only for the desktop. It is not supported for Tegra. Also, the binary compatibility between desktop and Tegra is not supported.\n6.1.3. PTX Compatibility\uf0c1\n\nSome PTX instructions are only supported on devices of higher compute capabilities. For example, Warp Shuffle Functions are only supported on devices of compute capability 5.0 and above. The -arch compiler option specifies the compute capability that is assumed when compiling C++ to PTX code. So, code that contains warp shuffle, for example, must be compiled with -arch=compute_50 (or higher).\n\nPTX code produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability. Note that a binary compiled from an earlier PTX version may not make use of some hardware features. For example, a binary targeting devices of compute capability 7.0 (Volta) compiled from PTX generated for compute capability 6.0 (Pascal) will not make use of Tensor Core instructions, since these were not available on Pascal. As a result, the final binary may perform worse than would be possible if the binary were generated using the latest version of PTX.\n\nPTX code compiled to target Architecture-Specific Features only runs on the exact same physical architecture and nowhere else. Architecture-specific PTX code is not forward and backward compatible. Example code compiled with sm_90a or compute_90a only runs on devices with compute capability 9.0 and is not backward or forward compatible.\n\nPTX code compiled to target Family-Specific Features only runs on the exact same physical architecture and other architectures in the same family. Family-specific PTX code is forward compatible with other devices in the same family, and is not backward compatible. Example code compiled with sm_100f or compute_100f only runs on devices with compute capability 10.0 and 10.3. Table 25 shows the compatibility of family-specific targets with compute capability.\n6.1.4. Application Compatibility\uf0c1\n\nTo execute code on devices of specific compute capability, an application must load binary or PTX code that is compatible with this compute capability as described in Binary Compatibility and PTX Compatibility. In particular, to be able to execute code on future architectures with higher compute capability (for which no binary code can be generated yet), an application must load PTX code that will be just-in-time compiled for these devices (see Just-in-Time Compilation).\n\nWhich PTX and binary code gets embedded in a CUDA C++ application is controlled by the -arch and -code compiler options or the -gencode compiler option as detailed in the nvcc user manual. For example,\n\nnvcc x.cu\n        -gencode arch=compute_50,code=sm_50\n        -gencode arch=compute_60,code=sm_60\n        -gencode arch=compute_70,code=\\\"compute_70,sm_70\\\"\n\nembeds binary code compatible with compute capability 5.0 and 6.0 (first and second -gencode options) and PTX and binary code compatible with compute capability 7.0 (third -gencode option).\n\nHost code is generated to automatically select at runtime the most appropriate code to load and execute, which, in the above example, will be:\n\n    5.0 binary code for devices with compute capability 5.0 and 5.2,\n\n    6.0 binary code for devices with compute capability 6.0 and 6.1,\n\n    7.0 binary code for devices with compute capability 7.0 and 7.5,\n\n    PTX code which is compiled to binary code at runtime for devices with compute capability later than 7.5\n\nx.cu can have an optimized code path that uses warp reduction operations, for example, which are only supported in devices of compute capability 8.0 and higher. The __CUDA_ARCH__ macro can be used to differentiate various code paths based on compute capability. It is only defined for device code. When compiling with -arch=compute_80 for example, __CUDA_ARCH__ is equal to 800.\n\nIf x.cu is compiled for Family-Specific Features with sm_100f or compute_100f, the code can only run on devices in that specific family, which are devices with compute capability 10.0 and 10.3. For family-specific code targets an additional macro __CUDA_ARCH_FAMILY_SPECIFIC__ is defined. In this example, __CUDA_ARCH_FAMILY_SPECIFIC__ is equal to 1000.\n\nIf x.cu is compiled for Architecture-Specific Features with sm_100a or compute_100a, the code can only run on devices with compute capability 10.0. For architecture-specific code targets an additional macro __CUDA_ARCH_SPECIFIC__ is defined. In this example, __CUDA_ARCH_SPECIFIC__ is equal to 1000. Because architecture-specific features are a superset of family-specific features, the family-specific macro __CUDA_ARCH_FAMILY_SPECIFIC__ is also defined and is equal to 1000.\n\nApplications using the driver API must compile code to separate files and explicitly load and execute the most appropriate file at runtime.\n\nThe Volta architecture introduces Independent Thread Scheduling which changes the way threads are scheduled on the GPU. For code relying on specific behavior of SIMT scheduling in previous architectures, Independent Thread Scheduling may alter the set of participating threads, leading to incorrect results. To aid migration while implementing the corrective actions detailed in Independent Thread Scheduling, Volta developers can opt-in to Pascal\u2019s thread scheduling with the compiler option combination -arch=compute_60 -code=sm_70.\n\nThe nvcc user manual lists various shorthands for the -arch, -code, and -gencode compiler options. For example, -arch=sm_70 is a shorthand for -arch=compute_70 -code=compute_70,sm_70 (which is the same as -gencode arch=compute_70,code=\\\"compute_70,sm_70\\\").\n6.1.5. C++ Compatibility\uf0c1\n\nThe front end of the compiler processes CUDA source files according to C++ syntax rules. Full C++ is supported for the host code. However, only a subset of C++ is fully supported for the device code as described in C++ Language Support.\n6.1.6. 64-Bit Compatibility\uf0c1\n\nThe 64-bit version of nvcc compiles device code in 64-bit mode (i.e., pointers are 64-bit). Device code compiled in 64-bit mode is only supported with host code compiled in 64-bit mode.\n6.2. CUDA Runtime\uf0c1\n\nThe runtime is implemented in the cudart library, which is linked to the application, either statically via cudart.lib or libcudart.a, or dynamically via cudart.dll or libcudart.so. Applications that require cudart.dll and/or cudart.so for dynamic linking typically include them as part of the application installation package. It is only safe to pass the address of CUDA runtime symbols between components that link to the same instance of the CUDA runtime.\n\nAll its entry points are prefixed with cuda.\n\nAs mentioned in Heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Device Memory gives an overview of the runtime functions used to manage device memory.\n\nShared Memory illustrates the use of shared memory, introduced in Thread Hierarchy, to maximize performance.\n\nPage-Locked Host Memory introduces page-locked host memory that is required to overlap kernel execution with data transfers between host and device memory.\n\nAsynchronous Concurrent Execution describes the concepts and API used to enable asynchronous concurrent execution at various levels in the system.\n\nMulti-Device System shows how the programming model extends to a system with multiple devices attached to the same host.\n\nError Checking describes how to properly check the errors generated by the runtime.\n\nCall Stack mentions the runtime functions used to manage the CUDA C++ call stack.\n\nTexture and Surface Memory presents the texture and surface memory spaces that provide another way to access device memory; they also expose a subset of the GPU texturing hardware.\n\nGraphics Interoperability introduces the various functions the runtime provides to interoperate with the two main graphics APIs, OpenGL and Direct3D.\n6.2.1. Initialization\uf0c1\n\nAs of CUDA 12.0, the cudaInitDevice() and cudaSetDevice() calls initialize the runtime and the primary context associated with the specified device. Absent these calls, the runtime will implicitly use device 0 and self-initialize as needed to process other runtime API requests. One needs to keep this in mind when timing runtime function calls and when interpreting the error code from the first call into the runtime. Before 12.0, cudaSetDevice() would not initialize the runtime and applications would often use the no-op runtime call cudaFree(0) to isolate the runtime initialization from other api activity (both for the sake of timing and error handling).\n\nThe runtime creates a CUDA context for each device in the system (see Context for more details on CUDA contexts). This context is the primary context for this device and is initialized at the first runtime function which requires an active context on this device. It is shared among all the host threads of the application. As part of this context creation, the device code is just-in-time compiled if necessary (see Just-in-Time Compilation) and loaded into device memory. This all happens transparently. If needed, for example, for driver API interoperability, the primary context of a device can be accessed from the driver API as described in Interoperability between Runtime and Driver APIs.\n\nWhen a host thread calls cudaDeviceReset(), this destroys the primary context of the device the host thread currently operates on (that is, the current device as defined in Device Selection). The next runtime function call made by any host thread that has this device as current will create a new primary context for this device.\n\nNote\n\nThe CUDA interfaces use global state that is initialized during host program initiation and destroyed during host program termination. The CUDA runtime and driver cannot detect if this state is invalid, so using any of these interfaces (implicitly or explicitly) during program initiation or termination after main) will result in undefined behavior.\n\nAs of CUDA 12.0, cudaSetDevice() will now explicitly initialize the runtime after changing the current device for the host thread. Previous versions of CUDA delayed runtime initialization on the new device until the first runtime call was made after cudaSetDevice(). This change means that it is now very important to check the return value of cudaSetDevice() for initialization errors.\n\nThe runtime functions from the error handling and version management sections of the reference manual do not initialize the runtime.\n6.2.2. Device Memory\uf0c1\n\nAs mentioned in Heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.\n\nDevice memory can be allocated either as linear memory or as CUDA arrays.\n\nCUDA arrays are opaque memory layouts optimized for texture fetching. They are described in Texture and Surface Memory.\n\nLinear memory is allocated in a single unified address space, which means that separately allocated entities can reference one another via pointers, for example, in a binary tree or linked list. The size of the address space depends on the host system (CPU) and the compute capability of the used GPU:\nTable 4 Linear Memory Address Space\uf0c1 \t\n\nx86_64 (AMD64)\n\t\n\nPOWER (ppc64le)\n\t\n\nARM64\n\nup to compute capability 5.3 (Maxwell)\n\t\n\n40bit\n\t\n\n40bit\n\t\n\n40bit\n\ncompute capability 6.0 (Pascal) or newer\n\t\n\nup to 47bit\n\t\n\nup to 49bit\n\t\n\nup to 48bit\n\nNote\n\nOn devices of compute capability 5.3 (Maxwell) and earlier, the CUDA driver creates an uncommitted 40bit virtual address reservation to ensure that memory allocations (pointers) fall into the supported range. This reservation appears as reserved virtual memory, but does not occupy any physical memory until the program actually allocates memory.\n\nLinear memory is typically allocated using cudaMalloc() and freed using cudaFree() and data transfer between host memory and device memory are typically done using cudaMemcpy(). In the vector addition code sample of Kernels, the vectors need to be copied from host memory to device memory:\n\n// Device code\n__global__ void VecAdd(float* A, float* B, float* C, int N)\n{\n    int i = blockDim.x * blockIdx.x + threadIdx.x;\n    if (i < N)\n        C[i] = A[i] + B[i];\n}\n\n// Host code\nint main()\n{\n    int N = ...;\n    size_t size = N * sizeof(float);\n\n    // Allocate input vectors h_A and h_B in host memory\n    float* h_A = (float*)malloc(size);\n    float* h_B = (float*)malloc(size);\n    float* h_C = (float*)malloc(size);\n\n    // Initialize input vectors\n    ...\n\n    // Allocate vectors in device memory\n    float* d_A;\n    cudaMalloc(&d_A, size);\n    float* d_B;\n    cudaMalloc(&d_B, size);\n    float* d_C;\n    cudaMalloc(&d_C, size);\n\n    // Copy vectors from host memory to device memory\n    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);\n\n    // Invoke kernel\n    int threadsPerBlock = 256;\n    int blocksPerGrid =\n            (N + threadsPerBlock - 1) / threadsPerBlock;\n    VecAdd<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_B, d_C, N);\n\n    // Copy result from device memory to host memory\n    // h_C contains the result in host memory\n    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);\n\n    // Free device memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n\n    // Free host memory\n    ...\n}\n\nLinear memory can also be allocated through cudaMallocPitch() and cudaMalloc3D(). These functions are recommended for allocations of 2D or 3D arrays as it makes sure that the allocation is appropriately padded to meet the alignment requirements described in Device Memory Accesses, therefore ensuring best performance when accessing the row addresses or performing copies between 2D arrays and other regions of device memory (using the cudaMemcpy2D() and cudaMemcpy3D() functions). The returned pitch (or stride) must be used to access array elements. The following code sample allocates a width x height 2D array of floating-point values and shows how to loop over the array elements in device code:\n\n// Host code\nint width = 64, height = 64;\nfloat* devPtr;\nsize_t pitch;\ncudaMallocPitch(&devPtr, &pitch,\n                width * sizeof(float), height);\nMyKernel<<<100, 512>>>(devPtr, pitch, width, height);\n\n// Device code\n__global__ void MyKernel(float* devPtr,\n                         size_t pitch, int width, int height)\n{\n    for (int r = 0; r < height; ++r) {\n        float* row = (float*)((char*)devPtr + r * pitch);\n        for (int c = 0; c < width; ++c) {\n            float element = row[c];\n        }\n    }\n}\n\nThe following code sample allocates a width x height x depth 3D array of floating-point values and shows how to loop over the array elements in device code:\n\n// Host code\nint width = 64, height = 64, depth = 64;\ncudaExtent extent = make_cudaExtent(width * sizeof(float),\n                                    height, depth);\ncudaPitchedPtr devPitchedPtr;\ncudaMalloc3D(&devPitchedPtr, extent);\nMyKernel<<<100, 512>>>(devPitchedPtr, width, height, depth);\n\n// Device code\n__global__ void MyKernel(cudaPitchedPtr devPitchedPtr,\n                         int width, int height, int depth)\n{\n    char* devPtr = devPitchedPtr.ptr;\n    size_t pitch = devPitchedPtr.pitch;\n    size_t slicePitch = pitch * height;\n    for (int z = 0; z < depth; ++z) {\n        char* slice = devPtr + z * slicePitch;\n        for (int y = 0; y < height; ++y) {\n            float* row = (float*)(slice + y * pitch);\n            for (int x = 0; x < width; ++x) {\n                float element = row[x];\n            }\n        }\n    }\n}\n\nNote\n\nTo avoid allocating too much memory and thus impacting system-wide performance, request the allocation parameters from the user based on the problem size. If the allocation fails, you can fallback to other slower memory types (cudaMallocHost(), cudaHostRegister(), etc.), or return an error telling the user how much memory was needed that was denied. If your application cannot request the allocation parameters for some reason, we recommend using cudaMallocManaged() for platforms that support it.\n\nThe reference manual lists all the various functions used to copy memory between linear memory allocated with cudaMalloc(), linear memory allocated with cudaMallocPitch() or cudaMalloc3D(), CUDA arrays, and memory allocated for variables declared in global or constant memory space.\n\nThe following code sample illustrates various ways of accessing global variables via the runtime API:\n\n__constant__ float constData[256];\nfloat data[256];\ncudaMemcpyToSymbol(constData, data, sizeof(data));\ncudaMemcpyFromSymbol(data, constData, sizeof(data));\n\n__device__ float devData;\nfloat value = 3.14f;\ncudaMemcpyToSymbol(devData, &value, sizeof(float));\n\n__device__ float* devPointer;\nfloat* ptr;\ncudaMalloc(&ptr, 256 * sizeof(float));\ncudaMemcpyToSymbol(devPointer, &ptr, sizeof(ptr));\n\ncudaGetSymbolAddress() is used to retrieve the address pointing to the memory allocated for a variable declared in global memory space. The size of the allocated memory is obtained through cudaGetSymbolSize().\n6.2.3. Device Memory L2 Access Management\uf0c1\n\nWhen a CUDA kernel accesses a data region in the global memory repeatedly, such data accesses can be considered to be persisting. On the other hand, if the data is only accessed once, such data accesses can be considered to be streaming.\n\nStarting with CUDA 11.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache, potentially providing higher bandwidth and lower latency accesses to global memory.\n6.2.3.1. L2 Cache Set-Aside for Persisting Accesses\uf0c1\n\nA portion of the L2 cache can be set aside to be used for persisting data accesses to global memory. Persisting accesses have prioritized use of this set-aside portion of L2 cache, whereas normal or streaming, accesses to global memory can only utilize this portion of L2 when it is unused by persisting accesses.\n\nThe L2 cache set-aside size for persisting accesses may be adjusted, within limits:\n\ncudaGetDeviceProperties(&prop, device_id);\nsize_t size = min(int(prop.l2CacheSize * 0.75), prop.persistingL2CacheMaxSize);\ncudaDeviceSetLimit(cudaLimitPersistingL2CacheSize, size); /* set-aside 3/4 of L2 cache for persisting accesses or the max allowed*/\n\nWhen the GPU is configured in Multi-Instance GPU (MIG) mode, the L2 cache set-aside functionality is disabled.\n\nWhen using the Multi-Process Service (MPS), the L2 cache set-aside size cannot be changed by cudaDeviceSetLimit. Instead, the set-aside size can only be specified at start up of MPS server through the environment variable CUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT.\n6.2.3.2. L2 Policy for Persisting Accesses\uf0c1\n\nAn access policy window specifies a contiguous region of global memory and a persistence property in the L2 cache for accesses within that region.\n\nThe code example below shows how to set an L2 persisting access window using a CUDA Stream.\n\nCUDA Stream Example\n\ncudaStreamAttrValue stream_attribute;                                         // Stream level attributes data structure\nstream_attribute.accessPolicyWindow.base_ptr  = reinterpret_cast<void*>(ptr); // Global Memory data pointer\nstream_attribute.accessPolicyWindow.num_bytes = num_bytes;                    // Number of bytes for persistence access.\n                                                                              // (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)\nstream_attribute.accessPolicyWindow.hitRatio  = 0.6;                          // Hint for cache hit ratio\nstream_attribute.accessPolicyWindow.hitProp   = cudaAccessPropertyPersisting; // Type of access property on cache hit\nstream_attribute.accessPolicyWindow.missProp  = cudaAccessPropertyStreaming;  // Type of access property on cache miss.\n\n//Set the attributes to a CUDA stream of type cudaStream_t\ncudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_attribute);\n\nWhen a kernel subsequently executes in CUDA stream, memory accesses within the global memory extent [ptr..ptr+num_bytes) are more likely to persist in the L2 cache than accesses to other global memory locations.\n\nL2 persistence can also be set for a CUDA Graph Kernel Node as shown in the example below:\n\nCUDA GraphKernelNode Example\n\ncudaKernelNodeAttrValue node_attribute;                                     // Kernel level attributes data structure\nnode_attribute.accessPolicyWindow.base_ptr  = reinterpret_cast<void*>(ptr); // Global Memory data pointer\nnode_attribute.accessPolicyWindow.num_bytes = num_bytes;                    // Number of bytes for persistence access.\n                                                                            // (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)\nnode_attribute.accessPolicyWindow.hitRatio  = 0.6;                          // Hint for cache hit ratio\nnode_attribute.accessPolicyWindow.hitProp   = cudaAccessPropertyPersisting; // Type of access property on cache hit\nnode_attribute.accessPolicyWindow.missProp  = cudaAccessPropertyStreaming;  // Type of access property on cache miss.\n\n//Set the attributes to a CUDA Graph Kernel node of type cudaGraphNode_t\ncudaGraphKernelNodeSetAttribute(node, cudaKernelNodeAttributeAccessPolicyWindow, &node_attribute);\n\nThe hitRatio parameter can be used to specify the fraction of accesses that receive the hitProp property. In both of the examples above, 60% of the memory accesses in the global memory region [ptr..ptr+num_bytes) have the persisting property and 40% of the memory accesses have the streaming property. Which specific memory accesses are classified as persisting (the hitProp) is random with a probability of approximately hitRatio; the probability distribution depends upon the hardware architecture and the memory extent.\n\nFor example, if the L2 set-aside cache size is 16KB and the num_bytes in the accessPolicyWindow is 32KB:\n\n    With a hitRatio of 0.5, the hardware will select, at random, 16KB of the 32KB window to be designated as persisting and cached in the set-aside L2 cache area.\n\n    With a hitRatio of 1.0, the hardware will attempt to cache the whole 32KB window in the set-aside L2 cache area. Since the set-aside area is smaller than the window, cache lines will be evicted to keep the most recently used 16KB of the 32KB data in the set-aside portion of the L2 cache.\n\nThe hitRatio can therefore be used to avoid thrashing of cache lines and overall reduce the amount of data moved into and out of the L2 cache.\n\nA hitRatio value below 1.0 can be used to manually control the amount of data different accessPolicyWindows from concurrent CUDA streams can cache in L2. For example, let the L2 set-aside cache size be 16KB; two concurrent kernels in two different CUDA streams, each with a 16KB accessPolicyWindow, and both with hitRatio value 1.0, might evict each others\u2019 cache lines when competing for the shared L2 resource. However, if both accessPolicyWindows have a hitRatio value of 0.5, they will be less likely to evict their own or each others\u2019 persisting cache lines.\n6.2.3.3. L2 Access Properties\uf0c1\n\nThree types of access properties are defined for different global memory data accesses:\n\n    cudaAccessPropertyStreaming: Memory accesses that occur with the streaming property are less likely to persist in the L2 cache because these accesses are preferentially evicted.\n\n    cudaAccessPropertyPersisting: Memory accesses that occur with the persisting property are more likely to persist in the L2 cache because these accesses are preferentially retained in the set-aside portion of L2 cache.\n\n    cudaAccessPropertyNormal: This access property forcibly resets previously applied persisting access property to a normal status. Memory accesses with the persisting property from previous CUDA kernels may be retained in L2 cache long after their intended use. This persistence-after-use reduces the amount of L2 cache available to subsequent kernels that do not use the persisting property. Resetting an access property window with the cudaAccessPropertyNormal property removes the persisting (preferential retention) status of the prior access, as if the prior access had been without an access property.\n\n6.2.3.4. L2 Persistence Example\uf0c1\n\nThe following example shows how to set-aside L2 cache for persistent accesses, use the set-aside L2 cache in CUDA kernels via CUDA Stream and then reset the L2 cache.\n\ncudaStream_t stream;\ncudaStreamCreate(&stream);                                                                  // Create CUDA stream\n\ncudaDeviceProp prop;                                                                        // CUDA device properties variable\ncudaGetDeviceProperties( &prop, device_id);                                                 // Query GPU properties\nsize_t size = min( int(prop.l2CacheSize * 0.75) , prop.persistingL2CacheMaxSize );\ncudaDeviceSetLimit( cudaLimitPersistingL2CacheSize, size);                                  // set-aside 3/4 of L2 cache for persisting accesses or the max allowed\n\nsize_t window_size = min(prop.accessPolicyMaxWindowSize, num_bytes);                        // Select minimum of user defined num_bytes and max window size.\n\ncudaStreamAttrValue stream_attribute;                                                       // Stream level attributes data structure\nstream_attribute.accessPolicyWindow.base_ptr  = reinterpret_cast<void*>(data1);               // Global Memory data pointer\nstream_attribute.accessPolicyWindow.num_bytes = window_size;                                // Number of bytes for persistence access\nstream_attribute.accessPolicyWindow.hitRatio  = 0.6;                                        // Hint for cache hit ratio\nstream_attribute.accessPolicyWindow.hitProp   = cudaAccessPropertyPersisting;               // Persistence Property\nstream_attribute.accessPolicyWindow.missProp  = cudaAccessPropertyStreaming;                // Type of access property on cache miss\n\ncudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_attribute);   // Set the attributes to a CUDA Stream\n\nfor(int i = 0; i < 10; i++) {\n    cuda_kernelA<<<grid_size,block_size,0,stream>>>(data1);                                 // This data1 is used by a kernel multiple times\n}                                                                                           // [data1 + num_bytes) benefits from L2 persistence\ncuda_kernelB<<<grid_size,block_size,0,stream>>>(data1);                                     // A different kernel in the same stream can also benefit\n                                                                                            // from the persistence of data1\n\nstream_attribute.accessPolicyWindow.num_bytes = 0;                                          // Setting the window size to 0 disable it\ncudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_attribute);   // Overwrite the access policy attribute to a CUDA Stream\ncudaCtxResetPersistingL2Cache();                                                            // Remove any persistent lines in L2\n\ncuda_kernelC<<<grid_size,block_size,0,stream>>>(data2);                                     // data2 can now benefit from full L2 in normal mode\n\n6.2.3.5. Reset L2 Access to Normal\uf0c1\n\nA persisting L2 cache line from a previous CUDA kernel may persist in L2 long after it has been used. Hence, a reset to normal for L2 cache is important for streaming or normal memory accesses to utilize the L2 cache with normal priority. There are three ways a persisting access can be reset to normal status.\n\n    Reset a previous persisting memory region with the access property, cudaAccessPropertyNormal.\n\n    Reset all persisting L2 cache lines to normal by calling cudaCtxResetPersistingL2Cache().\n\n    Eventually untouched lines are automatically reset to normal. Reliance on automatic reset is strongly discouraged because of the undetermined length of time required for automatic reset to occur.\n\n6.2.3.6. Manage Utilization of L2 set-aside cache\uf0c1\n\nMultiple CUDA kernels executing concurrently in different CUDA streams may have a different access policy window assigned to their streams. However, the L2 set-aside cache portion is shared among all these concurrent CUDA kernels. As a result, the net utilization of this set-aside cache portion is the sum of all the concurrent kernels\u2019 individual use. The benefits of designating memory accesses as persisting diminish as the volume of persisting accesses exceeds the set-aside L2 cache capacity.\n\nTo manage utilization of the set-aside L2 cache portion, an application must consider the following:\n\n    Size of L2 set-aside cache.\n\n    CUDA kernels that may concurrently execute.\n\n    The access policy window for all the CUDA kernels that may concurrently execute.\n\n    When and how L2 reset is required to allow normal or streaming accesses to utilize the previously set-aside L2 cache with equal priority.\n\n6.2.3.7. Query L2 cache Properties\uf0c1\n\nProperties related to L2 cache are a part of cudaDeviceProp struct and can be queried using CUDA runtime API cudaGetDeviceProperties\n\nCUDA Device Properties include:\n\n    l2CacheSize: The amount of available L2 cache on the GPU.\n\n    persistingL2CacheMaxSize: The maximum amount of L2 cache that can be set-aside for persisting memory accesses.\n\n    accessPolicyMaxWindowSize: The maximum size of the access policy window.\n\n6.2.3.8. Control L2 Cache Set-Aside Size for Persisting Memory Access\uf0c1\n\nThe L2 set-aside cache size for persisting memory accesses is queried using CUDA runtime API cudaDeviceGetLimit and set using CUDA runtime API cudaDeviceSetLimit as a cudaLimit. The maximum value for setting this limit is cudaDeviceProp::persistingL2CacheMaxSize.\n\nenum cudaLimit {\n    /* other fields not shown */\n    cudaLimitPersistingL2CacheSize\n};\n\n6.2.4. Shared Memory\uf0c1\n\nAs detailed in Variable Memory Space Specifiers shared memory is allocated using the __shared__ memory space specifier.\n\nShared memory is expected to be much faster than global memory as mentioned in Thread Hierarchy and detailed in Shared Memory. It can be used as scratchpad memory (or software managed cache) to minimize global memory accesses from a CUDA block as illustrated by the following matrix multiplication example.\n\nThe following code sample is a straightforward implementation of matrix multiplication that does not take advantage of shared memory. Each thread reads one row of A and one column of B and computes the corresponding element of C as illustrated in Figure 8. A is therefore read B.width times from global memory and B is read A.height times.\n\n// Matrices are stored in row-major order:\n// M(row, col) = *(M.elements + row * M.width + col)\ntypedef struct {\n    int width;\n    int height;\n    float* elements;\n} Matrix;\n\n// Thread block size\n#define BLOCK_SIZE 16\n\n// Forward declaration of the matrix multiplication kernel\n__global__ void MatMulKernel(const Matrix, const Matrix, Matrix);\n\n// Matrix multiplication - Host code\n// Matrix dimensions are assumed to be multiples of BLOCK_SIZE\nvoid MatMul(const Matrix A, const Matrix B, Matrix C)\n{\n    // Load A and B to device memory\n    Matrix d_A;\n    d_A.width = A.width; d_A.height = A.height;\n    size_t size = A.width * A.height * sizeof(float);\n    cudaMalloc(&d_A.elements, size);\n    cudaMemcpy(d_A.elements, A.elements, size,\n               cudaMemcpyHostToDevice);\n    Matrix d_B;\n    d_B.width = B.width; d_B.height = B.height;\n    size = B.width * B.height * sizeof(float);\n    cudaMalloc(&d_B.elements, size);\n    cudaMemcpy(d_B.elements, B.elements, size,\n               cudaMemcpyHostToDevice);\n\n    // Allocate C in device memory\n    Matrix d_C;\n    d_C.width = C.width; d_C.height = C.height;\n    size = C.width * C.height * sizeof(float);\n    cudaMalloc(&d_C.elements, size);\n\n    // Invoke kernel\n    dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE);\n    dim3 dimGrid(B.width / dimBlock.x, A.height / dimBlock.y);\n    MatMulKernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C);\n\n    // Read C from device memory\n    cudaMemcpy(C.elements, d_C.elements, size,\n               cudaMemcpyDeviceToHost);\n\n    // Free device memory\n    cudaFree(d_A.elements);\n    cudaFree(d_B.elements);\n    cudaFree(d_C.elements);\n}\n\n// Matrix multiplication kernel called by MatMul()\n__global__ void MatMulKernel(Matrix A, Matrix B, Matrix C)\n{\n    // Each thread computes one element of C\n    // by accumulating results into Cvalue\n    float Cvalue = 0;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    for (int e = 0; e < A.width; ++e)\n        Cvalue += A.elements[row * A.width + e]\n                * B.elements[e * B.width + col];\n    C.elements[row * C.width + col] = Cvalue;\n}\n\n_images/matrix-multiplication-without-shared-memory.png\n\nFigure 8 Matrix Multiplication without Shared Memory\uf0c1\n\nThe following code sample is an implementation of matrix multiplication that does take advantage of shared memory. In this implementation, each thread block is responsible for computing one square sub-matrix Csub of C and each thread within the block is responsible for computing one element of Csub. As illustrated in Figure 9, Csub is equal to the product of two rectangular matrices: the sub-matrix of A of dimension (A.width, block_size) that has the same row indices as Csub, and the sub-matrix of B of dimension (block_size, A.width )that has the same column indices as Csub. In order to fit into the device\u2019s resources, these two rectangular matrices are divided into as many square matrices of dimension block_size as necessary and Csub is computed as the sum of the products of these square matrices. Each of these products is performed by first loading the two corresponding square matrices from global memory to shared memory with one thread loading one element of each matrix, and then by having each thread compute one element of the product. Each thread accumulates the result of each of these products into a register and once done writes the result to global memory.\n\nBy blocking the computation this way, we take advantage of fast shared memory and save a lot of global memory bandwidth since A is only read (B.width / block_size) times from global memory and B is read (A.height / block_size) times.\n\nThe Matrix type from the previous code sample is augmented with a stride field, so that sub-matrices can be efficiently represented with the same type. __device__ functions are used to get and set elements and build any sub-matrix from a matrix.\n\n// Matrices are stored in row-major order:\n// M(row, col) = *(M.elements + row * M.stride + col)\ntypedef struct {\n    int width;\n    int height;\n    int stride;\n    float* elements;\n} Matrix;\n// Get a matrix element\n__device__ float GetElement(const Matrix A, int row, int col)\n{\n    return A.elements[row * A.stride + col];\n}\n// Set a matrix element\n__device__ void SetElement(Matrix A, int row, int col,\n                           float value)\n{\n    A.elements[row * A.stride + col] = value;\n}\n// Get the BLOCK_SIZExBLOCK_SIZE sub-matrix Asub of A that is\n// located col sub-matrices to the right and row sub-matrices down\n// from the upper-left corner of A\n __device__ Matrix GetSubMatrix(Matrix A, int row, int col)\n{\n    Matrix Asub;\n    Asub.width    = BLOCK_SIZE;\n    Asub.height   = BLOCK_SIZE;\n    Asub.stride   = A.stride;\n    Asub.elements = &A.elements[A.stride * BLOCK_SIZE * row\n                                         + BLOCK_SIZE * col];\n    return Asub;\n}\n// Thread block size\n#define BLOCK_SIZE 16\n// Forward declaration of the matrix multiplication kernel\n__global__ void MatMulKernel(const Matrix, const Matrix, Matrix);\n// Matrix multiplication - Host code\n// Matrix dimensions are assumed to be multiples of BLOCK_SIZE\nvoid MatMul(const Matrix A, const Matrix B, Matrix C)\n{\n    // Load A and B to device memory\n    Matrix d_A;\n    d_A.width = d_A.stride = A.width; d_A.height = A.height;\n    size_t size = A.width * A.height * sizeof(float);\n    cudaMalloc(&d_A.elements, size);\n    cudaMemcpy(d_A.elements, A.elements, size,\n               cudaMemcpyHostToDevice);\n    Matrix d_B;\n    d_B.width = d_B.stride = B.width; d_B.height = B.height;\n    size = B.width * B.height * sizeof(float);\n    cudaMalloc(&d_B.elements, size);\n    cudaMemcpy(d_B.elements, B.elements, size,\n    cudaMemcpyHostToDevice);\n    // Allocate C in device memory\n    Matrix d_C;\n    d_C.width = d_C.stride = C.width; d_C.height = C.height;\n    size = C.width * C.height * sizeof(float);\n    cudaMalloc(&d_C.elements, size);\n    // Invoke kernel\n    dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE);\n    dim3 dimGrid(B.width / dimBlock.x, A.height / dimBlock.y);\n    MatMulKernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C);\n    // Read C from device memory\n    cudaMemcpy(C.elements, d_C.elements, size,\n               cudaMemcpyDeviceToHost);\n    // Free device memory\n    cudaFree(d_A.elements);\n    cudaFree(d_B.elements);\n    cudaFree(d_C.elements);\n}\n// Matrix multiplication kernel called by MatMul()\n __global__ void MatMulKernel(Matrix A, Matrix B, Matrix C)\n{\n    // Block row and column\n    int blockRow = blockIdx.y;\n    int blockCol = blockIdx.x;\n    // Each thread block computes one sub-matrix Csub of C\n    Matrix Csub = GetSubMatrix(C, blockRow, blockCol);\n    // Each thread computes one element of Csub\n    // by accumulating results into Cvalue\n    float Cvalue = 0;\n    // Thread row and column within Csub\n    int row = threadIdx.y;\n    int col = threadIdx.x;\n    // Loop over all the sub-matrices of A and B that are\n    // required to compute Csub\n    // Multiply each pair of sub-matrices together\n    // and accumulate the results\n    for (int m = 0; m < (A.width / BLOCK_SIZE); ++m) {\n        // Get sub-matrix Asub of A\n        Matrix Asub = GetSubMatrix(A, blockRow, m);\n        // Get sub-matrix Bsub of B\n        Matrix Bsub = GetSubMatrix(B, m, blockCol);\n        // Shared memory used to store Asub and Bsub respectively\n        __shared__ float As[BLOCK_SIZE][BLOCK_SIZE];\n        __shared__ float Bs[BLOCK_SIZE][BLOCK_SIZE];\n        // Load Asub and Bsub from device memory to shared memory\n        // Each thread loads one element of each sub-matrix\n        As[row][col] = GetElement(Asub, row, col);\n        Bs[row][col] = GetElement(Bsub, row, col);\n        // Synchronize to make sure the sub-matrices are loaded\n        // before starting the computation\n        __syncthreads();\n        // Multiply Asub and Bsub together\n        for (int e = 0; e < BLOCK_SIZE; ++e)\n            Cvalue += As[row][e] * Bs[e][col];\n        // Synchronize to make sure that the preceding\n        // computation is done before loading two new\n        // sub-matrices of A and B in the next iteration\n        __syncthreads();\n    }\n    // Write Csub to device memory\n    // Each thread writes one element\n    SetElement(Csub, row, col, Cvalue);\n}\n\n_images/matrix-multiplication-with-shared-memory.png\n\nFigure 9 Matrix Multiplication with Shared Memory\uf0c1\n6.2.5. Distributed Shared Memory\uf0c1\n\nThread block clusters introduced in compute capability 9.0 provide the ability for threads in a thread block cluster to access shared memory of all the participating thread blocks in a cluster. This partitioned shared memory is called Distributed Shared Memory, and the corresponding address space is called Distributed shared memory address space. Threads that belong to a thread block cluster, can read, write or perform atomics in the distributed address space, regardless whether the address belongs to the local thread block or a remote thread block. Whether a kernel uses distributed shared memory or not, the shared memory size specifications, static or dynamic is still per thread block. The size of distributed shared memory is just the number of thread blocks per cluster multiplied by the size of shared memory per thread block.\n\nAccessing data in distributed shared memory requires all the thread blocks to exist. A user can guarantee that all thread blocks have started executing using cluster.sync() from Cluster Group API. The user also needs to ensure that all distributed shared memory operations happen before the exit of a thread block, e.g., if a remote thread block is trying to read a given thread block\u2019s shared memory, user needs to ensure that the shared memory read by remote thread block is completed before it can exit.\n\nCUDA provides a mechanism to access to distributed shared memory, and applications can benefit from leveraging its capabilities. Lets look at a simple histogram computation and how to optimize it on the GPU using thread block cluster. A standard way of computing histograms is do the computation in the shared memory of each thread block and then perform global memory atomics. A limitation of this approach is the shared memory capacity. Once the histogram bins no longer fit in the shared memory, a user needs to directly compute histograms and hence the atomics in the global memory. With distributed shared memory, CUDA provides an intermediate step, where a depending on the histogram bins size, histogram can be computed in shared memory, distributed shared memory or global memory directly.\n\nThe CUDA kernel example below shows how to compute histograms in shared memory or distributed shared memory, depending on the number of histogram bins.\n\n#include <cooperative_groups.h>\n\n// Distributed Shared memory histogram kernel\n__global__ void clusterHist_kernel(int *bins, const int nbins, const int bins_per_block, const int *__restrict__ input,\n                                   size_t array_size)\n{\n  extern __shared__ int smem[];\n  namespace cg = cooperative_groups;\n  int tid = cg::this_grid().thread_rank();\n\n  // Cluster initialization, size and calculating local bin offsets.\n  cg::cluster_group cluster = cg::this_cluster();\n  unsigned int clusterBlockRank = cluster.block_rank();\n  int cluster_size = cluster.dim_blocks().x;\n\n  for (int i = threadIdx.x; i < bins_per_block; i += blockDim.x)\n  {\n    smem[i] = 0; //Initialize shared memory histogram to zeros\n  }\n\n  // cluster synchronization ensures that shared memory is initialized to zero in\n  // all thread blocks in the cluster. It also ensures that all thread blocks\n  // have started executing and they exist concurrently.\n  cluster.sync();\n\n  for (int i = tid; i < array_size; i += blockDim.x * gridDim.x)\n  {\n    int ldata = input[i];\n\n    //Find the right histogram bin.\n    int binid = ldata;\n    if (ldata < 0)\n      binid = 0;\n    else if (ldata >= nbins)\n      binid = nbins - 1;\n\n    //Find destination block rank and offset for computing\n    //distributed shared memory histogram\n    int dst_block_rank = (int)(binid / bins_per_block);\n    int dst_offset = binid % bins_per_block;\n\n    //Pointer to target block shared memory\n    int *dst_smem = cluster.map_shared_rank(smem, dst_block_rank);\n\n    //Perform atomic update of the histogram bin\n    atomicAdd(dst_smem + dst_offset, 1);\n  }\n\n  // cluster synchronization is required to ensure all distributed shared\n  // memory operations are completed and no thread block exits while\n  // other thread blocks are still accessing distributed shared memory\n  cluster.sync();\n\n  // Perform global memory histogram, using the local distributed memory histogram\n  int *lbins = bins + cluster.block_rank() * bins_per_block;\n  for (int i = threadIdx.x; i < bins_per_block; i += blockDim.x)\n  {\n    atomicAdd(&lbins[i], smem[i]);\n  }\n}\n\nThe above kernel can be launched at runtime with a cluster size depending on the amount of distributed shared memory required. If histogram is small enough to fit in shared memory of just one block, user can launch kernel with cluster size 1. The code snippet below shows how to launch a cluster kernel dynamically based depending on shared memory requirements.\n\n// Launch via extensible launch\n{\n  cudaLaunchConfig_t config = {0};\n  config.gridDim = array_size / threads_per_block;\n  config.blockDim = threads_per_block;\n\n  // cluster_size depends on the histogram size.\n  // ( cluster_size == 1 ) implies no distributed shared memory, just thread block local shared memory\n  int cluster_size = 2; // size 2 is an example here\n  int nbins_per_block = nbins / cluster_size;\n\n  //dynamic shared memory size is per block.\n  //Distributed shared memory size =  cluster_size * nbins_per_block * sizeof(int)\n  config.dynamicSmemBytes = nbins_per_block * sizeof(int);\n\n  CUDA_CHECK(::cudaFuncSetAttribute((void *)clusterHist_kernel, cudaFuncAttributeMaxDynamicSharedMemorySize, config.dynamicSmemBytes));\n\n  cudaLaunchAttribute attribute[1];\n  attribute[0].id = cudaLaunchAttributeClusterDimension;\n  attribute[0].val.clusterDim.x = cluster_size;\n  attribute[0].val.clusterDim.y = 1;\n  attribute[0].val.clusterDim.z = 1;\n\n  config.numAttrs = 1;\n  config.attrs = attribute;\n\n  cudaLaunchKernelEx(&config, clusterHist_kernel, bins, nbins, nbins_per_block, input, array_size);\n}\n\n6.2.6. Page-Locked Host Memory\uf0c1\n\nThe runtime provides functions to allow the use of page-locked (also known as pinned) host memory (as opposed to regular pageable host memory allocated by malloc()):\n\n    cudaHostAlloc() and cudaFreeHost() allocate and free page-locked host memory;\n\n    cudaHostRegister() page-locks a range of memory allocated by malloc() (see reference manual for limitations).\n\nUsing page-locked host memory has several benefits:\n\n    Copies between page-locked host memory and device memory can be performed concurrently with kernel execution for some devices as mentioned in Asynchronous Concurrent Execution.\n\n    On some devices, page-locked host memory can be mapped into the address space of the device, eliminating the need to copy it to or from device memory as detailed in Mapped Memory.\n\n    On systems with a front-side bus, bandwidth between host memory and device memory is higher if host memory is allocated as page-locked and even higher if in addition it is allocated as write-combining as described in Write-Combining Memory.\n\nNote\n\nPage-locked host memory is not cached on non I/O coherent Tegra devices. Also, cudaHostRegister() is not supported on non I/O coherent Tegra devices.\n\nThe simple zero-copy CUDA sample comes with a detailed document on the page-locked memory APIs.\n6.2.6.1. Portable Memory\uf0c1\n\nA block of page-locked memory can be used in conjunction with any device in the system (see Multi-Device System for more details on multi-device systems), but by default, the benefits of using page-locked memory described above are only available in conjunction with the device that was current when the block was allocated (and with all devices sharing the same unified address space, if any, as described in Unified Virtual Address Space). To make these advantages available to all devices, the block needs to be allocated by passing the flag cudaHostAllocPortable to cudaHostAlloc() or page-locked by passing the flag cudaHostRegisterPortable to cudaHostRegister().\n6.2.6.2. Write-Combining Memory\uf0c1\n\nBy default page-locked host memory is allocated as cacheable. It can optionally be allocated as write-combining instead by passing flag cudaHostAllocWriteCombined to cudaHostAlloc(). Write-combining memory frees up the host\u2019s L1 and L2 cache resources, making more cache available to the rest of the application. In addition, write-combining memory is not snooped during transfers across the PCI Express bus, which can improve transfer performance by up to 40%.\n\nReading from write-combining memory from the host is prohibitively slow, so write-combining memory should in general be used for memory that the host only writes to.\n\nUsing CPU atomic instructions on WC memory should be avoided because not all CPU implementations guarantee that functionality.\n6.2.6.3. Mapped Memory\uf0c1\n\nA block of page-locked host memory can also be mapped into the address space of the device by passing flag cudaHostAllocMapped to cudaHostAlloc() or by passing flag cudaHostRegisterMapped to cudaHostRegister(). Such a block has therefore in general two addresses: one in host memory that is returned by cudaHostAlloc() or malloc(), and one in device memory that can be retrieved using cudaHostGetDevicePointer() and then used to access the block from within a kernel. The only exception is for pointers allocated with cudaHostAlloc() and when a unified address space is used for the host and the device as mentioned in Unified Virtual Address Space.\n\nAccessing host memory directly from within a kernel does not provide the same bandwidth as device memory, but does have some advantages:\n\n    There is no need to allocate a block in device memory and copy data between this block and the block in host memory; data transfers are implicitly performed as needed by the kernel;\n\n    There is no need to use streams (see Concurrent Data Transfers) to overlap data transfers with kernel execution; the kernel-originated data transfers automatically overlap with kernel execution.\n\nSince mapped page-locked memory is shared between host and device however, the application must synchronize memory accesses using streams or events (see Asynchronous Concurrent Execution) to avoid any potential read-after-write, write-after-read, or write-after-write hazards.\n\nTo be able to retrieve the device pointer to any mapped page-locked memory, page-locked memory mapping must be enabled by calling cudaSetDeviceFlags() with the cudaDeviceMapHost flag before any other CUDA call is performed. Otherwise, cudaHostGetDevicePointer() will return an error.\n\ncudaHostGetDevicePointer() also returns an error if the device does not support mapped page-locked host memory. Applications may query this capability by checking the canMapHostMemory device property (see Device Enumeration), which is equal to 1 for devices that support mapped page-locked host memory.\n\nNote that atomic functions (see Atomic Functions) operating on mapped page-locked memory are not atomic from the point of view of the host or other devices.\n\nAlso note that CUDA runtime requires that 1-byte, 2-byte, 4-byte, 8-byte, and 16-byte naturally aligned loads and stores to host memory initiated from the device are preserved as single accesses from the point of view of the host and other devices. On some platforms, atomics to memory may be broken by the hardware into separate load and store operations. These component load and store operations have the same requirements on preservation of naturally aligned accesses. The CUDA runtime does not support a PCI Express bus topology where a PCI Express bridge splits 8-byte naturally aligned operations and NVIDIA is not aware of any topology that splits 16-byte naturally aligned operations.\n6.2.7. Memory Synchronization Domains\uf0c1\n6.2.7.1. Memory Fence Interference\uf0c1\n\nSome CUDA applications may see degraded performance due to memory fence/flush operations waiting on more transactions than those necessitated by the CUDA memory consistency model.\n\n__managed__ int x = 0;\n__device__  cuda::atomic<int, cuda::thread_scope_device> a(0);\n__managed__ cuda::atomic<int, cuda::thread_scope_system> b(0);\n\n\t\n\nThread 1 (SM)\n\nx = 1;\na = 1;\n\nThread 2 (SM)\n\nwhile (a != 1) ;\nassert(x == 1);\nb = 1;\n\nThread 3 (CPU)\n\nwhile (b != 1) ;\nassert(x == 1);\n\nConsider the example above. The CUDA memory consistency model guarantees that the asserted condition will be true, so the write to x from thread 1 must be visible to thread 3, before the write to b from thread 2.\n\nThe memory ordering provided by the release and acquire of a is only sufficient to make x visible to thread 2, not thread 3, as it is a device-scope operation. The system-scope ordering provided by release and acquire of b, therefore, needs to ensure not only writes issued from thread 2 itself are visible to thread 3, but also writes from other threads that are visible to thread 2. This is known as cumulativity. As the GPU cannot know at the time of execution which writes have been guaranteed at the source level to be visible and which are visible only by chance timing, it must cast a conservatively wide net for in-flight memory operations.\n\nThis sometimes leads to interference: because the GPU is waiting on memory operations it is not required to at the source level, the fence/flush may take longer than necessary.\n\nNote that fences may occur explicitly as intrinsics or atomics in code, like in the example, or implicitly to implement synchronizes-with relationships at task boundaries.\n\nA common example is when a kernel is performing computation in local GPU memory, and a parallel kernel (e.g. from NCCL) is performing communications with a peer. Upon completion, the local kernel will implicitly flush its writes to satisfy any synchronizes-with relationships to downstream work. This may unnecessarily wait, fully or partially, on slower nvlink or PCIe writes from the communication kernel.\n6.2.7.2. Isolating Traffic with Domains\uf0c1\n\nBeginning with Hopper architecture GPUs and CUDA 12.0, the memory synchronization domains feature provides a way to alleviate such interference. In exchange for explicit assistance from code, the GPU can reduce the net cast by a fence operation. Each kernel launch is given a domain ID. Writes and fences are tagged with the ID, and a fence will only order writes matching the fence\u2019s domain. In the concurrent compute vs communication example, the communication kernels can be placed in a different domain.\n\nWhen using domains, code must abide by the rule that ordering or synchronization between distinct domains on the same GPU requires system-scope fencing. Within a domain, device-scope fencing remains sufficient. This is necessary for cumulativity as one kernel\u2019s writes will not be encompassed by a fence issued from a kernel in another domain. In essence, cumulativity is satisfied by ensuring that cross-domain traffic is flushed to the system scope ahead of time.\n\nNote that this modifies the definition of thread_scope_device. However, because kernels will default to domain 0 as described below, backward compatibility is maintained.\n6.2.7.3. Using Domains in CUDA\uf0c1\n\nDomains are accessible via the new launch attributes cudaLaunchAttributeMemSyncDomain and cudaLaunchAttributeMemSyncDomainMap. The former selects between logical domains cudaLaunchMemSyncDomainDefault and cudaLaunchMemSyncDomainRemote, and the latter provides a mapping from logical to physical domains. The remote domain is intended for kernels performing remote memory access in order to isolate their memory traffic from local kernels. Note, however, the selection of a particular domain does not affect what memory access a kernel may legally perform.\n\nThe domain count can be queried via device attribute cudaDevAttrMemSyncDomainCount. Hopper has 4 domains. To facilitate portable code, domains functionality can be used on all devices and CUDA will report a count of 1 prior to Hopper.\n\nHaving logical domains eases application composition. An individual kernel launch at a low level in the stack, such as from NCCL, can select a semantic logical domain without concern for the surrounding application architecture. Higher levels can steer logical domains using the mapping. The default value for the logical domain if it is not set is the default domain, and the default mapping is to map the default domain to 0 and the remote domain to 1 (on GPUs with more than 1 domain). Specific libraries may tag launches with the remote domain in CUDA 12.0 and later; for example, NCCL 2.16 will do so. Together, this provides a beneficial use pattern for common applications out of the box, with no code changes needed in other components, frameworks, or at application level. An alternative use pattern, for example in an application using nvshmem or with no clear separation of kernel types, could be to partition parallel streams. Stream A may map both logical domains to physical domain 0, stream B to 1, and so on.\n\n// Example of launching a kernel with the remote logical domain\ncudaLaunchAttribute domainAttr;\ndomainAttr.id = cudaLaunchAttrMemSyncDomain;\ndomainAttr.val = cudaLaunchMemSyncDomainRemote;\ncudaLaunchConfig_t config;\n// Fill out other config fields\nconfig.attrs = &domainAttr;\nconfig.numAttrs = 1;\ncudaLaunchKernelEx(&config, myKernel, kernelArg1, kernelArg2...);\n\n// Example of setting a mapping for a stream\n// (This mapping is the default for streams starting on Hopper if not\n// explicitly set, and provided for illustration)\ncudaLaunchAttributeValue mapAttr;\nmapAttr.memSyncDomainMap.default_ = 0;\nmapAttr.memSyncDomainMap.remote = 1;\ncudaStreamSetAttribute(stream, cudaLaunchAttributeMemSyncDomainMap, &mapAttr);\n\n// Example of mapping different streams to different physical domains, ignoring\n// logical domain settings\ncudaLaunchAttributeValue mapAttr;\nmapAttr.memSyncDomainMap.default_ = 0;\nmapAttr.memSyncDomainMap.remote = 0;\ncudaStreamSetAttribute(streamA, cudaLaunchAttributeMemSyncDomainMap, &mapAttr);\nmapAttr.memSyncDomainMap.default_ = 1;\nmapAttr.memSyncDomainMap.remote = 1;\ncudaStreamSetAttribute(streamB, cudaLaunchAttributeMemSyncDomainMap, &mapAttr);\n\nAs with other launch attributes, these are exposed uniformly on CUDA streams, individual launches using cudaLaunchKernelEx, and kernel nodes in CUDA graphs. A typical use would set the mapping at stream level and the logical domain at launch level (or bracketing a section of stream use) as described above.\n\nBoth attributes are copied to graph nodes during stream capture. Graphs take both attributes from the node itself, essentially an indirect way of specifying a physical domain. Domain-related attributes set on the stream a graph is launched into are not used in execution of the graph.\n6.2.8. Asynchronous Concurrent Execution\uf0c1\n\nCUDA exposes the following operations as independent tasks that can operate concurrently with one another:\n\n    Computation on the host;\n\n    Computation on the device;\n\n    Memory transfers from the host to the device;\n\n    Memory transfers from the device to the host;\n\n    Memory transfers within the memory of a given device;\n\n    Memory transfers among devices.\n\nThe level of concurrency achieved between these operations will depend on the feature set and compute capability of the device as described below.\n6.2.8.1. Concurrent Execution between Host and Device\uf0c1\n\nConcurrent host execution is facilitated through asynchronous library functions that return control to the host thread before the device completes the requested task. Using asynchronous calls, many device operations can be queued up together to be executed by the CUDA driver when appropriate device resources are available. This relieves the host thread of much of the responsibility to manage the device, leaving it free for other tasks. The following device operations are asynchronous with respect to the host:\n\n    Kernel launches;\n\n    Memory copies within a single device\u2019s memory;\n\n    Memory copies from host to device of a memory block of 64 KB or less;\n\n    Memory copies performed by functions that are suffixed with Async;\n\n    Memory set function calls.\n\nProgrammers can globally disable asynchronicity of kernel launches for all CUDA applications running on a system by setting the CUDA_LAUNCH_BLOCKING environment variable to 1. This feature is provided for debugging purposes only and should not be used as a way to make production software run reliably.\n\nKernel launches are synchronous if hardware counters are collected via a profiler (Nsight Compute) unless concurrent kernel profiling is enabled. Async memory copies might also be synchronous if they involve host memory that is not page-locked.\n6.2.8.2. Concurrent Kernel Execution\uf0c1\n\nSome devices of compute capability 2.x and higher can execute multiple kernels concurrently. Applications may query this capability by checking the concurrentKernels device property (see Device Enumeration), which is equal to 1 for devices that support it.\n\nThe maximum number of kernel launches that a device can execute concurrently depends on its compute capability and is listed in Table 27.\n\nA kernel from one CUDA context cannot execute concurrently with a kernel from another CUDA context. The GPU may time slice to provide forward progress to each context. If a user wants to run kernels from multiple process simultaneously on the SM, one must enable MPS.\n\nKernels that use many textures or a large amount of local memory are less likely to execute concurrently with other kernels.\n6.2.8.3. Overlap of Data Transfer and Kernel Execution\uf0c1\n\nSome devices can perform an asynchronous memory copy to or from the GPU concurrently with kernel execution. Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is greater than zero for devices that support it. If host memory is involved in the copy, it must be page-locked.\n\nIt is also possible to perform an intra-device copy simultaneously with kernel execution (on devices that support the concurrentKernels device property) and/or with copies to or from the device (for devices that support the asyncEngineCount property). Intra-device copies are initiated using the standard memory copy functions with destination and source addresses residing on the same device.\n6.2.8.4. Concurrent Data Transfers\uf0c1\n\nSome devices of compute capability 2.x and higher can overlap copies to and from the device. Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is equal to 2 for devices that support it. In order to be overlapped, any host memory involved in the transfers must be page-locked.\n6.2.8.5. Streams\uf0c1\n\nApplications manage the concurrent operations described above through streams. A stream is a sequence of commands (possibly issued by different host threads) that execute in order. Different streams, on the other hand, may execute their commands out of order with respect to one another or concurrently; this behavior is not guaranteed and should therefore not be relied upon for correctness (for example, inter-kernel communication is undefined). The commands issued on a stream may execute when all the dependencies of the command are met. The dependencies could be previously launched commands on same stream or dependencies from other streams. The successful completion of synchronize call guarantees that all the commands launched are completed.\n6.2.8.5.1. Creation and Destruction of Streams\uf0c1\n\nA stream is defined by creating a stream object and specifying it as the stream parameter to a sequence of kernel launches and host <-> device memory copies. The following code sample creates two streams and allocates an array hostPtr of float in page-locked memory.\n\ncudaStream_t stream[2];\nfor (int i = 0; i < 2; ++i)\n    cudaStreamCreate(&stream[i]);\nfloat* hostPtr;\ncudaMallocHost(&hostPtr, 2 * size);\n\nEach of these streams is defined by the following code sample as a sequence of one memory copy from host to device, one kernel launch, and one memory copy from device to host:\n\nfor (int i = 0; i < 2; ++i) {\n    cudaMemcpyAsync(inputDevPtr + i * size, hostPtr + i * size,\n                    size, cudaMemcpyHostToDevice, stream[i]);\n    MyKernel <<<100, 512, 0, stream[i]>>>\n          (outputDevPtr + i * size, inputDevPtr + i * size, size);\n    cudaMemcpyAsync(hostPtr + i * size, outputDevPtr + i * size,\n                    size, cudaMemcpyDeviceToHost, stream[i]);\n}\n\nEach stream copies its portion of input array hostPtr to array inputDevPtr in device memory, processes inputDevPtr on the device by calling MyKernel(), and copies the result outputDevPtr back to the same portion of hostPtr. Overlapping Behavior describes how the streams overlap in this example depending on the capability of the device. Note that hostPtr must point to page-locked host memory for any overlap to occur.\n\nStreams are released by calling cudaStreamDestroy().\n\nfor (int i = 0; i < 2; ++i)\n    cudaStreamDestroy(stream[i]);\n\nIn case the device is still doing work in the stream when cudaStreamDestroy() is called, the function will return immediately and the resources associated with the stream will be released automatically once the device has completed all work in the stream.\n6.2.8.5.2. Default Stream\uf0c1\n\nKernel launches and host <-> device memory copies that do not specify any stream parameter, or equivalently that set the stream parameter to zero, are issued to the default stream. They are therefore executed in order.\n\nFor code that is compiled using the --default-stream per-thread compilation flag (or that defines the CUDA_API_PER_THREAD_DEFAULT_STREAM macro before including CUDA headers (cuda.h and cuda_runtime.h)), the default stream is a regular stream and each host thread has its own default stream.\n\nNote\n\n#define CUDA_API_PER_THREAD_DEFAULT_STREAM 1 cannot be used to enable this behavior when the code is compiled by nvcc as nvcc implicitly includes cuda_runtime.h at the top of the translation unit. In this case the --default-stream per-thread compilation flag needs to be used or the CUDA_API_PER_THREAD_DEFAULT_STREAM macro needs to be defined with the -DCUDA_API_PER_THREAD_DEFAULT_STREAM=1 compiler flag.\n\nFor code that is compiled using the --default-stream legacy compilation flag, the default stream is a special stream called the NULL stream and each device has a single NULL stream used for all host threads. The NULL stream is special as it causes implicit synchronization as described in Implicit Synchronization.\n\nFor code that is compiled without specifying a --default-stream compilation flag, --default-stream legacy is assumed as the default.\n6.2.8.5.3. Explicit Synchronization\uf0c1\n\nThere are various ways to explicitly synchronize streams with each other.\n\ncudaDeviceSynchronize() waits until all preceding commands in all streams of all host threads have completed.\n\ncudaStreamSynchronize()takes a stream as a parameter and waits until all preceding commands in the given stream have completed. It can be used to synchronize the host with a specific stream, allowing other streams to continue executing on the device.\n\ncudaStreamWaitEvent()takes a stream and an event as parameters (see Events for a description of events)and makes all the commands added to the given stream after the call to cudaStreamWaitEvent()delay their execution until the given event has completed.\n\ncudaStreamQuery()provides applications with a way to know if all preceding commands in a stream have completed.\n6.2.8.5.4. Implicit Synchronization\uf0c1\n\nTwo operations from different streams cannot run concurrently if any CUDA operation on the NULL stream is submitted in-between them, unless the streams are non-blocking streams (created with the cudaStreamNonBlocking flag).\n\nApplications should follow these guidelines to improve their potential for concurrent kernel execution:\n\n    All independent operations should be issued before dependent operations,\n\n    Synchronization of any kind should be delayed as long as possible.\n\n6.2.8.5.5. Overlapping Behavior\uf0c1\n\nThe amount of execution overlap between two streams depends on the order in which the commands are issued to each stream and whether or not the device supports overlap of data transfer and kernel execution (see Overlap of Data Transfer and Kernel Execution), concurrent kernel execution (see Concurrent Kernel Execution), and/or concurrent data transfers (see Concurrent Data Transfers).\n\nFor example, on devices that do not support concurrent data transfers, the two streams of the code sample of Creation and Destruction of Streams do not overlap at all because the memory copy from host to device is issued to stream[1] after the memory copy from device to host is issued to stream[0], so it can only start once the memory copy from device to host issued to stream[0] has completed. If the code is rewritten the following way (and assuming the device supports overlap of data transfer and kernel execution)\n\nfor (int i = 0; i < 2; ++i)\n    cudaMemcpyAsync(inputDevPtr + i * size, hostPtr + i * size,\n                    size, cudaMemcpyHostToDevice, stream[i]);\nfor (int i = 0; i < 2; ++i)\n    MyKernel<<<100, 512, 0, stream[i]>>>\n          (outputDevPtr + i * size, inputDevPtr + i * size, size);\nfor (int i = 0; i < 2; ++i)\n    cudaMemcpyAsync(hostPtr + i * size, outputDevPtr + i * size,\n                    size, cudaMemcpyDeviceToHost, stream[i]);\n\nthen the memory copy from host to device issued to stream[1] overlaps with the kernel launch issued to stream[0].\n\nOn devices that do support concurrent data transfers, the two streams of the code sample of Creation and Destruction of Streams do overlap: The memory copy from host to device issued to stream[1] overlaps with the memory copy from device to host issued to stream[0] and even with the kernel launch issued to stream[0] (assuming the device supports overlap of data transfer and kernel execution).\n6.2.8.5.6. Host Functions (Callbacks)\uf0c1\n\nThe runtime provides a way to insert a CPU function call at any point into a stream via cudaLaunchHostFunc(). The provided function is executed on the host once all commands issued to the stream before the callback have completed.\n\nThe following code sample adds the host function MyCallback to each of two streams after issuing a host-to-device memory copy, a kernel launch and a device-to-host memory copy into each stream. The function will begin execution on the host after each of the device-to-host memory copies completes.\n\nvoid CUDART_CB MyCallback(void *data){\n    printf(\"Inside callback %d\\n\", (size_t)data);\n}\n...\nfor (size_t i = 0; i < 2; ++i) {\n    cudaMemcpyAsync(devPtrIn[i], hostPtr[i], size, cudaMemcpyHostToDevice, stream[i]);\n    MyKernel<<<100, 512, 0, stream[i]>>>(devPtrOut[i], devPtrIn[i], size);\n    cudaMemcpyAsync(hostPtr[i], devPtrOut[i], size, cudaMemcpyDeviceToHost, stream[i]);\n    cudaLaunchHostFunc(stream[i], MyCallback, (void*)i);\n}\n\nThe commands that are issued in a stream after a host function do not start executing before the function has completed.\n\nA host function enqueued into a stream must not make CUDA API calls (directly or indirectly), as it might end up waiting on itself if it makes such a call leading to a deadlock.\n6.2.8.5.7. Stream Priorities\uf0c1\n\nThe relative priorities of streams can be specified at creation using cudaStreamCreateWithPriority(). The range of allowable priorities, ordered as [ greatest priority, least priority ] can be obtained using the cudaDeviceGetStreamPriorityRange() function. At runtime, the GPU scheduler utilizes stream priorities to determine task execution order, but these priorities serve as hints rather than guarantees. When selecting work to launch, pending tasks in higher-priority streams take precedence over those in lower-priority streams. Higher-priority tasks do not preempt already running lower-priority tasks. The GPU does not reassess work queues during task execution, and increasing a stream\u2019s priority will not interrupt ongoing work. Stream priorities influence task execution without enforcing strict ordering, so users can leverage stream priorities to influence task execution without relying on strict ordering guarantees.\n\nThe following code sample obtains the allowable range of priorities for the current device, and creates streams with the highest and lowest available priorities.\n\n// get the range of stream priorities for this device\nint leastPriority, greatestPriority;\ncudaDeviceGetStreamPriorityRange(&leastPriority, &greatestPriority);\n// create streams with highest and lowest available priorities\ncudaStream_t st_high, st_low;\ncudaStreamCreateWithPriority(&st_high, cudaStreamNonBlocking, greatestPriority));\ncudaStreamCreateWithPriority(&st_low, cudaStreamNonBlocking, leastPriority);\n\n6.2.8.6. Programmatic Dependent Launch and Synchronization\uf0c1\n\nThe Programmatic Dependent Launch mechanism allows for a dependent secondary kernel to launch before the primary kernel it depends on in the same CUDA stream has finished executing. Available starting with devices of compute capability 9.0, this technique can provide performance benefits when the secondary kernel can complete significant work that does not depend on the results of the primary kernel.\n6.2.8.6.1. Background\uf0c1\n\nA CUDA application utilizes the GPU by launching and executing multiple kernels on it. A typical GPU activity timeline is shown in Figure 10.\nGPU activity timeline\n\nFigure 10 GPU activity timeline\uf0c1\n\nHere, secondary_kernel is launched after primary_kernel finishes its execution. Serialized execution is usually necessary because secondary_kernel depends on result data produced by primary_kernel. If secondary_kernel has no dependency on primary_kernel, both of them can be launched concurrently by using Streams. Even if secondary_kernel is dependent on primary_kernel, there is some potential for concurrent execution. For example, almost all the kernels have some sort of preamble section during which tasks such as zeroing buffers or loading constant values are performed.\nPreamble section of ``secondary_kernel``\n\nFigure 11 Preamble section of secondary_kernel\uf0c1\n\nFigure 11 demonstrates the portion of secondary_kernel that could be executed concurrently without impacting the application. Note that concurrent launch also allows us to hide the launch latency of secondary_kernel behind the execution of primary_kernel.\nConcurrent execution of ``primary_kernel`` and ``secondary_kernel``\n\nFigure 12 Concurrent execution of primary_kernel and secondary_kernel\uf0c1\n\nThe concurrent launch and execution of secondary_kernel shown in Figure 12 is achievable using Programmatic Dependent Launch.\n\nProgrammatic Dependent Launch introduces changes to the CUDA kernel launch APIs as explained in following section. These APIs require at least compute capability 9.0 to provide overlapping execution.\n6.2.8.6.2. API Description\uf0c1\n\nIn Programmatic Dependent Launch, a primary and a secondary kernel are launched in the same CUDA stream. The primary kernel should execute cudaTriggerProgrammaticLaunchCompletion with all thread blocks when it\u2019s ready for the secondary kernel to launch. The secondary kernel must be launched using the extensible launch API as shown.\n\n__global__ void primary_kernel() {\n   // Initial work that should finish before starting secondary kernel\n\n   // Trigger the secondary kernel\n   cudaTriggerProgrammaticLaunchCompletion();\n\n   // Work that can coincide with the secondary kernel\n}\n\n__global__ void secondary_kernel()\n{\n   // Independent work\n\n   // Will block until all primary kernels the secondary kernel is dependent on have completed and flushed results to global memory\n   cudaGridDependencySynchronize();\n\n   // Dependent work\n}\n\ncudaLaunchAttribute attribute[1];\nattribute[0].id = cudaLaunchAttributeProgrammaticStreamSerialization;\nattribute[0].val.programmaticStreamSerializationAllowed = 1;\nconfigSecondary.attrs = attribute;\nconfigSecondary.numAttrs = 1;\n\nprimary_kernel<<<grid_dim, block_dim, 0, stream>>>();\ncudaLaunchKernelEx(&configSecondary, secondary_kernel);\n\nWhen the secondary kernel is launched using the cudaLaunchAttributeProgrammaticStreamSerialization attribute, the CUDA driver is safe to launch the secondary kernel early and not wait on the completion and memory flush of the primary before launching the secondary.\n\nThe CUDA driver can launch the secondary kernel when all primary thread blocks have launched and executed cudaTriggerProgrammaticLaunchCompletion. If the primary kernel doesn\u2019t execute the trigger, it implicitly occurs after all thread blocks in the primary kernel exit.\n\nIn either case, the secondary thread blocks might launch before data written by the primary kernel is visible. As such, when the secondary kernel is configured with Programmatic Dependent Launch, it must always use cudaGridDependencySynchronize or other means to verify that the result data from the primary is available.\n\nPlease note that these methods provide the opportunity for the primary and secondary kernels to execute concurrently, however this behavior is opportunistic and not guaranteed to lead to concurrent kernel execution. Reliance on concurrent execution in this manner is unsafe and can lead to deadlock.\n6.2.8.6.3. Use in CUDA Graphs\uf0c1\n\nProgrammatic Dependent Launch can be used in CUDA Graphs via stream capture or directly via edge data. To program this feature in a CUDA Graph with edge data, use a cudaGraphDependencyType value of cudaGraphDependencyTypeProgrammatic on an edge connecting two kernel nodes. This edge type makes the upstream kernel visible to a cudaGridDependencySynchronize() in the downstream kernel. This type must be used with an outgoing port of either cudaGraphKernelNodePortLaunchCompletion or cudaGraphKernelNodePortProgrammatic.\n\nThe resulting graph equivalents for stream capture are as follows:\n\nStream code (abbreviated)\n\t\n\nResulting graph edge\n\ncudaLaunchAttribute attribute;\nattribute.id = cudaLaunchAttributeProgrammaticStreamSerialization;\nattribute.val.programmaticStreamSerializationAllowed = 1;\n\ncudaGraphEdgeData edgeData;\nedgeData.type = cudaGraphDependencyTypeProgrammatic;\nedgeData.from_port = cudaGraphKernelNodePortProgrammatic;\n\ncudaLaunchAttribute attribute;\nattribute.id = cudaLaunchAttributeProgrammaticEvent;\nattribute.val.programmaticEvent.triggerAtBlockStart = 0;\n\ncudaGraphEdgeData edgeData;\nedgeData.type = cudaGraphDependencyTypeProgrammatic;\nedgeData.from_port = cudaGraphKernelNodePortProgrammatic;\n\ncudaLaunchAttribute attribute;\nattribute.id = cudaLaunchAttributeProgrammaticEvent;\nattribute.val.programmaticEvent.triggerAtBlockStart = 1;\n\ncudaGraphEdgeData edgeData;\nedgeData.type = cudaGraphDependencyTypeProgrammatic;\nedgeData.from_port = cudaGraphKernelNodePortLaunchCompletion;\n\n6.2.8.7. CUDA Graphs\uf0c1\n\nCUDA Graphs present a new model for work submission in CUDA. A graph is a series of operations, such as kernel launches, connected by dependencies, which is defined separately from its execution. This allows a graph to be defined once and then launched repeatedly. Separating out the definition of a graph from its execution enables a number of optimizations: first, CPU launch costs are reduced compared to streams, because much of the setup is done in advance; second, presenting the whole workflow to CUDA enables optimizations which might not be possible with the piecewise work submission mechanism of streams.\n\nTo see the optimizations possible with graphs, consider what happens in a stream: when you place a kernel into a stream, the host driver performs a sequence of operations in preparation for the execution of the kernel on the GPU. These operations, necessary for setting up and launching the kernel, are an overhead cost which must be paid for each kernel that is issued. For a GPU kernel with a short execution time, this overhead cost can be a significant fraction of the overall end-to-end execution time.\n\nWork submission using graphs is separated into three distinct stages: definition, instantiation, and execution.\n\n    During the definition phase, a program creates a description of the operations in the graph along with the dependencies between them.\n\n    Instantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The resulting instance is known as an executable graph.\n\n    An executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation.\n\n6.2.8.7.1. Graph Structure\uf0c1\n\nAn operation forms a node in a graph. The dependencies between the operations are the edges. These dependencies constrain the execution sequence of the operations.\n\nAn operation may be scheduled at any time once the nodes on which it depends are complete. Scheduling is left up to the CUDA system.\n6.2.8.7.1.1. Node Types\uf0c1\n\nA graph node can be one of:\n\n    kernel\n\n    CPU function call\n\n    memory copy\n\n    memset\n\n    empty node\n\n    waiting on an event\n\n    recording an event\n\n    signalling an external semaphore\n\n    waiting on an external semaphore\n\n    conditional node\n\n    Graph Memory Nodes\n\n    child graph: To execute a separate nested graph, as shown in the following figure.\n\nChild Graph Example\n\nFigure 13 Child Graph Example\uf0c1\n6.2.8.7.1.2. Edge Data\uf0c1\n\nCUDA 12.3 introduced edge data on CUDA Graphs. Edge data modifies a dependency specified by an edge and consists of three parts: an outgoing port, an incoming port, and a type. An outgoing port specifies when an associated edge is triggered. An incoming port specifies what portion of a node is dependent on an associated edge. A type modifies the relation between the endpoints.\n\nPort values are specific to node type and direction, and edge types may be restricted to specific node types. In all cases, zero-initialized edge data represents default behavior. Outgoing port 0 waits on an entire task, incoming port 0 blocks an entire task, and edge type 0 is associated with a full dependency with memory synchronizing behavior.\n\nEdge data is optionally specified in various graph APIs via a parallel array to the associated nodes. If it is omitted as an input parameter, zero-initialized data is used. If it is omitted as an output (query) parameter, the API accepts this if the edge data being ignored is all zero-initialized, and returns cudaErrorLossyQuery if the call would discard information.\n\nEdge data is also available in some stream capture APIs: cudaStreamBeginCaptureToGraph(), cudaStreamGetCaptureInfo(), and cudaStreamUpdateCaptureDependencies(). In these cases, there is not yet a downstream node. The data is associated with a dangling edge (half edge) which will either be connected to a future captured node or discarded at termination of stream capture. Note that some edge types do not wait on full completion of the upstream node. These edges are ignored when considering if a stream capture has been fully rejoined to the origin stream, and cannot be discarded at the end of capture. See Creating a Graph Using Stream Capture.\n\nCurrently, no node types define additional incoming ports, and only kernel nodes define additional outgoing ports. There is one non-default dependency type, cudaGraphDependencyTypeProgrammatic, which enables Programmatic Dependent Launch between two kernel nodes.\n6.2.8.7.2. Creating a Graph Using Graph APIs\uf0c1\n\nGraphs can be created via two mechanisms: explicit API and stream capture. The following is an example of creating and executing the below graph.\nCreating a Graph Using Graph APIs Example\n\nFigure 14 Creating a Graph Using Graph APIs Example\uf0c1\n\n// Create the graph - it starts out empty\ncudaGraphCreate(&graph, 0);\n\n// For the purpose of this example, we'll create\n// the nodes separately from the dependencies to\n// demonstrate that it can be done in two stages.\n// Note that dependencies can also be specified\n// at node creation.\ncudaGraphAddKernelNode(&a, graph, NULL, 0, &nodeParams);\ncudaGraphAddKernelNode(&b, graph, NULL, 0, &nodeParams);\ncudaGraphAddKernelNode(&c, graph, NULL, 0, &nodeParams);\ncudaGraphAddKernelNode(&d, graph, NULL, 0, &nodeParams);\n\n// Now set up dependencies on each node\ncudaGraphAddDependencies(graph, &a, &b, NULL, 1);     // A->B\ncudaGraphAddDependencies(graph, &a, &c, NULL, 1);     // A->C\ncudaGraphAddDependencies(graph, &b, &d, NULL, 1);     // B->D\ncudaGraphAddDependencies(graph, &c, &d, NULL, 1);     // C->D\n\n6.2.8.7.3. Creating a Graph Using Stream Capture\uf0c1\n\nStream capture provides a mechanism to create a graph from existing stream-based APIs. A section of code which launches work into streams, including existing code, can be bracketed with calls to cudaStreamBeginCapture() and cudaStreamEndCapture(). See below.\n\ncudaGraph_t graph;\n\ncudaStreamBeginCapture(stream);\n\nkernel_A<<< ..., stream >>>(...);\nkernel_B<<< ..., stream >>>(...);\nlibraryCall(stream);\nkernel_C<<< ..., stream >>>(...);\n\ncudaStreamEndCapture(stream, &graph);\n\nA call to cudaStreamBeginCapture() places a stream in capture mode. When a stream is being captured, work launched into the stream is not enqueued for execution. It is instead appended to an internal graph that is progressively being built up. This graph is then returned by calling cudaStreamEndCapture(), which also ends capture mode for the stream. A graph which is actively being constructed by stream capture is referred to as a capture graph.\n\nStream capture can be used on any CUDA stream except cudaStreamLegacy (the \u201cNULL stream\u201d). Note that it can be used on cudaStreamPerThread. If a program is using the legacy stream, it may be possible to redefine stream 0 to be the per-thread stream with no functional change. See Default Stream.\n\nWhether a stream is being captured can be queried with cudaStreamIsCapturing().\n\nWork can be captured to an existing graph using cudaStreamBeginCaptureToGraph(). Instead of capturing to an internal graph, work is captured to a graph provided by the user.\n6.2.8.7.3.1. Cross-stream Dependencies and Events\uf0c1\n\nStream capture can handle cross-stream dependencies expressed with cudaEventRecord() and cudaStreamWaitEvent(), provided the event being waited upon was recorded into the same capture graph.\n\nWhen an event is recorded in a stream that is in capture mode, it results in a captured event. A captured event represents a set of nodes in a capture graph.\n\nWhen a captured event is waited on by a stream, it places the stream in capture mode if it is not already, and the next item in the stream will have additional dependencies on the nodes in the captured event. The two streams are then being captured to the same capture graph.\n\nWhen cross-stream dependencies are present in stream capture, cudaStreamEndCapture() must still be called in the same stream where cudaStreamBeginCapture() was called; this is the origin stream. Any other streams which are being captured to the same capture graph, due to event-based dependencies, must also be joined back to the origin stream. This is illustrated below. All streams being captured to the same capture graph are taken out of capture mode upon cudaStreamEndCapture(). Failure to rejoin to the origin stream will result in failure of the overall capture operation.\n\n// stream1 is the origin stream\ncudaStreamBeginCapture(stream1);\n\nkernel_A<<< ..., stream1 >>>(...);\n\n// Fork into stream2\ncudaEventRecord(event1, stream1);\ncudaStreamWaitEvent(stream2, event1);\n\nkernel_B<<< ..., stream1 >>>(...);\nkernel_C<<< ..., stream2 >>>(...);\n\n// Join stream2 back to origin stream (stream1)\ncudaEventRecord(event2, stream2);\ncudaStreamWaitEvent(stream1, event2);\n\nkernel_D<<< ..., stream1 >>>(...);\n\n// End capture in the origin stream\ncudaStreamEndCapture(stream1, &graph);\n\n// stream1 and stream2 no longer in capture mode\n\nGraph returned by the above code is shown in Figure 14.\n\nNote\n\nWhen a stream is taken out of capture mode, the next non-captured item in the stream (if any) will still have a dependency on the most recent prior non-captured item, despite intermediate items having been removed.\n6.2.8.7.3.2. Prohibited and Unhandled Operations\uf0c1\n\nIt is invalid to synchronize or query the execution status of a stream which is being captured or a captured event, because they do not represent items scheduled for execution. It is also invalid to query the execution status of or synchronize a broader handle which encompasses an active stream capture, such as a device or context handle when any associated stream is in capture mode.\n\nWhen any stream in the same context is being captured, and it was not created with cudaStreamNonBlocking, any attempted use of the legacy stream is invalid. This is because the legacy stream handle at all times encompasses these other streams; enqueueing to the legacy stream would create a dependency on the streams being captured, and querying it or synchronizing it would query or synchronize the streams being captured.\n\nIt is therefore also invalid to call synchronous APIs in this case. Synchronous APIs, such as cudaMemcpy(), enqueue work to the legacy stream and synchronize it before returning.\n\nNote\n\nAs a general rule, when a dependency relation would connect something that is captured with something that was not captured and instead enqueued for execution, CUDA prefers to return an error rather than ignore the dependency. An exception is made for placing a stream into or out of capture mode; this severs a dependency relation between items added to the stream immediately before and after the mode transition.\n\nIt is invalid to merge two separate capture graphs by waiting on a captured event from a stream which is being captured and is associated with a different capture graph than the event. It is invalid to wait on a non-captured event from a stream which is being captured without specifying the cudaEventWaitExternal flag.\n\nA small number of APIs that enqueue asynchronous operations into streams are not currently supported in graphs and will return an error if called with a stream which is being captured, such as cudaStreamAttachMemAsync().\n6.2.8.7.3.3. Invalidation\uf0c1\n\nWhen an invalid operation is attempted during stream capture, any associated capture graphs are invalidated. When a capture graph is invalidated, further use of any streams which are being captured or captured events associated with the graph is invalid and will return an error, until stream capture is ended with cudaStreamEndCapture(). This call will take the associated streams out of capture mode, but will also return an error value and a NULL graph.\n6.2.8.7.4. CUDA User Objects\uf0c1\n\nCUDA User Objects can be used to help manage the lifetime of resources used by asynchronous work in CUDA. In particular, this feature is useful for CUDA Graphs and stream capture.\n\nVarious resource management schemes are not compatible with CUDA graphs. Consider for example an event-based pool or a synchronous-create, asynchronous-destroy scheme.\n\n// Library API with pool allocation\nvoid libraryWork(cudaStream_t stream) {\n    auto &resource = pool.claimTemporaryResource();\n    resource.waitOnReadyEventInStream(stream);\n    launchWork(stream, resource);\n    resource.recordReadyEvent(stream);\n}\n\n// Library API with asynchronous resource deletion\nvoid libraryWork(cudaStream_t stream) {\n    Resource *resource = new Resource(...);\n    launchWork(stream, resource);\n    cudaLaunchHostFunc(\n        stream,\n        [](void *resource) {\n            delete static_cast<Resource *>(resource);\n        },\n        resource,\n        0);\n    // Error handling considerations not shown\n}\n\nThese schemes are difficult with CUDA graphs because of the non-fixed pointer or handle for the resource which requires indirection or graph update, and the synchronous CPU code needed each time the work is submitted. They also do not work with stream capture if these considerations are hidden from the caller of the library, and because of use of disallowed APIs during capture. Various solutions exist such as exposing the resource to the caller. CUDA user objects present another approach.\n\nA CUDA user object associates a user-specified destructor callback with an internal refcount, similar to C++ shared_ptr. References may be owned by user code on the CPU and by CUDA graphs. Note that for user-owned references, unlike C++ smart pointers, there is no object representing the reference; users must track user-owned references manually. A typical use case would be to immediately move the sole user-owned reference to a CUDA graph after the user object is created.\n\nWhen a reference is associated to a CUDA graph, CUDA will manage the graph operations automatically. A cloned cudaGraph_t retains a copy of every reference owned by the source cudaGraph_t, with the same multiplicity. An instantiated cudaGraphExec_t retains a copy of every reference in the source cudaGraph_t. When a cudaGraphExec_t is destroyed without being synchronized, the references are retained until the execution is completed.\n\nHere is an example use.\n\ncudaGraph_t graph;  // Preexisting graph\n\nObject *object = new Object;  // C++ object with possibly nontrivial destructor\ncudaUserObject_t cuObject;\ncudaUserObjectCreate(\n    &cuObject,\n    object,  // Here we use a CUDA-provided template wrapper for this API,\n             // which supplies a callback to delete the C++ object pointer\n    1,  // Initial refcount\n    cudaUserObjectNoDestructorSync  // Acknowledge that the callback cannot be\n                                    // waited on via CUDA\n);\ncudaGraphRetainUserObject(\n    graph,\n    cuObject,\n    1,  // Number of references\n    cudaGraphUserObjectMove  // Transfer a reference owned by the caller (do\n                             // not modify the total reference count)\n);\n// No more references owned by this thread; no need to call release API\ncudaGraphExec_t graphExec;\ncudaGraphInstantiate(&graphExec, graph, nullptr, nullptr, 0);  // Will retain a\n                                                               // new reference\ncudaGraphDestroy(graph);  // graphExec still owns a reference\ncudaGraphLaunch(graphExec, 0);  // Async launch has access to the user objects\ncudaGraphExecDestroy(graphExec);  // Launch is not synchronized; the release\n                                  // will be deferred if needed\ncudaStreamSynchronize(0);  // After the launch is synchronized, the remaining\n                           // reference is released and the destructor will\n                           // execute. Note this happens asynchronously.\n// If the destructor callback had signaled a synchronization object, it would\n// be safe to wait on it at this point.\n\nReferences owned by graphs in child graph nodes are associated to the child graphs, not the parents. If a child graph is updated or deleted, the references change accordingly. If an executable graph or child graph is updated with cudaGraphExecUpdate or cudaGraphExecChildGraphNodeSetParams, the references in the new source graph are cloned and replace the references in the target graph. In either case, if previous launches are not synchronized, any references which would be released are held until the launches have finished executing.\n\nThere is not currently a mechanism to wait on user object destructors via a CUDA API. Users may signal a synchronization object manually from the destructor code. In addition, it is not legal to call CUDA APIs from the destructor, similar to the restriction on cudaLaunchHostFunc. This is to avoid blocking a CUDA internal shared thread and preventing forward progress. It is legal to signal another thread to perform an API call, if the dependency is one way and the thread doing the call cannot block forward progress of CUDA work.\n\nUser objects are created with cudaUserObjectCreate, which is a good starting point to browse related APIs.\n6.2.8.7.5. Updating Instantiated Graphs\uf0c1\n\nWork submission using graphs is separated into three distinct stages: definition, instantiation, and execution. In situations where the workflow is not changing, the overhead of definition and instantiation can be amortized over many executions, and graphs provide a clear advantage over streams.\n\nA graph is a snapshot of a workflow, including kernels, parameters, and dependencies, in order to replay it as rapidly and efficiently as possible. In situations where the workflow changes the graph becomes out of date and must be modified. Major changes to graph structure such as topology or types of nodes will require re-instantiation of the source graph because various topology-related optimization techniques must be re-applied.\n\nThe cost of repeated instantiation can reduce the overall performance benefit from graph execution, but it is common for only node parameters, such as kernel parameters and cudaMemcpy addresses, to change while graph topology remains the same. For this case, CUDA provides a lightweight mechanism known as \u201cGraph Update,\u201d which allows certain node parameters to be modified in-place without having to rebuild the entire graph. This is much more efficient than re-instantiation.\n\nUpdates will take effect the next time the graph is launched, so they will not impact previous graph launches, even if they are running at the time of the update. A graph may be updated and relaunched repeatedly, so multiple updates/launches can be queued on a stream.\n\nCUDA provides two mechanisms for updating instantiated graph parameters, whole graph update and individual node update. Whole graph update allows the user to supply a topologically identical cudaGraph_t object whose nodes contain updated parameters. Individual node update allows the user to explicitly update the parameters of individual nodes. Using an updated cudaGraph_t is more convenient when a large number of nodes are being updated, or when the graph topology is unknown to the caller (i.e., The graph resulted from stream capture of a library call). Using individual node update is preferred when the number of changes is small and the user has the handles to the nodes requiring updates. Individual node update skips the topology checks and comparisons for unchanged nodes, so it can be more efficient in many cases.\n\nCUDA also provides a mechanism for enabling and disabling individual nodes without affecting their current parameters.\n\nThe following sections explain each approach in more detail.\n6.2.8.7.5.1. Graph Update Limitations\uf0c1\n\nKernel nodes:\n\n    The owning context of the function cannot change.\n\n    A node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CUDA dynamic parallelism.\n\ncudaMemset and cudaMemcpy nodes:\n\n    The CUDA device(s) to which the operand(s) was allocated/mapped cannot change.\n\n    The source/destination memory must be allocated from the same context as the original source/destination memory.\n\n    Only 1D cudaMemset/cudaMemcpy nodes can be changed.\n\nAdditional memcpy node restrictions:\n\n    Changing either the source or destination memory type (i.e., cudaPitchedPtr, cudaArray_t, etc.), or the type of transfer (i.e., cudaMemcpyKind) is not supported.\n\nExternal semaphore wait nodes and record nodes:\n\n    Changing the number of semaphores is not supported.\n\nConditional nodes:\n\n    The order of handle creation and assignment must match between the graphs.\n\n    Changing node parameters is not supported (i.e. number of graphs in the conditional, node context, etc).\n\n    Changing parameters of nodes within the conditional body graph is subject to the rules above.\n\nMemory nodes:\n\n    It is not possible to update a cudaGraphExec_t with a cudaGraph_t if the cudaGraph_t is currently instantiated as a different cudaGraphExec_t.\n\nThere are no restrictions on updates to host nodes, event record nodes, or event wait nodes.\n6.2.8.7.5.2. Whole Graph Update\uf0c1\n\ncudaGraphExecUpdate() allows an instantiated graph (the \u201coriginal graph\u201d) to be updated with the parameters from a topologically identical graph (the \u201cupdating\u201d graph). The topology of the updating graph must be identical to the original graph used to instantiate the cudaGraphExec_t. In addition, the order in which the dependencies are specified must match. Finally, CUDA needs to consistently order the sink nodes (nodes with no dependencies). CUDA relies on the order of specific api calls to achieve consistent sink node ordering.\n\nMore explicitly, following the following rules will cause cudaGraphExecUpdate() to pair the nodes in the original graph and the updating graph deterministically:\n\n    For any capturing stream, the API calls operating on that stream must be made in the same order, including event wait and other api calls not directly corresponding to node creation.\n\n    The API calls which directly manipulate a given graph node\u2019s incoming edges (including captured stream APIs, node add APIs, and edge addition / removal APIs) must be made in the same order. Moreover, when dependencies are specified in arrays to these APIs, the order in which the dependencies are specified inside those arrays must match.\n\n    Sink nodes must be consistently ordered. Sink nodes are nodes without dependent nodes / outgoing edges in the final graph at the time of the cudaGraphExecUpdate() invocation. The following operations affect sink node ordering (if present) and must (as a combined set) be made in the same order:\n\n        Node add APIs resulting in a sink node.\n\n        Edge removal resulting in a node becoming a sink node.\n\n        cudaStreamUpdateCaptureDependencies(), if it removes a sink node from a capturing stream\u2019s dependency set.\n\n        cudaStreamEndCapture().\n\nThe following example shows how the API could be used to update an instantiated graph:\n\ncudaGraphExec_t graphExec = NULL;\n\nfor (int i = 0; i < 10; i++) {\n    cudaGraph_t graph;\n    cudaGraphExecUpdateResult updateResult;\n    cudaGraphNode_t errorNode;\n\n    // In this example we use stream capture to create the graph.\n    // You can also use the Graph API to produce a graph.\n    cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal);\n\n    // Call a user-defined, stream based workload, for example\n    do_cuda_work(stream);\n\n    cudaStreamEndCapture(stream, &graph);\n\n    // If we've already instantiated the graph, try to update it directly\n    // and avoid the instantiation overhead\n    if (graphExec != NULL) {\n        // If the graph fails to update, errorNode will be set to the\n        // node causing the failure and updateResult will be set to a\n        // reason code.\n        cudaGraphExecUpdate(graphExec, graph, &errorNode, &updateResult);\n    }\n\n    // Instantiate during the first iteration or whenever the update\n    // fails for any reason\n    if (graphExec == NULL || updateResult != cudaGraphExecUpdateSuccess) {\n\n        // If a previous update failed, destroy the cudaGraphExec_t\n        // before re-instantiating it\n        if (graphExec != NULL) {\n            cudaGraphExecDestroy(graphExec);\n        }\n        // Instantiate graphExec from graph. The error node and\n        // error message parameters are unused here.\n        cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);\n    }\n\n    cudaGraphDestroy(graph);\n    cudaGraphLaunch(graphExec, stream);\n    cudaStreamSynchronize(stream);\n}\n\nA typical workflow is to create the initial cudaGraph_t using either the stream capture or graph API. The cudaGraph_t is then instantiated and launched as normal. After the initial launch, a new cudaGraph_t is created using the same method as the initial graph and cudaGraphExecUpdate() is called. If the graph update is successful, indicated by the updateResult parameter in the above example, the updated cudaGraphExec_t is launched. If the update fails for any reason, the cudaGraphExecDestroy() and cudaGraphInstantiate() are called to destroy the original cudaGraphExec_t and instantiate a new one.\n\nIt is also possible to update the cudaGraph_t nodes directly (i.e., Using cudaGraphKernelNodeSetParams()) and subsequently update the cudaGraphExec_t, however it is more efficient to use the explicit node update APIs covered in the next section.\n\nConditional handle flags and default values are updated as part of the graph update.\n\nPlease see the Graph API for more information on usage and current limitations.\n6.2.8.7.5.3. Individual Node Update\uf0c1\n\nInstantiated graph node parameters can be updated directly. This eliminates the overhead of instantiation as well as the overhead of creating a new cudaGraph_t. If the number of nodes requiring update is small relative to the total number of nodes in the graph, it is better to update the nodes individually. The following methods are available for updating cudaGraphExec_t nodes:\n\n    cudaGraphExecKernelNodeSetParams()\n\n    cudaGraphExecMemcpyNodeSetParams()\n\n    cudaGraphExecMemsetNodeSetParams()\n\n    cudaGraphExecHostNodeSetParams()\n\n    cudaGraphExecChildGraphNodeSetParams()\n\n    cudaGraphExecEventRecordNodeSetEvent()\n\n    cudaGraphExecEventWaitNodeSetEvent()\n\n    cudaGraphExecExternalSemaphoresSignalNodeSetParams()\n\n    cudaGraphExecExternalSemaphoresWaitNodeSetParams()\n\nPlease see the Graph API for more information on usage and current limitations.\n6.2.8.7.5.4. Individual Node Enable\uf0c1\n\nKernel, memset and memcpy nodes in an instantiated graph can be enabled or disabled using the cudaGraphNodeSetEnabled() API. This allows the creation of a graph which contains a superset of the desired functionality which can be customized for each launch. The enable state of a node can be queried using the cudaGraphNodeGetEnabled() API.\n\nA disabled node is functionally equivalent to empty node until it is reenabled. Node parameters are not affected by enabling/disabling a node. Enable state is unaffected by individual node update or whole graph update with cudaGraphExecUpdate(). Parameter updates while the node is disabled will take effect when the node is reenabled.\n\nThe following methods are available for enabling/disabling cudaGraphExec_t nodes, as well as querying their status:\n\n    cudaGraphNodeSetEnabled()\n\n    cudaGraphNodeGetEnabled()\n\nRefer to the Graph API for more information on usage and current limitations.\n6.2.8.7.6. Using Graph APIs\uf0c1\n\ncudaGraph_t objects are not thread-safe. It is the responsibility of the user to ensure that multiple threads do not concurrently access the same cudaGraph_t.\n\nA cudaGraphExec_t cannot run concurrently with itself. A launch of a cudaGraphExec_t will be ordered after previous launches of the same executable graph.\n\nGraph execution is done in streams for ordering with other asynchronous work. However, the stream is for ordering only; it does not constrain the internal parallelism of the graph, nor does it affect where graph nodes execute.\n\nSee Graph API.\n6.2.8.7.7. Device Graph Launch\uf0c1\n\nThere are many workflows which need to make data-dependent decisions during runtime and execute different operations depending on those decisions. Rather than offloading this decision-making process to the host, which may require a round-trip from the device, users may prefer to perform it on the device. To that end, CUDA provides a mechanism to launch graphs from the device.\n\nDevice graph launch provides a convenient way to perform dynamic control flow from the device, be it something as simple as a loop or as complex as a device-side work scheduler. This functionality is only available on systems which support unified addressing.\n\nGraphs which can be launched from the device will henceforth be referred to as device graphs, and graphs which cannot be launched from the device will be referred to as host graphs.\n\nDevice graphs can be launched from both the host and device, whereas host graphs can only be launched from the host. Unlike host launches, launching a device graph from the device while a previous launch of the graph is running will result in an error, returning cudaErrorInvalidValue; therefore, a device graph cannot be launched twice from the device at the same time. Launching a device graph from the host and device simultaneously will result in undefined behavior.\n6.2.8.7.7.1. Device Graph Creation\uf0c1\n\nIn order for a graph to be launched from the device, it must be instantiated explicitly for device launch. This is achieved by passing the cudaGraphInstantiateFlagDeviceLaunch flag to the cudaGraphInstantiate() call. As is the case for host graphs, device graph structure is fixed at time of instantiation and cannot be updated without re-instantiation, and instantiation can only be performed on the host. In order for a graph to be able to be instantiated for device launch, it must adhere to various requirements.\n6.2.8.7.7.1.1. Device Graph Requirements\uf0c1\n\nGeneral requirements:\n\n    The graph\u2019s nodes must all reside on a single device.\n\n    The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\n\nKernel nodes:\n\n    Use of CUDA Dynamic Parallelism by kernels in the graph is not permitted.\n\n    Cooperative launches are permitted so long as MPS is not in use.\n\nMemcpy nodes:\n\n    Only copies involving device memory and/or pinned device-mapped host memory are permitted.\n\n    Copies involving CUDA arrays are not permitted.\n\n    Both operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.\n\n6.2.8.7.7.1.2. Device Graph Upload\uf0c1\n\nIn order to launch a graph on the device, it must first be uploaded to the device to populate the necessary device resources. This can be achieved in one of two ways.\n\nFirstly, the graph can be uploaded explicitly, either via cudaGraphUpload() or by requesting an upload as part of instantiation via cudaGraphInstantiateWithParams().\n\nAlternatively, the graph can first be launched from the host, which will perform this upload step implicitly as part of the launch.\n\nExamples of all three methods can be seen below:\n\n// Explicit upload after instantiation\ncudaGraphInstantiate(&deviceGraphExec1, deviceGraph1, cudaGraphInstantiateFlagDeviceLaunch);\ncudaGraphUpload(deviceGraphExec1, stream);\n\n// Explicit upload as part of instantiation\ncudaGraphInstantiateParams instantiateParams = {0};\ninstantiateParams.flags = cudaGraphInstantiateFlagDeviceLaunch | cudaGraphInstantiateFlagUpload;\ninstantiateParams.uploadStream = stream;\ncudaGraphInstantiateWithParams(&deviceGraphExec2, deviceGraph2, &instantiateParams);\n\n// Implicit upload via host launch\ncudaGraphInstantiate(&deviceGraphExec3, deviceGraph3, cudaGraphInstantiateFlagDeviceLaunch);\ncudaGraphLaunch(deviceGraphExec3, stream);\n\n6.2.8.7.7.1.3. Device Graph Update\uf0c1\n\nDevice graphs can only be updated from the host, and must be re-uploaded to the device upon executable graph update in order for the changes to take effect. This can be achieved using the same methods outlined in the previous section. Unlike host graphs, launching a device graph from the device while an update is being applied will result in undefined behavior.\n6.2.8.7.7.2. Device Launch\uf0c1\n\nDevice graphs can be launched from both the host and the device via cudaGraphLaunch(), which has the same signature on the device as on the host. Device graphs are launched via the same handle on the host and the device. Device graphs must be launched from another graph when launched from the device.\n\nDevice-side graph launch is per-thread and multiple launches may occur from different threads at the same time, so the user will need to select a single thread from which to launch a given graph.\n6.2.8.7.7.2.1. Device Launch Modes\uf0c1\n\nUnlike host launch, device graphs cannot be launched into regular CUDA streams, and can only be launched into distinct named streams, which each denote a specific launch mode:\nTable 5 Device-only Graph Launch Streams\uf0c1\n\nStream\n\t\n\nLaunch Mode\n\ncudaStreamGraphFireAndForget\n\t\n\nFire and forget launch\n\ncudaStreamGraphTailLaunch\n\t\n\nTail launch\n\ncudaStreamGraphFireAndForgetAsSibling\n\t\n\nSibling launch\n6.2.8.7.7.2.1.1. Fire and Forget Launch\uf0c1\n\nAs the name suggests, a fire and forget launch is submitted to the GPU immediately, and it runs independently of the launching graph. In a fire-and-forget scenario, the launching graph is the parent, and the launched graph is the child.\n_images/fire-and-forget-simple.png\n\nFigure 15 Fire and forget launch\uf0c1\n\nThe above diagram can be generated by the sample code below:\n\n__global__ void launchFireAndForgetGraph(cudaGraphExec_t graph) {\n    cudaGraphLaunch(graph, cudaStreamGraphFireAndForget);\n}\n\nvoid graphSetup() {\n    cudaGraphExec_t gExec1, gExec2;\n    cudaGraph_t g1, g2;\n\n    // Create, instantiate, and upload the device graph.\n    create_graph(&g2);\n    cudaGraphInstantiate(&gExec2, g2, cudaGraphInstantiateFlagDeviceLaunch);\n    cudaGraphUpload(gExec2, stream);\n\n    // Create and instantiate the launching graph.\n    cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal);\n    launchFireAndForgetGraph<<<1, 1, 0, stream>>>(gExec2);\n    cudaStreamEndCapture(stream, &g1);\n    cudaGraphInstantiate(&gExec1, g1);\n\n    // Launch the host graph, which will in turn launch the device graph.\n    cudaGraphLaunch(gExec1, stream);\n}\n\nA graph can have up to 120 total fire-and-forget graphs during the course of its execution. This total resets between launches of the same parent graph.\n6.2.8.7.7.2.1.2. Graph Execution Environments\uf0c1\n\nIn order to fully understand the device-side synchronization model, it is first necessary to understand the concept of an execution environment.\n\nWhen a graph is launched from the device, it is launched into its own execution environment. The execution environment of a given graph encapsulates all work in the graph as well as all generated fire and forget work. The graph can be considered complete when it has completed execution and when all generated child work is complete.\n\nThe below diagram shows the environment encapsulation that would be generated by the fire-and-forget sample code in the previous section.\n_images/fire-and-forget-environments.png\n\nFigure 16 Fire and forget launch, with execution environments\uf0c1\n\nThese environments are also hierarchical, so a graph environment can include multiple levels of child-environments from fire and forget launches.\n_images/fire-and-forget-nested-environments.png\n\nFigure 17 Nested fire and forget environments\uf0c1\n\nWhen a graph is launched from the host, there exists a stream environment that parents the execution environment of the launched graph. The stream environment encapsulates all work generated as part of the overall launch. The stream launch is complete (i.e. downstream dependent work may now run) when the overall stream environment is marked as complete.\n_images/device-graph-stream-environment.png\n\nFigure 18 The stream environment, visualized\uf0c1\n6.2.8.7.7.2.1.3. Tail Launch\uf0c1\n\nUnlike on the host, it is not possible to synchronize with device graphs from the GPU via traditional methods such as cudaDeviceSynchronize() or cudaStreamSynchronize(). Rather, in order to enable serial work dependencies, a different launch mode - tail launch - is offered, to provide similar functionality.\n\nA tail launch executes when a graph\u2019s environment is considered complete - ie, when the graph and all its children are complete. When a graph completes, the environment of the next graph in the tail launch list will replace the completed environment as a child of the parent environment. Like fire-and-forget launches, a graph can have multiple graphs enqueued for tail launch.\n_images/tail-launch-simple.png\n\nFigure 19 A simple tail launch\uf0c1\n\nThe above execution flow can be generated by the code below:\n\n__global__ void launchTailGraph(cudaGraphExec_t graph) {\n    cudaGraphLaunch(graph, cudaStreamGraphTailLaunch);\n}\n\nvoid graphSetup() {\n    cudaGraphExec_t gExec1, gExec2;\n    cudaGraph_t g1, g2;\n\n    // Create, instantiate, and upload the device graph.\n    create_graph(&g2);\n    cudaGraphInstantiate(&gExec2, g2, cudaGraphInstantiateFlagDeviceLaunch);\n    cudaGraphUpload(gExec2, stream);\n\n    // Create and instantiate the launching graph.\n    cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal);\n    launchTailGraph<<<1, 1, 0, stream>>>(gExec2);\n    cudaStreamEndCapture(stream, &g1);\n    cudaGraphInstantiate(&gExec1, g1);\n\n    // Launch the host graph, which will in turn launch the device graph.\n    cudaGraphLaunch(gExec1, stream);\n}\n\nTail launches enqueued by a given graph will execute one at a time, in order of when they were enqueued. So the first enqueued graph will run first, and then the second, and so on.\n_images/tail-launch-ordering-simple.png\n\nFigure 20 Tail launch ordering\uf0c1\n\nTail launches enqueued by a tail graph will execute before tail launches enqueued by previous graphs in the tail launch list. These new tail launches will execute in the order they are enqueued.\n_images/tail-launch-ordering-complex.png\n\nFigure 21 Tail launch ordering when enqueued from multiple graphs\uf0c1\n\nA graph can have up to 255 pending tail launches.\n6.2.8.7.7.2.1.3.1. Tail Self-launch\uf0c1\n\nIt is possible for a device graph to enqueue itself for a tail launch, although a given graph can only have one self-launch enqueued at a time. In order to query the currently running device graph so that it can be relaunched, a new device-side function is added:\n\ncudaGraphExec_t cudaGetCurrentGraphExec();\n\nThis function returns the handle of the currently running graph if it is a device graph. If the currently executing kernel is not a node within a device graph, this function will return NULL.\n\nBelow is sample code showing usage of this function for a relaunch loop:\n\n__device__ int relaunchCount = 0;\n\n__global__ void relaunchSelf() {\n    int relaunchMax = 100;\n\n    if (threadIdx.x == 0) {\n        if (relaunchCount < relaunchMax) {\n            cudaGraphLaunch(cudaGetCurrentGraphExec(), cudaStreamGraphTailLaunch);\n        }\n\n        relaunchCount++;\n    }\n}\n\n6.2.8.7.7.2.1.4. Sibling Launch\uf0c1\n\nSibling launch is a variation of fire-and-forget launch in which the graph is launched not as a child of the launching graph\u2019s execution environment, but rather as a child of the launching graph\u2019s parent environment. Sibling launch is equivalent to a fire-and-forget launch from the launching graph\u2019s parent environment.\n_images/sibling-launch-simple.png\n\nFigure 22 A simple sibling launch\uf0c1\n\nThe above diagram can be generated by the sample code below:\n\n__global__ void launchSiblingGraph(cudaGraphExec_t graph) {\n    cudaGraphLaunch(graph, cudaStreamGraphFireAndForgetAsSibling);\n}\n\nvoid graphSetup() {\n    cudaGraphExec_t gExec1, gExec2;\n    cudaGraph_t g1, g2;\n\n    // Create, instantiate, and upload the device graph.\n    create_graph(&g2);\n    cudaGraphInstantiate(&gExec2, g2, cudaGraphInstantiateFlagDeviceLaunch);\n    cudaGraphUpload(gExec2, stream);\n\n    // Create and instantiate the launching graph.\n    cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal);\n    launchSiblingGraph<<<1, 1, 0, stream>>>(gExec2);\n    cudaStreamEndCapture(stream, &g1);\n    cudaGraphInstantiate(&gExec1, g1);\n\n    // Launch the host graph, which will in turn launch the device graph.\n    cudaGraphLaunch(gExec1, stream);\n}\n\nSince sibling launches are not launched into the launching graph\u2019s execution environment, they will not gate tail launches enqueued by the launching graph.\n6.2.8.7.8. Conditional Graph Nodes\uf0c1\n\nConditional nodes allow conditional execution and looping of a graph contained within the conditional node. This allows dynamic and iterative workflows to be represented completely within a graph and frees up the host CPU to perform other work in parallel.\n\nEvaluation of the condition value is performed on the device when the dependencies of the conditional node have been met. Conditional nodes can be one of the following types:\n\n    Conditional IF nodes execute their body graph once if the condition value is non-zero when the node is executed. An optional second body graph can be provided and this will be executed once if the condition value is zero when the node is executed.\n\n    Conditional WHILE nodes execute their body graph if the condition value is non-zero when the node is executed and will continue to execute their body graph until the condition value is zero.\n\n    Conditional SWITCH nodes execute the nth body graph once if the condition value is equal to n. If the condition value does not correspond to a body graph, no body graph is launched.\n\nA condition value is accessed by a conditional handle , which must be created before the node. The condition value can be set by device code using cudaGraphSetConditional(). A default value, applied on each graph launch, can also be specified when the handle is created.\n\nWhen the conditional node is created, an empty graph is created and the handle is returned to the user so that the graph can be populated. This conditional body graph can be populated using either the graph APIs or cudaStreamBeginCaptureToGraph().\n\nConditional nodes can be nested.\n6.2.8.7.8.1. Conditional Handles\uf0c1\n\nA condition value is represented by cudaGraphConditionalHandle and is created by cudaGraphConditionalHandleCreate().\n\nThe handle must be associated with a single conditional node. Handles cannot be destroyed.\n\nIf cudaGraphCondAssignDefault is specified when the handle is created, the condition value will be initialized to the specified default at the beginning of each graph execution. If this flag is not provided, the condition value is undefined at the start of each graph execution and code should not assume that the condition value persists across executions.\n\nThe default value and flags associated with a handle will be updated during whole graph update.\n6.2.8.7.8.2. Condtional Node Body Graph Requirements\uf0c1\n\nGeneral requirements:\n\n    The graph\u2019s nodes must all reside on a single device.\n\n    The graph can only contain kernel nodes, empty nodes, memcpy nodes, memset nodes, child graph nodes, and conditional nodes.\n\nKernel nodes:\n\n    Use of CUDA Dynamic Parallelism or Device Graph Launch by kernels in the graph is not permitted.\n\n    Cooperative launches are permitted so long as MPS is not in use.\n\nMemcpy/Memset nodes:\n\n    Only copies/memsets involving device memory and/or pinned device-mapped host memory are permitted.\n\n    Copies/memsets involving CUDA arrays are not permitted.\n\n    Both operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.\n\n6.2.8.7.8.3. Conditional IF Nodes\uf0c1\n\nThe body graph of an IF node will be executed once if the condition is non-zero when the node is executed. The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:\n_images/conditional-if-node.png\n\nFigure 23 Conditional IF Node\uf0c1\n\nThe following code illustrates the creation of a graph containing an IF conditional node. The default value of the condition is set using an upstream kernel. The body of the conditional is populated using the graph API.\n\n__global__ void setHandle(cudaGraphConditionalHandle handle)\n{\n    ...\n    cudaGraphSetConditional(handle, value);\n    ...\n}\n\nvoid graphSetup() {\n    cudaGraph_t graph;\n    cudaGraphExec_t graphExec;\n    cudaGraphNode_t node;\n    void *kernelArgs[1];\n    int value = 1;\n\n    cudaGraphCreate(&graph, 0);\n\n    cudaGraphConditionalHandle handle;\n    cudaGraphConditionalHandleCreate(&handle, graph);\n\n    // Use a kernel upstream of the conditional to set the handle value\n    cudaGraphNodeParams params = { cudaGraphNodeTypeKernel };\n    params.kernel.func = (void *)setHandle;\n    params.kernel.gridDim.x = params.kernel.gridDim.y = params.kernel.gridDim.z = 1;\n    params.kernel.blockDim.x = params.kernel.blockDim.y = params.kernel.blockDim.z = 1;\n    params.kernel.kernelParams = kernelArgs;\n    kernelArgs[0] = &handle;\n    cudaGraphAddNode(&node, graph, NULL, NULL, 0, &params);\n\n    cudaGraphNodeParams cParams = { cudaGraphNodeTypeConditional };\n    cParams.conditional.handle = handle;\n    cParams.conditional.type   = cudaGraphCondTypeIf;\n    cParams.conditional.size   = 1;\n    cudaGraphAddNode(&node, graph, &node, NULL, 1, &cParams);\n\n    cudaGraph_t bodyGraph = cParams.conditional.phGraph_out[0];\n\n    // Populate the body of the conditional node\n    ...\n    cudaGraphAddNode(&node, bodyGraph, NULL, NULL, 0, &params);\n\n    cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);\n    cudaGraphLaunch(graphExec, 0);\n    cudaDeviceSynchronize();\n\n    cudaGraphExecDestroy(graphExec);\n    cudaGraphDestroy(graph);\n}\n\nStarting in CUDA 12.8, IF nodes can also have an optional second body graph which is executed once when the node is executed if the condition value is zero.\n\nvoid graphSetup() {\n    cudaGraph_t graph;\n    cudaGraphExec_t graphExec;\n    cudaGraphNode_t node;\n    void *kernelArgs[1];\n    int value = 1;\n\n    cudaGraphCreate(&graph, 0);\n\n    cudaGraphConditionalHandle handle;\n    cudaGraphConditionalHandleCreate(&handle, graph);\n\n    // Use a kernel upstream of the conditional to set the handle value\n    cudaGraphNodeParams params = { cudaGraphNodeTypeKernel };\n    params.kernel.func = (void *)setHandle;\n    params.kernel.gridDim.x = params.kernel.gridDim.y = params.kernel.gridDim.z = 1;\n    params.kernel.blockDim.x = params.kernel.blockDim.y = params.kernel.blockDim.z = 1;\n    params.kernel.kernelParams = kernelArgs;\n    kernelArgs[0] = &handle;\n    cudaGraphAddNode(&node, graph, NULL, NULL, 0, &params);\n\n    cudaGraphNodeParams cParams = { cudaGraphNodeTypeConditional };\n    cParams.conditional.handle = handle;\n    cParams.conditional.type   = cudaGraphCondTypeIf;\n    cParams.conditional.size   = 2; // Note that size is now set to '2'\n    cudaGraphAddNode(&node, graph, &node, NULL, 1, &cParams);\n\n    cudaGraph_t ifBodyGraph = cParams.conditional.phGraph_out[0];\n    cudaGraph_t elseBodyGraph = cParams.conditional.phGraph_out[1];\n\n    // Populate the body graphs of the conditional node\n    ...\n    cudaGraphAddNode(&node, ifBodyGraph, NULL, NULL, 0, &params);\n    ...\n    cudaGraphAddNode(&node, elseBodyGraph, NULL, NULL, 0, &params);\n\n    cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);\n    cudaGraphLaunch(graphExec, 0);\n    cudaDeviceSynchronize();\n\n    cudaGraphExecDestroy(graphExec);\n    cudaGraphDestroy(graph);\n}\n\n6.2.8.7.8.4. Conditional WHILE Nodes\uf0c1\n\nThe body graph of a WHILE node will be executed as long as the condition is non-zero. The condition will be evaluated when the node is executed and after completion of the body graph. The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:\n_images/conditional-while-node.png\n\nFigure 24 Conditional WHILE Node\uf0c1\n\nThe following code illustrates the creation of a graph containing a WHILE conditional node. The handle is created using cudaGraphCondAssignDefault to avoid the need for an upstream kernel. The body of the conditional is populated using the graph API.\n\n__global__ void loopKernel(cudaGraphConditionalHandle handle)\n{\n    static int count = 10;\n    cudaGraphSetConditional(handle, --count ? 1 : 0);\n}\n\nvoid graphSetup() {\n    cudaGraph_t graph;\n    cudaGraphExec_t graphExec;\n    cudaGraphNode_t node;\n    void *kernelArgs[1];\n\n    cuGraphCreate(&graph, 0);\n\n    cudaGraphConditionalHandle handle;\n    cudaGraphConditionalHandleCreate(&handle, graph, 1, cudaGraphCondAssignDefault);\n\n    cudaGraphNodeParams cParams = { cudaGraphNodeTypeConditional };\n    cParams.conditional.handle = handle;\n    cParams.conditional.type   = cudaGraphCondTypeWhile;\n    cParams.conditional.size   = 1;\n    cudaGraphAddNode(&node, graph, NULL, NULL, 0, &cParams);\n\n    cudaGraph_t bodyGraph = cParams.conditional.phGraph_out[0];\n\n    cudaGraphNodeParams params = { cudaGraphNodeTypeKernel };\n    params.kernel.func = (void *)loopKernel;\n    params.kernel.gridDim.x = params.kernel.gridDim.y = params.kernel.gridDim.z = 1;\n    params.kernel.blockDim.x = params.kernel.blockDim.y = params.kernel.blockDim.z = 1;\n    params.kernel.kernelParams = kernelArgs;\n    kernelArgs[0] = &handle;\n    cudaGraphAddNode(&node, bodyGraph, NULL, NULL, 0, &params);\n\n    cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);\n    cudaGraphLaunch(graphExec, 0);\n    cudaDeviceSynchronize();\n\n    cudaGraphExecDestroy(graphExec);\n    cudaGraphDestroy(graph);\n}\n\n6.2.8.7.8.5. Conditional SWITCH Nodes\uf0c1\n\nSWITCH nodes, added in CUDA 12.8, execute 1 of n different graphs within the conditional node. The nth graph will be executed when the SWITCH node is evaluated if the condition value is n. If the condition value is greater than or equal to n, no graph will be executed. The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:\n_images/conditional-switch-node.png\n\nFigure 25 Conditional SWITCH Node\uf0c1\n\nThe following code illustrates the creation of a graph containing a SWITCH conditional node. The value of the condition is set using an upstream kernel. The bodies of the conditional are populated using the graph API.\n\n__global__ void setHandle(cudaGraphConditionalHandle handle)\n{\n    ...\n    cudaGraphSetConditional(handle, value);\n    ...\n}\n\nvoid graphSetup() {\n    cudaGraph_t graph;\n    cudaGraphExec_t graphExec;\n    cudaGraphNode_t node;\n    void *kernelArgs[1];\n    int value = 1;\n\n    cudaGraphCreate(&graph, 0);\n\n    cudaGraphConditionalHandle handle;\n    cudaGraphConditionalHandleCreate(&handle, graph);\n\n    // Use a kernel upstream of the conditional to set the handle value\n    cudaGraphNodeParams params = { cudaGraphNodeTypeKernel };\n    params.kernel.func = (void *)setHandle;\n    params.kernel.gridDim.x = params.kernel.gridDim.y = params.kernel.gridDim.z = 1;\n    params.kernel.blockDim.x = params.kernel.blockDim.y = params.kernel.blockDim.z = 1;\n    params.kernel.kernelParams = kernelArgs;\n    kernelArgs[0] = &handle;\n    cudaGraphAddNode(&node, graph, NULL, NULL, 0, &params);\n\n    cudaGraphNodeParams cParams = { cudaGraphNodeTypeConditional };\n    cParams.conditional.handle = handle;\n    cParams.conditional.type   = cudaGraphCondTypeSwitch;\n    cParams.conditional.size   = 5;\n    cudaGraphAddNode(&node, graph, &node, NULL, 1, &cParams);\n\n    cudaGraph_t *bodyGraphs = cParams.conditional.phGraph_out;\n\n    // Populate the first body of the conditional node\n    ...\n    cudaGraphAddNode(&node, bodyGraphs[0], NULL, NULL, 0, &params);\n    ...\n    // Populate the last body of the conditional node\n    cudaGraphAddNode(&node, bodyGraphs[4], NULL, NULL, 0, &params);\n\n    cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);\n    cudaGraphLaunch(graphExec, 0);\n    cudaDeviceSynchronize();\n\n    cudaGraphExecDestroy(graphExec);\n    cudaGraphDestroy(graph);\n}\n\n6.2.8.8. Events\uf0c1\n\nThe runtime also provides a way to closely monitor the device\u2019s progress, as well as perform accurate timing, by letting the application asynchronously record events at any point in the program, and query when these events are completed. An event has completed when all tasks - or optionally, all commands in a given stream - preceding the event have completed. Events in stream zero are completed after all preceding tasks and commands in all streams are completed.\n6.2.8.8.1. Creation and Destruction of Events\uf0c1\n\nThe following code sample creates two events:\n\ncudaEvent_t start, stop;\ncudaEventCreate(&start);\ncudaEventCreate(&stop);\n\nThey are destroyed this way:\n\ncudaEventDestroy(start);\ncudaEventDestroy(stop);\n\n6.2.8.8.2. Elapsed Time\uf0c1\n\nThe events created in Creation and Destruction of Events can be used to time the code sample of Creation and Destruction of Streams the following way:\n\ncudaEventRecord(start, 0);\nfor (int i = 0; i < 2; ++i) {\n    cudaMemcpyAsync(inputDev + i * size, inputHost + i * size,\n                    size, cudaMemcpyHostToDevice, stream[i]);\n    MyKernel<<<100, 512, 0, stream[i]>>>\n               (outputDev + i * size, inputDev + i * size, size);\n    cudaMemcpyAsync(outputHost + i * size, outputDev + i * size,\n                    size, cudaMemcpyDeviceToHost, stream[i]);\n}\ncudaEventRecord(stop, 0);\ncudaEventSynchronize(stop);\nfloat elapsedTime;\ncudaEventElapsedTime(&elapsedTime, start, stop);\n\n6.2.8.9. Synchronous Calls\uf0c1\n\nWhen a synchronous function is called, control is not returned to the host thread before the device has completed the requested task. Whether the host thread will then yield, block, or spin can be specified by calling cudaSetDeviceFlags()with some specific flags (see reference manual for details) before any other CUDA call is performed by the host thread.\n6.2.9. Multi-Device System\uf0c1\n6.2.9.1. Device Enumeration\uf0c1\n\nA host system can have multiple devices. The following code sample shows how to enumerate these devices, query their properties, and determine the number of CUDA-enabled devices.\n\nint deviceCount;\ncudaGetDeviceCount(&deviceCount);\nint device;\nfor (device = 0; device < deviceCount; ++device) {\n    cudaDeviceProp deviceProp;\n    cudaGetDeviceProperties(&deviceProp, device);\n    printf(\"Device %d has compute capability %d.%d.\\n\",\n           device, deviceProp.major, deviceProp.minor);\n}\n\n6.2.9.2. Device Selection\uf0c1\n\nA host thread can set the device it operates on at any time by calling cudaSetDevice(). Device memory allocations and kernel launches are made on the currently set device; streams and events are created in association with the currently set device. If no call to cudaSetDevice() is made, the current device is device 0.\n\nThe following code sample illustrates how setting the current device affects memory allocation and kernel execution.\n\nsize_t size = 1024 * sizeof(float);\ncudaSetDevice(0);            // Set device 0 as current\nfloat* p0;\ncudaMalloc(&p0, size);       // Allocate memory on device 0\nMyKernel<<<1000, 128>>>(p0); // Launch kernel on device 0\ncudaSetDevice(1);            // Set device 1 as current\nfloat* p1;\ncudaMalloc(&p1, size);       // Allocate memory on device 1\nMyKernel<<<1000, 128>>>(p1); // Launch kernel on device 1\n\n6.2.9.3. Stream and Event Behavior\uf0c1\n\nA kernel launch will fail if it is issued to a stream that is not associated to the current device as illustrated in the following code sample.\n\ncudaSetDevice(0);               // Set device 0 as current\ncudaStream_t s0;\ncudaStreamCreate(&s0);          // Create stream s0 on device 0\nMyKernel<<<100, 64, 0, s0>>>(); // Launch kernel on device 0 in s0\ncudaSetDevice(1);               // Set device 1 as current\ncudaStream_t s1;\ncudaStreamCreate(&s1);          // Create stream s1 on device 1\nMyKernel<<<100, 64, 0, s1>>>(); // Launch kernel on device 1 in s1\n\n// This kernel launch will fail:\nMyKernel<<<100, 64, 0, s0>>>(); // Launch kernel on device 1 in s0\n\nA memory copy will succeed even if it is issued to a stream that is not associated to the current device.\n\ncudaEventRecord() will fail if the input event and input stream are associated to different devices.\n\ncudaEventElapsedTime() will fail if the two input events are associated to different devices.\n\ncudaEventSynchronize() and cudaEventQuery() will succeed even if the input event is associated to a device that is different from the current device.\n\ncudaStreamWaitEvent() will succeed even if the input stream and input event are associated to different devices. cudaStreamWaitEvent() can therefore be used to synchronize multiple devices with each other.\n\nEach device has its own default stream (see Default Stream), so commands issued to the default stream of a device may execute out of order or concurrently with respect to commands issued to the default stream of any other device.\n6.2.9.4. Peer-to-Peer Memory Access\uf0c1\n\nDepending on the system properties, specifically the PCIe and/or NVLINK topology, devices are able to address each other\u2019s memory (i.e., a kernel executing on one device can dereference a pointer to the memory of the other device). This peer-to-peer memory access feature is supported between two devices if cudaDeviceCanAccessPeer() returns true for these two devices.\n\nPeer-to-peer memory access is only supported in 64-bit applications and must be enabled between two devices by calling cudaDeviceEnablePeerAccess() as illustrated in the following code sample. On non-NVSwitch enabled systems, each device can support a system-wide maximum of eight peer connections.\n\nA unified address space is used for both devices (see Unified Virtual Address Space), so the same pointer can be used to address memory from both devices as shown in the code sample below.\n\ncudaSetDevice(0);                   // Set device 0 as current\nfloat* p0;\nsize_t size = 1024 * sizeof(float);\ncudaMalloc(&p0, size);              // Allocate memory on device 0\nMyKernel<<<1000, 128>>>(p0);        // Launch kernel on device 0\ncudaSetDevice(1);                   // Set device 1 as current\ncudaDeviceEnablePeerAccess(0, 0);   // Enable peer-to-peer access\n                                    // with device 0\n\n// Launch kernel on device 1\n// This kernel launch can access memory on device 0 at address p0\nMyKernel<<<1000, 128>>>(p0);\n\n6.2.9.4.1. IOMMU on Linux\uf0c1\n\nOn Linux only, CUDA and the display driver does not support IOMMU-enabled bare-metal PCIe peer to peer memory copy. However, CUDA and the display driver does support IOMMU via VM pass through. As a consequence, users on Linux, when running on a native bare metal system, should disable the IOMMU. The IOMMU should be enabled and the VFIO driver be used as a PCIe pass through for virtual machines.\n\nOn Windows the above limitation does not exist.\n\nSee also Allocating DMA Buffers on 64-bit Platforms.\n6.2.9.5. Peer-to-Peer Memory Copy\uf0c1\n\nMemory copies can be performed between the memories of two different devices.\n\nWhen a unified address space is used for both devices (see Unified Virtual Address Space), this is done using the regular memory copy functions mentioned in Device Memory.\n\nOtherwise, this is done using cudaMemcpyPeer(), cudaMemcpyPeerAsync(), cudaMemcpy3DPeer(), or cudaMemcpy3DPeerAsync() as illustrated in the following code sample.\n\ncudaSetDevice(0);                   // Set device 0 as current\nfloat* p0;\nsize_t size = 1024 * sizeof(float);\ncudaMalloc(&p0, size);              // Allocate memory on device 0\ncudaSetDevice(1);                   // Set device 1 as current\nfloat* p1;\ncudaMalloc(&p1, size);              // Allocate memory on device 1\ncudaSetDevice(0);                   // Set device 0 as current\nMyKernel<<<1000, 128>>>(p0);        // Launch kernel on device 0\ncudaSetDevice(1);                   // Set device 1 as current\ncudaMemcpyPeer(p1, 1, p0, 0, size); // Copy p0 to p1\nMyKernel<<<1000, 128>>>(p1);        // Launch kernel on device 1\n\nA copy (in the implicit NULL stream) between the memories of two different devices:\n\n    does not start until all commands previously issued to either device have completed and\n\n    runs to completion before any commands (see Asynchronous Concurrent Execution) issued after the copy to either device can start.\n\nConsistent with the normal behavior of streams, an asynchronous copy between the memories of two devices may overlap with copies or kernels in another stream.\n\nNote that if peer-to-peer access is enabled between two devices via cudaDeviceEnablePeerAccess() as described in Peer-to-Peer Memory Access, peer-to-peer memory copy between these two devices no longer needs to be staged through the host and is therefore faster.\n6.2.10. Unified Virtual Address Space\uf0c1\n\nWhen the application is run as a 64-bit process, a single address space is used for the host and all the devices of compute capability 2.0 and higher. All host memory allocations made via CUDA API calls and all device memory allocations on supported devices are within this virtual address range. As a consequence:\n\n    The location of any memory on the host allocated through CUDA, or on any of the devices which use the unified address space, can be determined from the value of the pointer using cudaPointerGetAttributes().\n\n    When copying to or from the memory of any device which uses the unified address space, the cudaMemcpyKind parameter of cudaMemcpy*() can be set to cudaMemcpyDefault to determine locations from the pointers. This also works for host pointers not allocated through CUDA, as long as the current device uses unified addressing.\n\n    Allocations via cudaHostAlloc() are automatically portable (see Portable Memory) across all the devices for which the unified address space is used, and pointers returned by cudaHostAlloc() can be used directly from within kernels running on these devices (i.e., there is no need to obtain a device pointer via cudaHostGetDevicePointer() as described in Mapped Memory.\n\nApplications may query if the unified address space is used for a particular device by checking that the unifiedAddressing device property (see Device Enumeration) is equal to 1.\n6.2.11. Interprocess Communication\uf0c1\n\nAny device memory pointer or event handle created by a host thread can be directly referenced by any other thread within the same process. It is not valid outside this process however, and therefore cannot be directly referenced by threads belonging to a different process.\n\nTo share device memory pointers and events across processes, an application must use the Inter Process Communication API, which is described in detail in the reference manual. The IPC API is only supported for 64-bit processes on Linux and for devices of compute capability 2.0 and higher. Note that the IPC API is not supported for cudaMallocManaged allocations.\n\nUsing this API, an application can get the IPC handle for a given device memory pointer using cudaIpcGetMemHandle(), pass it to another process using standard IPC mechanisms (for example, interprocess shared memory or files), and use cudaIpcOpenMemHandle() to retrieve a device pointer from the IPC handle that is a valid pointer within this other process. Event handles can be shared using similar entry points.\n\nNote that allocations made by cudaMalloc() may be sub-allocated from a larger block of memory for performance reasons. In such case, CUDA IPC APIs will share the entire underlying memory block which may cause other sub-allocations to be shared, which can potentially lead to information disclosure between processes. To prevent this behavior, it is recommended to only share allocations with a 2MiB aligned size.\n\nAn example of using the IPC API is where a single primary process generates a batch of input data, making the data available to multiple secondary processes without requiring regeneration or copying.\n\nApplications using CUDA IPC to communicate with each other should be compiled, linked, and run with the same CUDA driver and runtime.\n\nNote\n\nSince CUDA 11.5, only events-sharing IPC APIs are supported on L4T and embedded Linux Tegra devices with compute capability 7.x and higher. The memory-sharing IPC APIs are still not supported on Tegra platforms.\n6.2.12. Error Checking\uf0c1\n\nAll runtime functions return an error code, but for an asynchronous function (see Asynchronous Concurrent Execution), this error code cannot possibly report any of the asynchronous errors that could occur on the device since the function returns before the device has completed the task; the error code only reports errors that occur on the host prior to executing the task, typically related to parameter validation; if an asynchronous error occurs, it will be reported by some subsequent unrelated runtime function call.\n\nThe only way to check for asynchronous errors just after some asynchronous function call is therefore to synchronize just after the call by calling cudaDeviceSynchronize() (or by using any other synchronization mechanisms described in Asynchronous Concurrent Execution) and checking the error code returned by cudaDeviceSynchronize().\n\nThe runtime maintains an error variable for each host thread that is initialized to cudaSuccess and is overwritten by the error code every time an error occurs (be it a parameter validation error or an asynchronous error). cudaPeekAtLastError() returns this variable. cudaGetLastError() returns this variable and resets it to cudaSuccess.\n\nKernel launches do not return any error code, so cudaPeekAtLastError() or cudaGetLastError() must be called just after the kernel launch to retrieve any pre-launch errors. To ensure that any error returned by cudaPeekAtLastError() or cudaGetLastError() does not originate from calls prior to the kernel launch, one has to make sure that the runtime error variable is set to cudaSuccess just before the kernel launch, for example, by calling cudaGetLastError() just before the kernel launch. Kernel launches are asynchronous, so to check for asynchronous errors, the application must synchronize in-between the kernel launch and the call to cudaPeekAtLastError() or cudaGetLastError().\n\nNote that cudaErrorNotReady that may be returned by cudaStreamQuery() and cudaEventQuery() is not considered an error and is therefore not reported by cudaPeekAtLastError() or cudaGetLastError().\n6.2.13. Call Stack\uf0c1\n\nOn devices of compute capability 2.x and higher, the size of the call stack can be queried usingcudaDeviceGetLimit() and set using cudaDeviceSetLimit().\n\nWhen the call stack overflows, the kernel call fails with a stack overflow error if the application is run via a CUDA debugger (CUDA-GDB, Nsight) or an unspecified launch error, otherwise. When the compiler cannot determine the stack size, it issues a warning saying Stack size cannot be statically determined. This is usually the case with recursive functions. Once this warning is issued, user will need to set stack size manually if default stack size is not sufficient.\n6.2.14. Texture and Surface Memory\uf0c1\n\nCUDA supports a subset of the texturing hardware that the GPU uses for graphics to access texture and surface memory. Reading data from texture or surface memory instead of global memory can have several performance benefits as described in Device Memory Accesses.\n6.2.14.1. Texture Memory\uf0c1\n\nTexture memory is read from kernels using the device functions described in Texture Functions. The process of reading a texture calling one of these functions is called a texture fetch. Each texture fetch specifies a parameter called a texture object for the texture object API.\n\nThe texture object specifies:\n\n    The texture, which is the piece of texture memory that is fetched. Texture objects are created at runtime and the texture is specified when creating the texture object as described in Texture Object API.\n\n    Its dimensionality that specifies whether the texture is addressed as a one dimensional array using one texture coordinate, a two-dimensional array using two texture coordinates, or a three-dimensional array using three texture coordinates. Elements of the array are called texels, short for texture elements. The texture width, height, and depth refer to the size of the array in each dimension. Table 27 lists the maximum texture width, height, and depth depending on the compute capability of the device.\n\n    The type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in Built-in Vector Types that are derived from the basic integer and single-precision floating-point types.\n\n    The read mode, which is equal to cudaReadModeNormalizedFloat or cudaReadModeElementType. If it is cudaReadModeNormalizedFloat and the type of the texel is a 16-bit or 8-bit integer type, the value returned by the texture fetch is actually returned as floating-point type and the full range of the integer type is mapped to [0.0, 1.0] for unsigned integer type and [-1.0, 1.0] for signed integer type; for example, an unsigned 8-bit texture element with the value 0xff reads as 1. If it is cudaReadModeElementType, no conversion is performed.\n\n    Whether texture coordinates are normalized or not. By default, textures are referenced (by the functions of Texture Functions) using floating-point coordinates in the range [0, N-1] where N is the size of the texture in the dimension corresponding to the coordinate. For example, a texture that is 64x32 in size will be referenced with coordinates in the range [0, 63] and [0, 31] for the x and y dimensions, respectively. Normalized texture coordinates cause the coordinates to be specified in the range [0.0, 1.0-1/N] instead of [0, N-1], so the same 64x32 texture would be addressed by normalized coordinates in the range [0, 1-1/N] in both the x and y dimensions. Normalized texture coordinates are a natural fit to some applications\u2019 requirements, if it is preferable for the texture coordinates to be independent of the texture size.\n\n    The addressing mode. It is valid to call the device functions of Section B.8 with coordinates that are out of range. The addressing mode defines what happens in that case. The default addressing mode is to clamp the coordinates to the valid range: [0, N) for non-normalized coordinates and [0.0, 1.0) for normalized coordinates. If the border mode is specified instead, texture fetches with out-of-range texture coordinates return zero. For normalized coordinates, the wrap mode and the mirror mode are also available. When using the wrap mode, each coordinate x is converted to frac(x)=x - floor(x) where floor(x) is the largest integer not greater than x. When using the mirror mode, each coordinate x is converted to frac(x) if floor(x) is even and 1-frac(x) if floor(x) is odd. The addressing mode is specified as an array of size three whose first, second, and third elements specify the addressing mode for the first, second, and third texture coordinates, respectively; the addressing mode are cudaAddressModeBorder, cudaAddressModeClamp, cudaAddressModeWrap, and cudaAddressModeMirror; cudaAddressModeWrap and cudaAddressModeMirror are only supported for normalized texture coordinates\n\n    The filtering mode which specifies how the value returned when fetching the texture is computed based on the input texture coordinates. Linear texture filtering may be done only for textures that are configured to return floating-point data. It performs low-precision interpolation between neighboring texels. When enabled, the texels surrounding a texture fetch location are read and the return value of the texture fetch is interpolated based on where the texture coordinates fell between the texels. Simple linear interpolation is performed for one-dimensional textures, bilinear interpolation for two-dimensional textures, and trilinear interpolation for three-dimensional textures. Texture Fetching gives more details on texture fetching. The filtering mode is equal to cudaFilterModePoint or cudaFilterModeLinear. If it is cudaFilterModePoint, the returned value is the texel whose texture coordinates are the closest to the input texture coordinates. If it is cudaFilterModeLinear, the returned value is the linear interpolation of the two (for a one-dimensional texture), four (for a two dimensional texture), or eight (for a three dimensional texture) texels whose texture coordinates are the closest to the input texture coordinates. cudaFilterModeLinear is only valid for returned values of floating-point type.\n\nTexture Object API introduces the texture object API.\n\n16-Bit Floating-Point Textures explains how to deal with 16-bit floating-point textures.\n\nTextures can also be layered as described in Layered Textures.\n\nCubemap Textures and Cubemap Layered Textures describe a special type of texture, the cubemap texture.\n\nTexture Gather describes a special texture fetch, texture gather.\n6.2.14.1.1. Texture Object API\uf0c1\n\nA texture object is created using cudaCreateTextureObject() from a resource description of type struct cudaResourceDesc, which specifies the texture, and from a texture description defined as such:\n\nstruct cudaTextureDesc\n{\n    enum cudaTextureAddressMode addressMode[3];\n    enum cudaTextureFilterMode  filterMode;\n    enum cudaTextureReadMode    readMode;\n    int                         sRGB;\n    int                         normalizedCoords;\n    unsigned int                maxAnisotropy;\n    enum cudaTextureFilterMode  mipmapFilterMode;\n    float                       mipmapLevelBias;\n    float                       minMipmapLevelClamp;\n    float                       maxMipmapLevelClamp;\n};\n\n    addressMode specifies the addressing mode;\n\n    filterMode specifies the filter mode;\n\n    readMode specifies the read mode;\n\n    normalizedCoords specifies whether texture coordinates are normalized or not;\n\n    See reference manual for sRGB, maxAnisotropy, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, and maxMipmapLevelClamp.\n\nThe following code sample applies some simple transformation kernel to a texture.\n\n// Simple transformation kernel\n__global__ void transformKernel(float* output,\n                                cudaTextureObject_t texObj,\n                                int width, int height,\n                                float theta)\n{\n    // Calculate normalized texture coordinates\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    float u = x / (float)width;\n    float v = y / (float)height;\n\n    // Transform coordinates\n    u -= 0.5f;\n    v -= 0.5f;\n    float tu = u * cosf(theta) - v * sinf(theta) + 0.5f;\n    float tv = v * cosf(theta) + u * sinf(theta) + 0.5f;\n\n    // Read from texture and write to global memory\n    output[y * width + x] = tex2D<float>(texObj, tu, tv);\n}\n\n// Host code\nint main()\n{\n    const int height = 1024;\n    const int width = 1024;\n    float angle = 0.5;\n\n    // Allocate and set some host data\n    float *h_data = (float *)std::malloc(sizeof(float) * width * height);\n    for (int i = 0; i < height * width; ++i)\n        h_data[i] = i;\n\n    // Allocate CUDA array in device memory\n    cudaChannelFormatDesc channelDesc =\n        cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat);\n    cudaArray_t cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n\n    // Set pitch of the source (the width in memory in bytes of the 2D array pointed\n    // to by src, including padding), we dont have any padding\n    const size_t spitch = width * sizeof(float);\n    // Copy data located at address h_data in host memory to device memory\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_data, spitch, width * sizeof(float),\n                        height, cudaMemcpyHostToDevice);\n\n    // Specify texture\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    // Specify texture object parameters\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeWrap;\n    texDesc.addressMode[1] = cudaAddressModeWrap;\n    texDesc.filterMode = cudaFilterModeLinear;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 1;\n\n    // Create texture object\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Allocate result of transformation in device memory\n    float *output;\n    cudaMalloc(&output, width * height * sizeof(float));\n\n    // Invoke kernel\n    dim3 threadsperBlock(16, 16);\n    dim3 numBlocks((width + threadsperBlock.x - 1) / threadsperBlock.x,\n                    (height + threadsperBlock.y - 1) / threadsperBlock.y);\n    transformKernel<<<numBlocks, threadsperBlock>>>(output, texObj, width, height,\n                                                    angle);\n    // Copy data from device back to host\n    cudaMemcpy(h_data, output, width * height * sizeof(float),\n                cudaMemcpyDeviceToHost);\n\n    // Destroy texture object\n    cudaDestroyTextureObject(texObj);\n\n    // Free device memory\n    cudaFreeArray(cuArray);\n    cudaFree(output);\n\n    // Free host memory\n    free(h_data);\n\n    return 0;\n}\n\n6.2.14.1.2. 16-Bit Floating-Point Textures\uf0c1\n\nThe 16-bit floating-point or half format supported by CUDA arrays is the same as the IEEE 754-2008 binary2 format.\n\nCUDA C++ does not support a matching data type, but provides intrinsic functions to convert to and from the 32-bit floating-point format via the unsigned short type: __float2half_rn(float) and __half2float(unsigned short). These functions are only supported in device code. Equivalent functions for the host code can be found in the OpenEXR library, for example.\n\n16-bit floating-point components are promoted to 32 bit float during texture fetching before any filtering is performed.\n\nA channel description for the 16-bit floating-point format can be created by calling one of the cudaCreateChannelDescHalf*() functions.\n6.2.14.1.3. Layered Textures\uf0c1\n\nA one-dimensional or two-dimensional layered texture (also known as texture array in Direct3D and array texture in OpenGL) is a texture made up of a sequence of layers, all of which are regular textures of same dimensionality, size, and data type.\n\nA one-dimensional layered texture is addressed using an integer index and a floating-point texture coordinate; the index denotes a layer within the sequence and the coordinate addresses a texel within that layer. A two-dimensional layered texture is addressed using an integer index and two floating-point texture coordinates; the index denotes a layer within the sequence and the coordinates address a texel within that layer.\n\nA layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered flag (and a height of zero for one-dimensional layered texture).\n\nLayered textures are fetched using the device functions described in tex1DLayered() and tex2DLayered(). Texture filtering (see Texture Fetching) is done only within a layer, not across layers.\n\nLayered textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.4. Cubemap Textures\uf0c1\n\nA cubemap texture is a special type of two-dimensional layered texture that has six layers representing the faces of a cube:\n\n    The width of a layer is equal to its height.\n\n    The cubemap is addressed using three texture coordinates x, y, and z that are interpreted as a direction vector emanating from the center of the cube and pointing to one face of the cube and a texel within the layer corresponding to that face. More specifically, the face is selected by the coordinate with largest magnitude m and the corresponding layer is addressed using coordinates (s/m+1)/2 and (t/m+1)/2 where s and t are defined in Table 6.\n\nTable 6 Cubemap Fetch\uf0c1 \t\n\nface\n\t\n\nm\n\t\n\ns\n\t\n\nt\n\n|x| > |y| and |x| > |z|\n\t\n\nx \u2265 0\n\t\n\n0\n\t\n\nx\n\t\n\n-z\n\t\n\n-y\n\nx < 0\n\t\n\n1\n\t\n\n-x\n\t\n\nz\n\t\n\n-y\n\n|y| > |x| and |y| > |z|\n\t\n\ny \u2265 0\n\t\n\n2\n\t\n\ny\n\t\n\nx\n\t\n\nz\n\ny < 0\n\t\n\n3\n\t\n\n-y\n\t\n\nx\n\t\n\n-z\n\n|z| > |x| and |z| > |y|\n\t\n\nz \u2265 0\n\t\n\n4\n\t\n\nz\n\t\n\nx\n\t\n\n-y\n\nz < 0\n\t\n\n5\n\t\n\n-z\n\t\n\n-x\n\t\n\n-y\n\nA cubemap texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayCubemap flag.\n\nCubemap textures are fetched using the device function described in texCubemap().\n\nCubemap textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.5. Cubemap Layered Textures\uf0c1\n\nA cubemap layered texture is a layered texture whose layers are cubemaps of same dimension.\n\nA cubemap layered texture is addressed using an integer index and three floating-point texture coordinates; the index denotes a cubemap within the sequence and the coordinates address a texel within that cubemap.\n\nA cubemap layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered and cudaArrayCubemap flags.\n\nCubemap layered textures are fetched using the device function described in texCubemapLayered(). Texture filtering (see Texture Fetching) is done only within a layer, not across layers.\n\nCubemap layered textures are only supported on devices of compute capability 2.0 and higher.\n6.2.14.1.6. Texture Gather\uf0c1\n\nTexture gather is a special texture fetch that is available for two-dimensional textures only. It is performed by the tex2Dgather() function, which has the same parameters as tex2D(), plus an additional comp parameter equal to 0, 1, 2, or 3 (see tex2Dgather()). It returns four 32-bit numbers that correspond to the value of the component comp of each of the four texels that would have been used for bilinear filtering during a regular texture fetch. For example, if these texels are of values (253, 20, 31, 255), (250, 25, 29, 254), (249, 16, 37, 253), (251, 22, 30, 250), and comp is 2, tex2Dgather() returns (31, 29, 37, 30).\n\nNote that texture coordinates are computed with only 8 bits of fractional precision. tex2Dgather() may therefore return unexpected results for cases where tex2D() would use 1.0 for one of its weights (\u03b1 or \u03b2, see Linear Filtering). For example, with an x texture coordinate of 2.49805: xB=x-0.5=1.99805, however the fractional part of xB is stored in an 8-bit fixed-point format. Since 0.99805 is closer to 256.f/256.f than it is to 255.f/256.f, xB has the value 2. A tex2Dgather() in this case would therefore return indices 2 and 3 in x, instead of indices 1 and 2.\n\nTexture gather is only supported for CUDA arrays created with the cudaArrayTextureGather flag and of width and height less than the maximum specified in Table 27 for texture gather, which is smaller than for regular texture fetch.\n\nTexture gather is only supported on devices of compute capability 2.0 and higher.\n6.2.14.2. Surface Memory\uf0c1\n\nFor devices of compute capability 2.0 and higher, a CUDA array (described in Cubemap Surfaces), created with the cudaArraySurfaceLoadStore flag, can be read and written via a surface object using the functions described in Surface Functions.\n\nTable 27 lists the maximum surface width, height, and depth depending on the compute capability of the device.\n6.2.14.2.1. Surface Object API\uf0c1\n\nA surface object is created using cudaCreateSurfaceObject() from a resource description of type struct cudaResourceDesc. Unlike texture memory, surface memory uses byte addressing. This means that the x-coordinate used to access a texture element via texture functions needs to be multiplied by the byte size of the element to access the same element via a surface function. For example, the element at texture coordinate x of a one-dimensional floating-point CUDA array bound to a texture object texObj and a surface object surfObj is read using tex1d(texObj, x) via texObj, but surf1Dread(surfObj, 4*x) via surfObj. Similarly, the element at texture coordinate x and y of a two-dimensional floating-point CUDA array bound to a texture object texObj and a surface object surfObj is accessed using tex2d(texObj, x, y) via texObj, but surf2Dread(surfObj, 4*x, y) via surObj (the byte offset of the y-coordinate is internally calculated from the underlying line pitch of the CUDA array).\n\nThe following code sample applies some simple transformation kernel to a surface.\n\n// Simple copy kernel\n__global__ void copyKernel(cudaSurfaceObject_t inputSurfObj,\n                           cudaSurfaceObject_t outputSurfObj,\n                           int width, int height)\n{\n    // Calculate surface coordinates\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n    if (x < width && y < height) {\n        uchar4 data;\n        // Read from input surface\n        surf2Dread(&data,  inputSurfObj, x * 4, y);\n        // Write to output surface\n        surf2Dwrite(data, outputSurfObj, x * 4, y);\n    }\n}\n\n// Host code\nint main()\n{\n    const int height = 1024;\n    const int width = 1024;\n\n    // Allocate and set some host data\n    unsigned char *h_data =\n        (unsigned char *)std::malloc(sizeof(unsigned char) * width * height * 4);\n    for (int i = 0; i < height * width * 4; ++i)\n        h_data[i] = i;\n\n    // Allocate CUDA arrays in device memory\n    cudaChannelFormatDesc channelDesc =\n        cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsigned);\n    cudaArray_t cuInputArray;\n    cudaMallocArray(&cuInputArray, &channelDesc, width, height,\n                    cudaArraySurfaceLoadStore);\n    cudaArray_t cuOutputArray;\n    cudaMallocArray(&cuOutputArray, &channelDesc, width, height,\n                    cudaArraySurfaceLoadStore);\n\n    // Set pitch of the source (the width in memory in bytes of the 2D array\n    // pointed to by src, including padding), we dont have any padding\n    const size_t spitch = 4 * width * sizeof(unsigned char);\n    // Copy data located at address h_data in host memory to device memory\n    cudaMemcpy2DToArray(cuInputArray, 0, 0, h_data, spitch,\n                        4 * width * sizeof(unsigned char), height,\n                        cudaMemcpyHostToDevice);\n\n    // Specify surface\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n\n    // Create the surface objects\n    resDesc.res.array.array = cuInputArray;\n    cudaSurfaceObject_t inputSurfObj = 0;\n    cudaCreateSurfaceObject(&inputSurfObj, &resDesc);\n    resDesc.res.array.array = cuOutputArray;\n    cudaSurfaceObject_t outputSurfObj = 0;\n    cudaCreateSurfaceObject(&outputSurfObj, &resDesc);\n\n    // Invoke kernel\n    dim3 threadsperBlock(16, 16);\n    dim3 numBlocks((width + threadsperBlock.x - 1) / threadsperBlock.x,\n                    (height + threadsperBlock.y - 1) / threadsperBlock.y);\n    copyKernel<<<numBlocks, threadsperBlock>>>(inputSurfObj, outputSurfObj, width,\n                                                height);\n\n    // Copy data from device back to host\n    cudaMemcpy2DFromArray(h_data, spitch, cuOutputArray, 0, 0,\n                            4 * width * sizeof(unsigned char), height,\n                            cudaMemcpyDeviceToHost);\n\n    // Destroy surface objects\n    cudaDestroySurfaceObject(inputSurfObj);\n    cudaDestroySurfaceObject(outputSurfObj);\n\n    // Free device memory\n    cudaFreeArray(cuInputArray);\n    cudaFreeArray(cuOutputArray);\n\n    // Free host memory\n    free(h_data);\n\n  return 0;\n}\n\n6.2.14.2.2. Cubemap Surfaces\uf0c1\n\nCubemap surfaces are accessed usingsurfCubemapread() and surfCubemapwrite() (surfCubemapread() and surfCubemapwrite()) as a two-dimensional layered surface, i.e., using an integer index denoting a face and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in Table 6.\n6.2.14.2.3. Cubemap Layered Surfaces\uf0c1\n\nCubemap layered surfaces are accessed using surfCubemapLayeredread() and surfCubemapLayeredwrite() (surfCubemapLayeredread() and surfCubemapLayeredwrite()) as a two-dimensional layered surface, i.e., using an integer index denoting a face of one of the cubemaps and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in Table 6, so index ((2 * 6) + 3), for example, accesses the fourth face of the third cubemap.\n6.2.14.3. CUDA Arrays\uf0c1\n\nCUDA arrays are opaque memory layouts optimized for texture fetching. They are one dimensional, two dimensional, or three-dimensional and composed of elements, each of which has 1, 2 or 4 components that may be signed or unsigned 8-, 16-, or 32-bit integers, 16-bit floats, or 32-bit floats. CUDA arrays are only accessible by kernels through texture fetching as described in Texture Memory or surface reading and writing as described in Surface Memory.\n6.2.14.4. Read/Write Coherency\uf0c1\n\nThe texture and surface memory is cached (see Device Memory Accesses) and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global write or a surface write in the same kernel call returns undefined data. In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call.\n6.2.15. Graphics Interoperability\uf0c1\n\nSome resources from OpenGL and Direct3D may be mapped into the address space of CUDA, either to enable CUDA to read data written by OpenGL or Direct3D, or to enable CUDA to write data for consumption by OpenGL or Direct3D.\n\nA resource must be registered to CUDA before it can be mapped using the functions mentioned in OpenGL Interoperability and Direct3D Interoperability. These functions return a pointer to a CUDA graphics resource of type struct cudaGraphicsResource. Registering a resource is potentially high-overhead and therefore typically called only once per resource. A CUDA graphics resource is unregistered using cudaGraphicsUnregisterResource(). Each CUDA context which intends to use the resource is required to register it separately.\n\nOnce a resource is registered to CUDA, it can be mapped and unmapped as many times as necessary using cudaGraphicsMapResources() and cudaGraphicsUnmapResources(). cudaGraphicsResourceSetMapFlags() can be called to specify usage hints (write-only, read-only) that the CUDA driver can use to optimize resource management.\n\nA mapped resource can be read from or written to by kernels using the device memory address returned by cudaGraphicsResourceGetMappedPointer() for buffers andcudaGraphicsSubResourceGetMappedArray() for CUDA arrays.\n\nAccessing a resource through OpenGL, Direct3D, or another CUDA context while it is mapped produces undefined results. OpenGL Interoperability and Direct3D Interoperability give specifics for each graphics API and some code samples. SLI Interoperability gives specifics for when the system is in SLI mode.\n6.2.15.1. OpenGL Interoperability\uf0c1\n\nThe OpenGL resources that may be mapped into the address space of CUDA are OpenGL buffer, texture, and renderbuffer objects.\n\nA buffer object is registered using cudaGraphicsGLRegisterBuffer(). In CUDA, it appears as a device pointer and can therefore be read and written by kernels or via cudaMemcpy() calls.\n\nA texture or renderbuffer object is registered using cudaGraphicsGLRegisterImage(). In CUDA, it appears as a CUDA array. Kernels can read from the array by binding it to a texture or surface reference. They can also write to it via the surface write functions if the resource has been registered with the cudaGraphicsRegisterFlagsSurfaceLoadStore flag. The array can also be read and written via cudaMemcpy2D() calls. cudaGraphicsGLRegisterImage() supports all texture formats with 1, 2, or 4 components and an internal type of float (for example, GL_RGBA_FLOAT32), normalized integer (for example, GL_RGBA8, GL_INTENSITY16), and unnormalized integer (for example, GL_RGBA8UI) (please note that since unnormalized integer formats require OpenGL 3.0, they can only be written by shaders, not the fixed function pipeline).\n\nThe OpenGL context whose resources are being shared has to be current to the host thread making any OpenGL interoperability API calls.\n\nPlease note: When an OpenGL texture is made bindless (say for example by requesting an image or texture handle using the glGetTextureHandle*/glGetImageHandle* APIs) it cannot be registered with CUDA. The application needs to register the texture for interop before requesting an image or texture handle.\n\nThe following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object:\n\nGLuint positionsVBO;\nstruct cudaGraphicsResource* positionsVBO_CUDA;\n\nint main()\n{\n    // Initialize OpenGL and GLUT for device 0\n    // and make the OpenGL context current\n    ...\n    glutDisplayFunc(display);\n\n    // Explicitly set device 0\n    cudaSetDevice(0);\n\n    // Create buffer object and register it with CUDA\n    glGenBuffers(1, &positionsVBO);\n    glBindBuffer(GL_ARRAY_BUFFER, positionsVBO);\n    unsigned int size = width * height * 4 * sizeof(float);\n    glBufferData(GL_ARRAY_BUFFER, size, 0, GL_DYNAMIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    cudaGraphicsGLRegisterBuffer(&positionsVBO_CUDA,\n                                 positionsVBO,\n                                 cudaGraphicsMapFlagsWriteDiscard);\n\n    // Launch rendering loop\n    glutMainLoop();\n\n    ...\n}\n\nvoid display()\n{\n    // Map buffer object for writing from CUDA\n    float4* positions;\n    cudaGraphicsMapResources(1, &positionsVBO_CUDA, 0);\n    size_t num_bytes;\n    cudaGraphicsResourceGetMappedPointer((void**)&positions,\n                                         &num_bytes,\n                                         positionsVBO_CUDA));\n\n    // Execute kernel\n    dim3 dimBlock(16, 16, 1);\n    dim3 dimGrid(width / dimBlock.x, height / dimBlock.y, 1);\n    createVertices<<<dimGrid, dimBlock>>>(positions, time,\n                                          width, height);\n\n    // Unmap buffer object\n    cudaGraphicsUnmapResources(1, &positionsVBO_CUDA, 0);\n\n    // Render from buffer object\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glBindBuffer(GL_ARRAY_BUFFER, positionsVBO);\n    glVertexPointer(4, GL_FLOAT, 0, 0);\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glDrawArrays(GL_POINTS, 0, width * height);\n    glDisableClientState(GL_VERTEX_ARRAY);\n\n    // Swap buffers\n    glutSwapBuffers();\n    glutPostRedisplay();\n}\n\nvoid deleteVBO()\n{\n    cudaGraphicsUnregisterResource(positionsVBO_CUDA);\n    glDeleteBuffers(1, &positionsVBO);\n}\n\n__global__ void createVertices(float4* positions, float time,\n                               unsigned int width, unsigned int height)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    // Calculate uv coordinates\n    float u = x / (float)width;\n    float v = y / (float)height;\n    u = u * 2.0f - 1.0f;\n    v = v * 2.0f - 1.0f;\n\n    // calculate simple sine wave pattern\n    float freq = 4.0f;\n    float w = sinf(u * freq + time)\n            * cosf(v * freq + time) * 0.5f;\n\n    // Write positions\n    positions[y * width + x] = make_float4(u, w, v, 1.0f);\n}\n\nOn Windows and for Quadro GPUs, cudaWGLGetDevice() can be used to retrieve the CUDA device associated to the handle returned by wglEnumGpusNV(). Quadro GPUs offer higher performance OpenGL interoperability than GeForce and Tesla GPUs in a multi-GPU configuration where OpenGL rendering is performed on the Quadro GPU and CUDA computations are performed on other GPUs in the system.\n6.2.15.2. Direct3D Interoperability\uf0c1\n\nDirect3D interoperability is supported for Direct3D 9Ex, Direct3D 10, and Direct3D 11.\n\nA CUDA context may interoperate only with Direct3D devices that fulfill the following criteria: Direct3D 9Ex devices must be created with DeviceType set to D3DDEVTYPE_HAL and BehaviorFlags with the D3DCREATE_HARDWARE_VERTEXPROCESSING flag; Direct3D 10 and Direct3D 11 devices must be created with DriverType set to D3D_DRIVER_TYPE_HARDWARE.\n\nThe Direct3D resources that may be mapped into the address space of CUDA are Direct3D buffers, textures, and surfaces. These resources are registered using cudaGraphicsD3D9RegisterResource(), cudaGraphicsD3D10RegisterResource(), and cudaGraphicsD3D11RegisterResource().\n\nThe following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object.\n6.2.15.2.1. Direct3D 9 Version\uf0c1\n\nIDirect3D9* D3D;\nIDirect3DDevice9* device;\nstruct CUSTOMVERTEX {\n    FLOAT x, y, z;\n    DWORD color;\n};\nIDirect3DVertexBuffer9* positionsVB;\nstruct cudaGraphicsResource* positionsVB_CUDA;\n\nint main()\n{\n    int dev;\n    // Initialize Direct3D\n    D3D = Direct3DCreate9Ex(D3D_SDK_VERSION);\n\n    // Get a CUDA-enabled adapter\n    unsigned int adapter = 0;\n    for (; adapter < g_pD3D->GetAdapterCount(); adapter++) {\n        D3DADAPTER_IDENTIFIER9 adapterId;\n        g_pD3D->GetAdapterIdentifier(adapter, 0, &adapterId);\n        if (cudaD3D9GetDevice(&dev, adapterId.DeviceName)\n            == cudaSuccess)\n            break;\n    }\n\n     // Create device\n    ...\n    D3D->CreateDeviceEx(adapter, D3DDEVTYPE_HAL, hWnd,\n                        D3DCREATE_HARDWARE_VERTEXPROCESSING,\n                        &params, NULL, &device);\n\n    // Use the same device\n    cudaSetDevice(dev);\n\n    // Create vertex buffer and register it with CUDA\n    unsigned int size = width * height * sizeof(CUSTOMVERTEX);\n    device->CreateVertexBuffer(size, 0, D3DFVF_CUSTOMVERTEX,\n                               D3DPOOL_DEFAULT, &positionsVB, 0);\n    cudaGraphicsD3D9RegisterResource(&positionsVB_CUDA,\n                                     positionsVB,\n                                     cudaGraphicsRegisterFlagsNone);\n    cudaGraphicsResourceSetMapFlags(positionsVB_CUDA,\n                                    cudaGraphicsMapFlagsWriteDiscard);\n\n    // Launch rendering loop\n    while (...) {\n        ...\n        Render();\n        ...\n    }\n    ...\n}\n\nvoid Render()\n{\n    // Map vertex buffer for writing from CUDA\n    float4* positions;\n    cudaGraphicsMapResources(1, &positionsVB_CUDA, 0);\n    size_t num_bytes;\n    cudaGraphicsResourceGetMappedPointer((void**)&positions,\n                                         &num_bytes,\n                                         positionsVB_CUDA));\n\n    // Execute kernel\n    dim3 dimBlock(16, 16, 1);\n    dim3 dimGrid(width / dimBlock.x, height / dimBlock.y, 1);\n    createVertices<<<dimGrid, dimBlock>>>(positions, time,\n                                          width, height);\n\n    // Unmap vertex buffer\n    cudaGraphicsUnmapResources(1, &positionsVB_CUDA, 0);\n\n    // Draw and present\n    ...\n}\n\nvoid releaseVB()\n{\n    cudaGraphicsUnregisterResource(positionsVB_CUDA);\n    positionsVB->Release();\n}\n\n__global__ void createVertices(float4* positions, float time,\n                               unsigned int width, unsigned int height)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    // Calculate uv coordinates\n    float u = x / (float)width;\n    float v = y / (float)height;\n    u = u * 2.0f - 1.0f;\n    v = v * 2.0f - 1.0f;\n\n    // Calculate simple sine wave pattern\n    float freq = 4.0f;\n    float w = sinf(u * freq + time)\n            * cosf(v * freq + time) * 0.5f;\n\n    // Write positions\n    positions[y * width + x] =\n                make_float4(u, w, v, __int_as_float(0xff00ff00));\n}\n\n6.2.15.2.2. Direct3D 10 Version\uf0c1\n\nID3D10Device* device;\nstruct CUSTOMVERTEX {\n    FLOAT x, y, z;\n    DWORD color;\n};\nID3D10Buffer* positionsVB;\nstruct cudaGraphicsResource* positionsVB_CUDA;\n\nint main()\n{\n    int dev;\n    // Get a CUDA-enabled adapter\n    IDXGIFactory* factory;\n    CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);\n    IDXGIAdapter* adapter = 0;\n    for (unsigned int i = 0; !adapter; ++i) {\n        if (FAILED(factory->EnumAdapters(i, &adapter))\n            break;\n        if (cudaD3D10GetDevice(&dev, adapter) == cudaSuccess)\n            break;\n        adapter->Release();\n    }\n    factory->Release();\n\n    // Create swap chain and device\n    ...\n    D3D10CreateDeviceAndSwapChain(adapter,\n                                  D3D10_DRIVER_TYPE_HARDWARE, 0,\n                                  D3D10_CREATE_DEVICE_DEBUG,\n                                  D3D10_SDK_VERSION,\n                                  &swapChainDesc, &swapChain,\n                                  &device);\n    adapter->Release();\n\n    // Use the same device\n    cudaSetDevice(dev);\n\n    // Create vertex buffer and register it with CUDA\n    unsigned int size = width * height * sizeof(CUSTOMVERTEX);\n    D3D10_BUFFER_DESC bufferDesc;\n    bufferDesc.Usage          = D3D10_USAGE_DEFAULT;\n    bufferDesc.ByteWidth      = size;\n    bufferDesc.BindFlags      = D3D10_BIND_VERTEX_BUFFER;\n    bufferDesc.CPUAccessFlags = 0;\n    bufferDesc.MiscFlags      = 0;\n    device->CreateBuffer(&bufferDesc, 0, &positionsVB);\n    cudaGraphicsD3D10RegisterResource(&positionsVB_CUDA,\n                                      positionsVB,\n                                      cudaGraphicsRegisterFlagsNone);\n                                      cudaGraphicsResourceSetMapFlags(positionsVB_CUDA,\n                                      cudaGraphicsMapFlagsWriteDiscard);\n\n    // Launch rendering loop\n    while (...) {\n        ...\n        Render();\n        ...\n    }\n    ...\n}\n\nvoid Render()\n{\n    // Map vertex buffer for writing from CUDA\n    float4* positions;\n    cudaGraphicsMapResources(1, &positionsVB_CUDA, 0);\n    size_t num_bytes;\n    cudaGraphicsResourceGetMappedPointer((void**)&positions,\n                                         &num_bytes,\n                                         positionsVB_CUDA));\n\n    // Execute kernel\n    dim3 dimBlock(16, 16, 1);\n    dim3 dimGrid(width / dimBlock.x, height / dimBlock.y, 1);\n    createVertices<<<dimGrid, dimBlock>>>(positions, time,\n                                          width, height);\n\n    // Unmap vertex buffer\n    cudaGraphicsUnmapResources(1, &positionsVB_CUDA, 0);\n\n    // Draw and present\n    ...\n}\n\nvoid releaseVB()\n{\n    cudaGraphicsUnregisterResource(positionsVB_CUDA);\n    positionsVB->Release();\n}\n\n__global__ void createVertices(float4* positions, float time,\n                               unsigned int width, unsigned int height)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    // Calculate uv coordinates\n    float u = x / (float)width;\n    float v = y / (float)height;\n    u = u * 2.0f - 1.0f;\n    v = v * 2.0f - 1.0f;\n\n    // Calculate simple sine wave pattern\n    float freq = 4.0f;\n    float w = sinf(u * freq + time)\n            * cosf(v * freq + time) * 0.5f;\n\n    // Write positions\n    positions[y * width + x] =\n                make_float4(u, w, v, __int_as_float(0xff00ff00));\n}\n\n6.2.15.2.3. Direct3D 11 Version\uf0c1\n\nID3D11Device* device;\nstruct CUSTOMVERTEX {\n    FLOAT x, y, z;\n    DWORD color;\n};\nID3D11Buffer* positionsVB;\nstruct cudaGraphicsResource* positionsVB_CUDA;\n\nint main()\n{\n    int dev;\n    // Get a CUDA-enabled adapter\n    IDXGIFactory* factory;\n    CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);\n    IDXGIAdapter* adapter = 0;\n    for (unsigned int i = 0; !adapter; ++i) {\n        if (FAILED(factory->EnumAdapters(i, &adapter))\n            break;\n        if (cudaD3D11GetDevice(&dev, adapter) == cudaSuccess)\n            break;\n        adapter->Release();\n    }\n    factory->Release();\n\n    // Create swap chain and device\n    ...\n    sFnPtr_D3D11CreateDeviceAndSwapChain(adapter,\n                                         D3D11_DRIVER_TYPE_HARDWARE,\n                                         0,\n                                         D3D11_CREATE_DEVICE_DEBUG,\n                                         featureLevels, 3,\n                                         D3D11_SDK_VERSION,\n                                         &swapChainDesc, &swapChain,\n                                         &device,\n                                         &featureLevel,\n                                         &deviceContext);\n    adapter->Release();\n\n    // Use the same device\n    cudaSetDevice(dev);\n\n    // Create vertex buffer and register it with CUDA\n    unsigned int size = width * height * sizeof(CUSTOMVERTEX);\n    D3D11_BUFFER_DESC bufferDesc;\n    bufferDesc.Usage          = D3D11_USAGE_DEFAULT;\n    bufferDesc.ByteWidth      = size;\n    bufferDesc.BindFlags      = D3D11_BIND_VERTEX_BUFFER;\n    bufferDesc.CPUAccessFlags = 0;\n    bufferDesc.MiscFlags      = 0;\n    device->CreateBuffer(&bufferDesc, 0, &positionsVB);\n    cudaGraphicsD3D11RegisterResource(&positionsVB_CUDA,\n                                      positionsVB,\n                                      cudaGraphicsRegisterFlagsNone);\n    cudaGraphicsResourceSetMapFlags(positionsVB_CUDA,\n                                    cudaGraphicsMapFlagsWriteDiscard);\n\n    // Launch rendering loop\n    while (...) {\n        ...\n        Render();\n        ...\n    }\n    ...\n}\n\nvoid Render()\n{\n    // Map vertex buffer for writing from CUDA\n    float4* positions;\n    cudaGraphicsMapResources(1, &positionsVB_CUDA, 0);\n    size_t num_bytes;\n    cudaGraphicsResourceGetMappedPointer((void**)&positions,\n                                         &num_bytes,\n                                         positionsVB_CUDA));\n\n    // Execute kernel\n    dim3 dimBlock(16, 16, 1);\n    dim3 dimGrid(width / dimBlock.x, height / dimBlock.y, 1);\n    createVertices<<<dimGrid, dimBlock>>>(positions, time,\n                                          width, height);\n\n    // Unmap vertex buffer\n    cudaGraphicsUnmapResources(1, &positionsVB_CUDA, 0);\n\n    // Draw and present\n    ...\n}\n\nvoid releaseVB()\n{\n    cudaGraphicsUnregisterResource(positionsVB_CUDA);\n    positionsVB->Release();\n}\n\n    __global__ void createVertices(float4* positions, float time,\n                          unsigned int width, unsigned int height)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n// Calculate uv coordinates\n    float u = x / (float)width;\n    float v = y / (float)height;\n    u = u * 2.0f - 1.0f;\n    v = v * 2.0f - 1.0f;\n\n    // Calculate simple sine wave pattern\n    float freq = 4.0f;\n    float w = sinf(u * freq + time)\n            * cosf(v * freq + time) * 0.5f;\n\n    // Write positions\n    positions[y * width + x] =\n                make_float4(u, w, v, __int_as_float(0xff00ff00));\n}\n\n6.2.15.3. SLI Interoperability\uf0c1\n\nIn a system with multiple GPUs, all CUDA-enabled GPUs are accessible via the CUDA driver and runtime as separate devices. There are however special considerations as described below when the system is in SLI mode.\n\nFirst, an allocation in one CUDA device on one GPU will consume memory on other GPUs that are part of the SLI configuration of the Direct3D or OpenGL device. Because of this, allocations may fail earlier than otherwise expected.\n\nSecond, applications should create multiple CUDA contexts, one for each GPU in the SLI configuration. While this is not a strict requirement, it avoids unnecessary data transfers between devices. The application can use the cudaD3D[9|10|11]GetDevices() for Direct3D and cudaGLGetDevices() for OpenGL set of calls to identify the CUDA device handle(s) for the device(s) that are performing the rendering in the current and next frame. Given this information the application will typically choose the appropriate device and map Direct3D or OpenGL resources to the CUDA device returned by cudaD3D[9|10|11]GetDevices() or cudaGLGetDevices() when the deviceList parameter is set to cudaD3D[9|10|11]DeviceListCurrentFrame or cudaGLDeviceListCurrentFrame.\n\nPlease note that resource returned from cudaGraphicsD9D[9|10|11]RegisterResource and cudaGraphicsGLRegister[Buffer|Image] must be only used on device the registration happened. Therefore on SLI configurations when data for different frames is computed on different CUDA devices it is necessary to register the resources for each separately.\n\nSee Direct3D Interoperability and OpenGL Interoperability for details on how the CUDA runtime interoperate with Direct3D and OpenGL, respectively.\n6.2.16. External Resource Interoperability\uf0c1\n\nExternal resource interoperability allows CUDA to import certain resources that are explicitly exported by other APIs. These objects are typically exported by other APIs using handles native to the Operating System, like file descriptors on Linux or NT handles on Windows. They could also be exported using other unified interfaces such as the NVIDIA Software Communication Interface. There are two types of resources that can be imported: memory objects and synchronization objects.\n\nMemory objects can be imported into CUDA using cudaImportExternalMemory(). An imported memory object can be accessed from within kernels using device pointers mapped onto the memory object via cudaExternalMemoryGetMappedBuffer()or CUDA mipmapped arrays mapped via cudaExternalMemoryGetMappedMipmappedArray(). Depending on the type of memory object, it may be possible for more than one mapping to be setup on a single memory object. The mappings must match the mappings setup in the exporting API. Any mismatched mappings result in undefined behavior. Imported memory objects must be freed using cudaDestroyExternalMemory(). Freeing a memory object does not free any mappings to that object. Therefore, any device pointers mapped onto that object must be explicitly freed using cudaFree() and any CUDA mipmapped arrays mapped onto that object must be explicitly freed using cudaFreeMipmappedArray(). It is illegal to access mappings to an object after it has been destroyed.\n\nSynchronization objects can be imported into CUDA using cudaImportExternalSemaphore(). An imported synchronization object can then be signaled using cudaSignalExternalSemaphoresAsync() and waited on using cudaWaitExternalSemaphoresAsync(). It is illegal to issue a wait before the corresponding signal has been issued. Also, depending on the type of the imported synchronization object, there may be additional constraints imposed on how they can be signaled and waited on, as described in subsequent sections. Imported semaphore objects must be freed using cudaDestroyExternalSemaphore(). All outstanding signals and waits must have completed before the semaphore object is destroyed.\n6.2.16.1. Vulkan Interoperability\uf0c1\n6.2.16.1.1. Matching device UUIDs\uf0c1\n\nWhen importing memory and synchronization objects exported by Vulkan, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Vulkan physical device on which the objects were created can be determined by comparing the UUID of a CUDA device with that of the Vulkan physical device, as shown in the following code sample. Note that the Vulkan physical device should not be part of a device group that contains more than one Vulkan physical device. The device group as returned by vkEnumeratePhysicalDeviceGroups that contains the given Vulkan physical device must have a physical device count of 1.\n\nint getCudaDeviceForVulkanPhysicalDevice(VkPhysicalDevice vkPhysicalDevice) {\n    VkPhysicalDeviceIDProperties vkPhysicalDeviceIDProperties = {};\n    vkPhysicalDeviceIDProperties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;\n    vkPhysicalDeviceIDProperties.pNext = NULL;\n\n    VkPhysicalDeviceProperties2 vkPhysicalDeviceProperties2 = {};\n    vkPhysicalDeviceProperties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;\n    vkPhysicalDeviceProperties2.pNext = &vkPhysicalDeviceIDProperties;\n\n    vkGetPhysicalDeviceProperties2(vkPhysicalDevice, &vkPhysicalDeviceProperties2);\n\n    int cudaDeviceCount;\n    cudaGetDeviceCount(&cudaDeviceCount);\n\n    for (int cudaDevice = 0; cudaDevice < cudaDeviceCount; cudaDevice++) {\n        cudaDeviceProp deviceProp;\n        cudaGetDeviceProperties(&deviceProp, cudaDevice);\n        if (!memcmp(&deviceProp.uuid, vkPhysicalDeviceIDProperties.deviceUUID, VK_UUID_SIZE)) {\n            return cudaDevice;\n        }\n    }\n    return cudaInvalidDeviceId;\n}\n\n6.2.16.1.2. Importing Memory Objects\uf0c1\n\nOn Linux and Windows 10, both dedicated and non-dedicated memory objects exported by Vulkan can be imported into CUDA. On Windows 7, only dedicated memory objects can be imported. When importing a Vulkan dedicated memory object, the flag cudaExternalMemoryDedicated must be set.\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT can be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.\n\ncudaExternalMemory_t importVulkanMemoryObjectFromFileDescriptor(int fd, unsigned long long size, bool isDedicated) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeOpaqueFd;\n    desc.handle.fd = fd;\n    desc.size = size;\n    if (isDedicated) {\n        desc.flags |= cudaExternalMemoryDedicated;\n    }\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    // Input parameter 'fd' should not be used beyond this point as CUDA has assumed ownership of it\n\n    return extMem;\n}\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the application\u2019s responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\n\ncudaExternalMemory_t importVulkanMemoryObjectFromNTHandle(HANDLE handle, unsigned long long size, bool isDedicated) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeOpaqueWin32;\n    desc.handle.win32.handle = handle;\n    desc.size = size;\n    if (isDedicated) {\n        desc.flags |= cudaExternalMemoryDedicated;\n    }\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extMem;\n}\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT can also be imported using a named handle if one exists as shown below.\n\ncudaExternalMemory_t importVulkanMemoryObjectFromNamedNTHandle(LPCWSTR name, unsigned long long size, bool isDedicated) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeOpaqueWin32;\n    desc.handle.win32.name = (void *)name;\n    desc.size = size;\n    if (isDedicated) {\n        desc.flags |= cudaExternalMemoryDedicated;\n    }\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\n\ncudaExternalMemory_t importVulkanMemoryObjectFromKMTHandle(HANDLE handle, unsigned long long size, bool isDedicated) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeOpaqueWin32Kmt;\n    desc.handle.win32.handle = (void *)handle;\n    desc.size = size;\n    if (isDedicated) {\n        desc.flags |= cudaExternalMemoryDedicated;\n    }\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\n6.2.16.1.3. Mapping Buffers onto Imported Memory Objects\uf0c1\n\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Vulkan API. All mapped device pointers must be freed using cudaFree().\n\nvoid * mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, unsigned long long size) {\n\n    void *ptr = NULL;\n\n    cudaExternalMemoryBufferDesc desc = {};\n\n\n\n    memset(&desc, 0, sizeof(desc));\n\n\n\n    desc.offset = offset;\n\n    desc.size = size;\n\n\n\n    cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc);\n\n\n\n    // Note: \u2018ptr\u2019 must eventually be freed using cudaFree()\n\n    return ptr;\n\n}\n\n6.2.16.1.4. Mapping Mipmapped Arrays onto Imported Memory Objects\uf0c1\n\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Vulkan API. Additionally, if the mipmapped array is bound as a color target in Vulkan, the flagcudaArrayColorAttachment must be set. All mapped mipmapped arrays must be freed using cudaFreeMipmappedArray(). The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\n\ncudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, cudaChannelFormatDesc *formatDesc, cudaExtent *extent, unsigned int flags, unsigned int numLevels) {\n    cudaMipmappedArray_t mipmap = NULL;\n    cudaExternalMemoryMipmappedArrayDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.formatDesc = *formatDesc;\n    desc.extent = *extent;\n    desc.flags = flags;\n    desc.numLevels = numLevels;\n\n    // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\n    cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc);\n\n    return mipmap;\n}\n\ncudaChannelFormatDesc getCudaChannelFormatDescForVulkanFormat(VkFormat format)\n{\n    cudaChannelFormatDesc d;\n\n    memset(&d, 0, sizeof(d));\n\n    switch (format) {\n    case VK_FORMAT_R8_UINT:             d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R8_SINT:             d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R8G8_UINT:           d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R8G8_SINT:           d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R8G8B8A8_UINT:       d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R8G8B8A8_SINT:       d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R16_UINT:            d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R16_SINT:            d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R16G16_UINT:         d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R16G16_SINT:         d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R16G16B16A16_UINT:   d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R16G16B16A16_SINT:   d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R32_UINT:            d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R32_SINT:            d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R32_SFLOAT:          d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case VK_FORMAT_R32G32_UINT:         d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R32G32_SINT:         d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R32G32_SFLOAT:       d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case VK_FORMAT_R32G32B32A32_UINT:   d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindUnsigned; break;\n    case VK_FORMAT_R32G32B32A32_SINT:   d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindSigned;   break;\n    case VK_FORMAT_R32G32B32A32_SFLOAT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindFloat;    break;\n    default: assert(0);\n    }\n\n    return d;\n}\n\ncudaExtent getCudaExtentForVulkanExtent(VkExtent3D vkExt, uint32_t arrayLayers, VkImageViewType vkImageViewType) {\n    cudaExtent e = { 0, 0, 0 };\n\n    switch (vkImageViewType) {\n    case VK_IMAGE_VIEW_TYPE_1D:         e.width = vkExt.width; e.height = 0;            e.depth = 0;           break;\n    case VK_IMAGE_VIEW_TYPE_2D:         e.width = vkExt.width; e.height = vkExt.height; e.depth = 0;           break;\n    case VK_IMAGE_VIEW_TYPE_3D:         e.width = vkExt.width; e.height = vkExt.height; e.depth = vkExt.depth; break;\n    case VK_IMAGE_VIEW_TYPE_CUBE:       e.width = vkExt.width; e.height = vkExt.height; e.depth = arrayLayers; break;\n    case VK_IMAGE_VIEW_TYPE_1D_ARRAY:   e.width = vkExt.width; e.height = 0;            e.depth = arrayLayers; break;\n    case VK_IMAGE_VIEW_TYPE_2D_ARRAY:   e.width = vkExt.width; e.height = vkExt.height; e.depth = arrayLayers; break;\n    case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: e.width = vkExt.width; e.height = vkExt.height; e.depth = arrayLayers; break;\n    default: assert(0);\n    }\n\n    return e;\n}\n\nunsigned int getCudaMipmappedArrayFlagsForVulkanImage(VkImageViewType vkImageViewType, VkImageUsageFlags vkImageUsageFlags, bool allowSurfaceLoadStore) {\n    unsigned int flags = 0;\n\n    switch (vkImageViewType) {\n    case VK_IMAGE_VIEW_TYPE_CUBE:       flags |= cudaArrayCubemap;                    break;\n    case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: flags |= cudaArrayCubemap | cudaArrayLayered; break;\n    case VK_IMAGE_VIEW_TYPE_1D_ARRAY:   flags |= cudaArrayLayered;                    break;\n    case VK_IMAGE_VIEW_TYPE_2D_ARRAY:   flags |= cudaArrayLayered;                    break;\n    default: break;\n    }\n\n    if (vkImageUsageFlags & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) {\n        flags |= cudaArrayColorAttachment;\n    }\n\n    if (allowSurfaceLoadStore) {\n        flags |= cudaArraySurfaceLoadStore;\n    }\n    return flags;\n}\n\n6.2.16.1.5. Importing Synchronization Objects\uf0c1\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BITcan be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.\n\ncudaExternalSemaphore_t importVulkanSemaphoreObjectFromFileDescriptor(int fd) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeOpaqueFd;\n    desc.handle.fd = fd;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'fd' should not be used beyond this point as CUDA has assumed ownership of it\n\n    return extSem;\n}\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the application\u2019s responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\n\ncudaExternalSemaphore_t importVulkanSemaphoreObjectFromNTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32;\n    desc.handle.win32.handle = handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extSem;\n}\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT can also be imported using a named handle if one exists as shown below.\n\ncudaExternalSemaphore_t importVulkanSemaphoreObjectFromNamedNTHandle(LPCWSTR name) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32;\n    desc.handle.win32.name = (void *)name;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    return extSem;\n}\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying semaphore it is automatically destroyed when all other references to the resource are destroyed.\n\ncudaExternalSemaphore_t importVulkanSemaphoreObjectFromKMTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt;\n    desc.handle.win32.handle = (void *)handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    return extSem;\n}\n\n6.2.16.1.6. Signaling/Waiting on Imported Synchronization Objects\uf0c1\n\nAn imported Vulkan semaphore object can be signaled as shown below. Signaling such a semaphore object sets it to the signaled state. The corresponding wait that waits on this signal must be issued in Vulkan. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream) {\n    cudaExternalSemaphoreSignalParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\nAn imported Vulkan semaphore object can be waited on as shown below. Waiting on such a semaphore object waits until it reaches the signaled state and then resets it back to the unsignaled state. The corresponding signal that this wait is waiting on must be issued in Vulkan. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream) {\n    cudaExternalSemaphoreWaitParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\n6.2.16.2. OpenGL Interoperability\uf0c1\n\nTraditional OpenGL-CUDA interop as outlined in OpenGL Interoperability works by CUDA directly consuming handles created in OpenGL. However, since OpenGL can also consume memory and synchronization objects created in Vulkan, there exists an alternative approach to doing OpenGL-CUDA interop. Essentially, memory and synchronization objects exported by Vulkan could be imported into both, OpenGL and CUDA, and then used to coordinate memory accesses between OpenGL and CUDA. Please refer to the following OpenGL extensions for further details on how to import memory and synchronization objects exported by Vulkan:\n\n    GL_EXT_memory_object\n\n    GL_EXT_memory_object_fd\n\n    GL_EXT_memory_object_win32\n\n    GL_EXT_semaphore\n\n    GL_EXT_semaphore_fd\n\n    GL_EXT_semaphore_win32\n\n6.2.16.3. Direct3D 12 Interoperability\uf0c1\n6.2.16.3.1. Matching Device LUIDs\uf0c1\n\nWhen importing memory and synchronization objects exported by Direct3D 12, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 12 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 12 device, as shown in the following code sample. Note that the Direct3D 12 device must not be created on a linked node adapter. I.e. the node count as returned by ID3D12Device::GetNodeCount must be 1.\n\nint getCudaDeviceForD3D12Device(ID3D12Device *d3d12Device) {\n    LUID d3d12Luid = d3d12Device->GetAdapterLuid();\n\n    int cudaDeviceCount;\n    cudaGetDeviceCount(&cudaDeviceCount);\n\n    for (int cudaDevice = 0; cudaDevice < cudaDeviceCount; cudaDevice++) {\n        cudaDeviceProp deviceProp;\n        cudaGetDeviceProperties(&deviceProp, cudaDevice);\n        char *cudaLuid = deviceProp.luid;\n\n        if (!memcmp(&d3d12Luid.LowPart, cudaLuid, sizeof(d3d12Luid.LowPart)) &&\n            !memcmp(&d3d12Luid.HighPart, cudaLuid + sizeof(d3d12Luid.LowPart), sizeof(d3d12Luid.HighPart))) {\n            return cudaDevice;\n        }\n    }\n    return cudaInvalidDeviceId;\n}\n\n6.2.16.3.2. Importing Memory Objects\uf0c1\n\nA shareable Direct3D 12 heap memory object, created by setting the flag D3D12_HEAP_FLAG_SHARED in the call to ID3D12Device::CreateHeap, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application\u2019s responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\n\ncudaExternalMemory_t importD3D12HeapFromNTHandle(HANDLE handle, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D12Heap;\n    desc.handle.win32.handle = (void *)handle;\n    desc.size = size;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extMem;\n}\n\nA shareable Direct3D 12 heap memory object can also be imported using a named handle if one exists as shown below.\n\ncudaExternalMemory_t importD3D12HeapFromNamedNTHandle(LPCWSTR name, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D12Heap;\n    desc.handle.win32.name = (void *)name;\n    desc.size = size;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\nA shareable Direct3D 12 committed resource, created by setting the flag D3D12_HEAP_FLAG_SHARED in the call to D3D12Device::CreateCommittedResource, can be imported into CUDA using the NT handle associated with that object as shown below. When importing a Direct3D 12 committed resource, the flag cudaExternalMemoryDedicated must be set. Note that it is the application\u2019s responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.\n\ncudaExternalMemory_t importD3D12CommittedResourceFromNTHandle(HANDLE handle, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D12Resource;\n    desc.handle.win32.handle = (void *)handle;\n    desc.size = size;\n    desc.flags |= cudaExternalMemoryDedicated;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extMem;\n}\n\nA shareable Direct3D 12 committed resource can also be imported using a named handle if one exists as shown below.\n\ncudaExternalMemory_t importD3D12CommittedResourceFromNamedNTHandle(LPCWSTR name, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D12Resource;\n    desc.handle.win32.name = (void *)name;\n    desc.size = size;\n    desc.flags |= cudaExternalMemoryDedicated;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\n6.2.16.3.3. Mapping Buffers onto Imported Memory Objects\uf0c1\n\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 12 API. All mapped device pointers must be freed using cudaFree().\n\nvoid * mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, unsigned long long size) {\n    void *ptr = NULL;\n    cudaExternalMemoryBufferDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.size = size;\n\n    cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc);\n\n    // Note: 'ptr' must eventually be freed using cudaFree()\n    return ptr;\n}\n\n6.2.16.3.4. Mapping Mipmapped Arrays onto Imported Memory Objects\uf0c1\n\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 12 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag cudaArrayColorAttachment must be set. All mapped mipmapped arrays must be freed using cudaFreeMipmappedArray(). The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\n\ncudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, cudaChannelFormatDesc *formatDesc, cudaExtent *extent, unsigned int flags, unsigned int numLevels) {\n    cudaMipmappedArray_t mipmap = NULL;\n    cudaExternalMemoryMipmappedArrayDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.formatDesc = *formatDesc;\n    desc.extent = *extent;\n    desc.flags = flags;\n    desc.numLevels = numLevels;\n\n    // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\n    cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc);\n\n    return mipmap;\n}\n\ncudaChannelFormatDesc getCudaChannelFormatDescForDxgiFormat(DXGI_FORMAT dxgiFormat)\n{\n    cudaChannelFormatDesc d;\n\n    memset(&d, 0, sizeof(d));\n\n    switch (dxgiFormat) {\n    case DXGI_FORMAT_R8_UINT:            d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8_SINT:            d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R8G8_UINT:          d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8G8_SINT:          d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R8G8B8A8_UINT:      d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8G8B8A8_SINT:      d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16_UINT:           d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16_SINT:           d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16G16_UINT:        d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16G16_SINT:        d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16G16B16A16_UINT:  d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16G16B16A16_SINT:  d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32_UINT:           d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32_SINT:           d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32_FLOAT:          d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case DXGI_FORMAT_R32G32_UINT:        d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32G32_SINT:        d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32G32_FLOAT:       d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case DXGI_FORMAT_R32G32B32A32_UINT:  d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32G32B32A32_SINT:  d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32G32B32A32_FLOAT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindFloat;    break;\n    default: assert(0);\n\n    }\n\n    return d;\n}\n\ncudaExtent getCudaExtentForD3D12Extent(UINT64 width, UINT height, UINT16 depthOrArraySize, D3D12_SRV_DIMENSION d3d12SRVDimension) {\n    cudaExtent e = { 0, 0, 0 };\n\n    switch (d3d12SRVDimension) {\n    case D3D12_SRV_DIMENSION_TEXTURE1D:        e.width = width; e.height = 0;      e.depth = 0;                break;\n    case D3D12_SRV_DIMENSION_TEXTURE2D:        e.width = width; e.height = height; e.depth = 0;                break;\n    case D3D12_SRV_DIMENSION_TEXTURE3D:        e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D12_SRV_DIMENSION_TEXTURECUBE:      e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D12_SRV_DIMENSION_TEXTURE1DARRAY:   e.width = width; e.height = 0;      e.depth = depthOrArraySize; break;\n    case D3D12_SRV_DIMENSION_TEXTURE2DARRAY:   e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    default: assert(0);\n    }\n\n    return e;\n}\n\nunsigned int getCudaMipmappedArrayFlagsForD3D12Resource(D3D12_SRV_DIMENSION d3d12SRVDimension, D3D12_RESOURCE_FLAGS d3d12ResourceFlags, bool allowSurfaceLoadStore) {\n    unsigned int flags = 0;\n\n    switch (d3d12SRVDimension) {\n    case D3D12_SRV_DIMENSION_TEXTURECUBE:      flags |= cudaArrayCubemap;                    break;\n    case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: flags |= cudaArrayCubemap | cudaArrayLayered; break;\n    case D3D12_SRV_DIMENSION_TEXTURE1DARRAY:   flags |= cudaArrayLayered;                    break;\n    case D3D12_SRV_DIMENSION_TEXTURE2DARRAY:   flags |= cudaArrayLayered;                    break;\n    default: break;\n    }\n\n    if (d3d12ResourceFlags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) {\n        flags |= cudaArrayColorAttachment;\n    }\n    if (allowSurfaceLoadStore) {\n        flags |= cudaArraySurfaceLoadStore;\n    }\n\n    return flags;\n}\n\n6.2.16.3.5. Importing Synchronization Objects\uf0c1\n\nA shareable Direct3D 12 fence object, created by setting the flag D3D12_FENCE_FLAG_SHARED in the call to ID3D12Device::CreateFence, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application\u2019s responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\n\ncudaExternalSemaphore_t importD3D12FenceFromNTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeD3D12Fence;\n    desc.handle.win32.handle = handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extSem;\n}\n\nA shareable Direct3D 12 fence object can also be imported using a named handle if one exists as shown below.\n\ncudaExternalSemaphore_t importD3D12FenceFromNamedNTHandle(LPCWSTR name) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeD3D12Fence;\n    desc.handle.win32.name = (void *)name;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    return extSem;\n}\n\n6.2.16.3.6. Signaling/Waiting on Imported Synchronization Objects\uf0c1\n\nAn imported Direct3D 12 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 12. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {\n    cudaExternalSemaphoreSignalParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.fence.value = value;\n\n    cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\nAn imported Direct3D 12 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 12. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {\n    cudaExternalSemaphoreWaitParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.fence.value = value;\n\n    cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\n6.2.16.4. Direct3D 11 Interoperability\uf0c1\n6.2.16.4.1. Matching Device LUIDs\uf0c1\n\nWhen importing memory and synchronization objects exported by Direct3D 11, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 11 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 11 device, as shown in the following code sample.\n\nint getCudaDeviceForD3D11Device(ID3D11Device *d3d11Device) {\n    IDXGIDevice *dxgiDevice;\n    d3d11Device->QueryInterface(__uuidof(IDXGIDevice), (void **)&dxgiDevice);\n\n    IDXGIAdapter *dxgiAdapter;\n    dxgiDevice->GetAdapter(&dxgiAdapter);\n\n    DXGI_ADAPTER_DESC dxgiAdapterDesc;\n    dxgiAdapter->GetDesc(&dxgiAdapterDesc);\n\n    LUID d3d11Luid = dxgiAdapterDesc.AdapterLuid;\n\n    int cudaDeviceCount;\n    cudaGetDeviceCount(&cudaDeviceCount);\n\n    for (int cudaDevice = 0; cudaDevice < cudaDeviceCount; cudaDevice++) {\n        cudaDeviceProp deviceProp;\n        cudaGetDeviceProperties(&deviceProp, cudaDevice);\n        char *cudaLuid = deviceProp.luid;\n\n        if (!memcmp(&d3d11Luid.LowPart, cudaLuid, sizeof(d3d11Luid.LowPart)) &&\n            !memcmp(&d3d11Luid.HighPart, cudaLuid + sizeof(d3d11Luid.LowPart), sizeof(d3d11Luid.HighPart))) {\n            return cudaDevice;\n        }\n    }\n    return cudaInvalidDeviceId;\n}\n\n6.2.16.4.2. Importing Memory Objects\uf0c1\n\nA shareable Direct3D 11 texture resource, viz, ID3D11Texture1D, ID3D11Texture2D or ID3D11Texture3D, can be created by setting either the D3D11_RESOURCE_MISC_SHARED or D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX (on Windows 7) or D3D11_RESOURCE_MISC_SHARED_NTHANDLE (on Windows 10) when calling ID3D11Device:CreateTexture1D, ID3D11Device:CreateTexture2D or ID3D11Device:CreateTexture3D respectively. A shareable Direct3D 11 buffer resource, ID3D11Buffer, can be created by specifying either of the above flags when calling ID3D11Device::CreateBuffer. A shareable resource created by specifying the D3D11_RESOURCE_MISC_SHARED_NTHANDLE can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application\u2019s responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed. When importing a Direct3D 11 resource, the flag cudaExternalMemoryDedicated must be set.\n\ncudaExternalMemory_t importD3D11ResourceFromNTHandle(HANDLE handle, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D11Resource;\n    desc.handle.win32.handle = (void *)handle;\n    desc.size = size;\n    desc.flags |= cudaExternalMemoryDedicated;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extMem;\n}\n\nA shareable Direct3D 11 resource can also be imported using a named handle if one exists as shown below.\n\ncudaExternalMemory_t importD3D11ResourceFromNamedNTHandle(LPCWSTR name, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D11Resource;\n    desc.handle.win32.name = (void *)name;\n    desc.size = size;\n    desc.flags |= cudaExternalMemoryDedicated;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\nA shareable Direct3D 11 resource, created by specifying the D3D11_RESOURCE_MISC_SHARED or D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX, can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\n\ncudaExternalMemory_t importD3D11ResourceFromKMTHandle(HANDLE handle, unsigned long long size) {\n    cudaExternalMemory_t extMem = NULL;\n    cudaExternalMemoryHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalMemoryHandleTypeD3D11ResourceKmt;\n    desc.handle.win32.handle = (void *)handle;\n    desc.size = size;\n    desc.flags |= cudaExternalMemoryDedicated;\n\n    cudaImportExternalMemory(&extMem, &desc);\n\n    return extMem;\n}\n\n6.2.16.4.3. Mapping Buffers onto Imported Memory Objects\uf0c1\n\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 11 API. All mapped device pointers must be freed using cudaFree().\n\nvoid * mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, unsigned long long size) {\n    void *ptr = NULL;\n    cudaExternalMemoryBufferDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.size = size;\n\n    cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc);\n\n    // Note: \u2018ptr\u2019 must eventually be freed using cudaFree()\n    return ptr;\n}\n\n6.2.16.4.4. Mapping Mipmapped Arrays onto Imported Memory Objects\uf0c1\n\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 11 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag cudaArrayColorAttachment must be set. All mapped mipmapped arrays must be freed using cudaFreeMipmappedArray(). The following code sample shows how to convert Direct3D 11 parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\n\ncudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, cudaChannelFormatDesc *formatDesc, cudaExtent *extent, unsigned int flags, unsigned int numLevels) {\n    cudaMipmappedArray_t mipmap = NULL;\n    cudaExternalMemoryMipmappedArrayDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.formatDesc = *formatDesc;\n    desc.extent = *extent;\n    desc.flags = flags;\n    desc.numLevels = numLevels;\n\n    // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\n    cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc);\n\n    return mipmap;\n}\n\ncudaChannelFormatDesc getCudaChannelFormatDescForDxgiFormat(DXGI_FORMAT dxgiFormat)\n{\n    cudaChannelFormatDesc d;\n    memset(&d, 0, sizeof(d));\n    switch (dxgiFormat) {\n    case DXGI_FORMAT_R8_UINT:            d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8_SINT:            d.x = 8;  d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R8G8_UINT:          d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8G8_SINT:          d.x = 8;  d.y = 8;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R8G8B8A8_UINT:      d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R8G8B8A8_SINT:      d.x = 8;  d.y = 8;  d.z = 8;  d.w = 8;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16_UINT:           d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16_SINT:           d.x = 16; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16G16_UINT:        d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16G16_SINT:        d.x = 16; d.y = 16; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R16G16B16A16_UINT:  d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R16G16B16A16_SINT:  d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32_UINT:           d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32_SINT:           d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32_FLOAT:          d.x = 32; d.y = 0;  d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case DXGI_FORMAT_R32G32_UINT:        d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32G32_SINT:        d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32G32_FLOAT:       d.x = 32; d.y = 32; d.z = 0;  d.w = 0;  d.f = cudaChannelFormatKindFloat;    break;\n    case DXGI_FORMAT_R32G32B32A32_UINT:  d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindUnsigned; break;\n    case DXGI_FORMAT_R32G32B32A32_SINT:  d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindSigned;   break;\n    case DXGI_FORMAT_R32G32B32A32_FLOAT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f = cudaChannelFormatKindFloat;    break;\n    default: assert(0);\n    }\n\n    return d;\n}\n\ncudaExtent getCudaExtentForD3D11Extent(UINT64 width, UINT height, UINT16 depthOrArraySize, D3D12_SRV_DIMENSION d3d11SRVDimension) {\n    cudaExtent e = { 0, 0, 0 };\n\n    switch (d3d11SRVDimension) {\n    case D3D11_SRV_DIMENSION_TEXTURE1D:        e.width = width; e.height = 0;      e.depth = 0;                break;\n    case D3D11_SRV_DIMENSION_TEXTURE2D:        e.width = width; e.height = height; e.depth = 0;                break;\n    case D3D11_SRV_DIMENSION_TEXTURE3D:        e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D11_SRV_DIMENSION_TEXTURECUBE:      e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D11_SRV_DIMENSION_TEXTURE1DARRAY:   e.width = width; e.height = 0;      e.depth = depthOrArraySize; break;\n    case D3D11_SRV_DIMENSION_TEXTURE2DARRAY:   e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY: e.width = width; e.height = height; e.depth = depthOrArraySize; break;\n    default: assert(0);\n    }\n    return e;\n}\n\nunsigned int getCudaMipmappedArrayFlagsForD3D12Resource(D3D11_SRV_DIMENSION d3d11SRVDimension, D3D11_BIND_FLAG d3d11BindFlags, bool allowSurfaceLoadStore) {\n    unsigned int flags = 0;\n\n    switch (d3d11SRVDimension) {\n    case D3D11_SRV_DIMENSION_TEXTURECUBE:      flags |= cudaArrayCubemap;                    break;\n    case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY: flags |= cudaArrayCubemap | cudaArrayLayered; break;\n    case D3D11_SRV_DIMENSION_TEXTURE1DARRAY:   flags |= cudaArrayLayered;                    break;\n    case D3D11_SRV_DIMENSION_TEXTURE2DARRAY:   flags |= cudaArrayLayered;                    break;\n    default: break;\n    }\n\n    if (d3d11BindFlags & D3D11_BIND_RENDER_TARGET) {\n        flags |= cudaArrayColorAttachment;\n    }\n\n    if (allowSurfaceLoadStore) {\n        flags |= cudaArraySurfaceLoadStore;\n    }\n\n    return flags;\n}\n\n6.2.16.4.5. Importing Synchronization Objects\uf0c1\n\nA shareable Direct3D 11 fence object, created by setting the flag D3D11_FENCE_FLAG_SHARED in the call to ID3D11Device5::CreateFence, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application\u2019s responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\n\ncudaExternalSemaphore_t importD3D11FenceFromNTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeD3D11Fence;\n    desc.handle.win32.handle = handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extSem;\n}\n\nA shareable Direct3D 11 fence object can also be imported using a named handle if one exists as shown below.\n\ncudaExternalSemaphore_t importD3D11FenceFromNamedNTHandle(LPCWSTR name) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeD3D11Fence;\n    desc.handle.win32.name = (void *)name;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    return extSem;\n}\n\nA shareable Direct3D 11 keyed mutex object associated with a shareable Direct3D 11 resource, viz, IDXGIKeyedMutex, created by setting the flag D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application\u2019s responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.\n\ncudaExternalSemaphore_t importD3D11KeyedMutexFromNTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutex;\n    desc.handle.win32.handle = handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extSem;\n}\n\nA shareable Direct3D 11 keyed mutex object can also be imported using a named handle if one exists as shown below.\n\ncudaExternalSemaphore_t importD3D11KeyedMutexFromNamedNTHandle(LPCWSTR name) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutex;\n    desc.handle.win32.name = (void *)name;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    return extSem;\n}\n\nA shareable Direct3D 11 keyed mutex object can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\n\ncudaExternalSemaphore_t importD3D11FenceFromKMTHandle(HANDLE handle) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutexKmt;\n    desc.handle.win32.handle = handle;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Input parameter 'handle' should be closed if it's not needed anymore\n    CloseHandle(handle);\n\n    return extSem;\n}\n\n6.2.16.4.6. Signaling/Waiting on Imported Synchronization Objects\uf0c1\n\nAn imported Direct3D 11 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 11. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {\n    cudaExternalSemaphoreSignalParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.fence.value = value;\n\n    cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\nAn imported Direct3D 11 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {\n    cudaExternalSemaphoreWaitParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.fence.value = value;\n\n    cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\nAn imported Direct3D 11 keyed mutex object can be signaled as shown below. Signaling such a keyed mutex object by specifying a key value releases the keyed mutex for that value. The corresponding wait that waits on this signal must be issued in Direct3D 11 with the same key value. Additionally, the Direct3D 11 wait must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long key, cudaStream_t stream) {\n    cudaExternalSemaphoreSignalParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.keyedmutex.key = key;\n\n    cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\nAn imported Direct3D 11 keyed mutex object can be waited on as shown below. A timeout value in milliseconds is needed when waiting on such a keyed mutex. The wait operation waits until the keyed mutex value is equal to the specified key value or until the timeout has elapsed. The timeout interval can also be an infinite value. In case an infinite value is specified the timeout never elapses. The windows INFINITE macro must be used to specify an infinite timeout. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the Direct3D 11 signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long key, unsigned int timeoutMs, cudaStream_t stream) {\n    cudaExternalSemaphoreWaitParams params = {};\n\n    memset(&params, 0, sizeof(params));\n\n    params.params.keyedmutex.key = key;\n    params.params.keyedmutex.timeoutMs = timeoutMs;\n\n    cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream);\n}\n\n6.2.16.5. NVIDIA Software Communication Interface Interoperability (NVSCI)\uf0c1\n\nNvSciBuf and NvSciSync are interfaces developed for serving the following purposes:\n\n    NvSciBuf: Allows applications to allocate and exchange buffers in memory\n\n    NvSciSync: Allows applications to manage synchronization objects at operation boundaries\n\nMore details on these interfaces are available at: https://docs.nvidia.com/drive.\n6.2.16.5.1. Importing Memory Objects\uf0c1\n\nFor allocating an NvSciBuf object compatible with a given CUDA device, the corresponding GPU id must be set with NvSciBufGeneralAttrKey_GpuId in the NvSciBuf attribute list as shown below. Optionally, applications can specify the following attributes -\n\n    NvSciBufGeneralAttrKey_NeedCpuAccess: Specifies if CPU access is required for the buffer\n\n    NvSciBufRawBufferAttrKey_Align: Specifies the alignment requirement of NvSciBufType_RawBuffer\n\n    NvSciBufGeneralAttrKey_RequiredPerm: Different access permissions can be configured for different UMDs per NvSciBuf memory object instance. For example, to provide the GPU with read-only access permissions to the buffer, create a duplicate NvSciBuf object using NvSciBufObjDupWithReducePerm() with NvSciBufAccessPerm_Readonly as the input parameter. Then import this newly created duplicate object with reduced permission into CUDA as shown\n\n    NvSciBufGeneralAttrKey_EnableGpuCache: To control GPU L2 cacheability\n\n    NvSciBufGeneralAttrKey_EnableGpuCompression: To specify GPU compression\n\nNote\n\nFor more details on these attributes and their valid input options, refer to NvSciBuf Documentation.\n\nThe following code snippet illustrates their sample usage.\n\nNvSciBufObj createNvSciBufObject() {\n   // Raw Buffer Attributes for CUDA\n    NvSciBufType bufType = NvSciBufType_RawBuffer;\n    uint64_t rawsize = SIZE;\n    uint64_t align = 0;\n    bool cpuaccess_flag = true;\n    NvSciBufAttrValAccessPerm perm = NvSciBufAccessPerm_ReadWrite;\n\n    NvSciRmGpuId gpuid[] ={};\n    CUuuid uuid;\n    cuDeviceGetUuid(&uuid, dev));\n\n    memcpy(&gpuid[0].bytes, &uuid.bytes, sizeof(uuid.bytes));\n    // Disable cache on dev\n    NvSciBufAttrValGpuCache gpuCache[] = {{gpuid[0], false}};\n    NvSciBufAttrValGpuCompression gpuCompression[] = {{gpuid[0], NvSciBufCompressionType_GenericCompressible}};\n    // Fill in values\n    NvSciBufAttrKeyValuePair rawbuffattrs[] = {\n         { NvSciBufGeneralAttrKey_Types, &bufType, sizeof(bufType) },\n         { NvSciBufRawBufferAttrKey_Size, &rawsize, sizeof(rawsize) },\n         { NvSciBufRawBufferAttrKey_Align, &align, sizeof(align) },\n         { NvSciBufGeneralAttrKey_NeedCpuAccess, &cpuaccess_flag, sizeof(cpuaccess_flag) },\n         { NvSciBufGeneralAttrKey_RequiredPerm, &perm, sizeof(perm) },\n         { NvSciBufGeneralAttrKey_GpuId, &gpuid, sizeof(gpuid) },\n         { NvSciBufGeneralAttrKey_EnableGpuCache &gpuCache, sizeof(gpuCache) },\n         { NvSciBufGeneralAttrKey_EnableGpuCompression &gpuCompression, sizeof(gpuCompression) }\n    };\n\n    // Create list by setting attributes\n    err = NvSciBufAttrListSetAttrs(attrListBuffer, rawbuffattrs,\n            sizeof(rawbuffattrs)/sizeof(NvSciBufAttrKeyValuePair));\n\n    NvSciBufAttrListCreate(NvSciBufModule, &attrListBuffer);\n\n    // Reconcile And Allocate\n    NvSciBufAttrListReconcile(&attrListBuffer, 1, &attrListReconciledBuffer,\n                       &attrListConflictBuffer)\n    NvSciBufObjAlloc(attrListReconciledBuffer, &bufferObjRaw);\n    return bufferObjRaw;\n}\n\nNvSciBufObj bufferObjRo; // Readonly NvSciBuf memory obj\n// Create a duplicate handle to the same memory buffer with reduced permissions\nNvSciBufObjDupWithReducePerm(bufferObjRaw, NvSciBufAccessPerm_Readonly, &bufferObjRo);\nreturn bufferObjRo;\n\nThe allocated NvSciBuf memory object can be imported in CUDA using the NvSciBufObj handle as shown below. Application should query the allocated NvSciBufObj for attributes required for filling CUDA External Memory Descriptor. Note that the attribute list and NvSciBuf objects should be maintained by the application. If the NvSciBuf object imported into CUDA is also mapped by other drivers, then based on NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency output attribute value the application must use NvSciSync objects (refer to Importing Synchronization Objects) as appropriate barriers to maintain coherence between CUDA and the other drivers.\n\nNote\n\nFor more details on how to allocate and maintain NvSciBuf objects refer to NvSciBuf API Documentation.\n\ncudaExternalMemory_t importNvSciBufObject (NvSciBufObj bufferObjRaw) {\n\n    /*************** Query NvSciBuf Object **************/\n    NvSciBufAttrKeyValuePair bufattrs[] = {\n                { NvSciBufRawBufferAttrKey_Size, NULL, 0 },\n                { NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency, NULL, 0 },\n                { NvSciBufGeneralAttrKey_EnableGpuCompression, NULL, 0 }\n    };\n    NvSciBufAttrListGetAttrs(retList, bufattrs,\n        sizeof(bufattrs)/sizeof(NvSciBufAttrKeyValuePair)));\n                ret_size = *(static_cast<const uint64_t*>(bufattrs[0].value));\n\n    // Note cache and compression are per GPU attributes, so read values for specific gpu by comparing UUID\n    // Read cacheability granted by NvSciBuf\n    int numGpus = bufattrs[1].len / sizeof(NvSciBufAttrValGpuCache);\n    NvSciBufAttrValGpuCache[] cacheVal = (NvSciBufAttrValGpuCache *)bufattrs[1].value;\n    bool ret_cacheVal;\n    for (int i = 0; i < numGpus; i++) {\n        if (memcmp(gpuid[0].bytes, cacheVal[i].gpuId.bytes, sizeof(CUuuid)) == 0) {\n            ret_cacheVal = cacheVal[i].cacheability);\n        }\n    }\n\n    // Read compression granted by NvSciBuf\n    numGpus = bufattrs[2].len / sizeof(NvSciBufAttrValGpuCompression);\n    NvSciBufAttrValGpuCompression[] compVal = (NvSciBufAttrValGpuCompression *)bufattrs[2].value;\n    NvSciBufCompressionType ret_compVal;\n    for (int i = 0; i < numGpus; i++) {\n        if (memcmp(gpuid[0].bytes, compVal[i].gpuId.bytes, sizeof(CUuuid)) == 0) {\n            ret_compVal = compVal[i].compressionType);\n        }\n    }\n\n    /*************** NvSciBuf Registration With CUDA **************/\n\n    // Fill up CUDA_EXTERNAL_MEMORY_HANDLE_DESC\n    cudaExternalMemoryHandleDesc memHandleDesc;\n    memset(&memHandleDesc, 0, sizeof(memHandleDesc));\n    memHandleDesc.type = cudaExternalMemoryHandleTypeNvSciBuf;\n    memHandleDesc.handle.nvSciBufObject = bufferObjRaw;\n    // Set the NvSciBuf object with required access permissions in this step\n    memHandleDesc.handle.nvSciBufObject = bufferObjRo;\n    memHandleDesc.size = ret_size;\n    cudaImportExternalMemory(&extMemBuffer, &memHandleDesc);\n    return extMemBuffer;\n }\n\n6.2.16.5.2. Mapping Buffers onto Imported Memory Objects\uf0c1\n\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping can be filled as per the attributes of the allocated NvSciBufObj. All mapped device pointers must be freed using cudaFree().\n\nvoid * mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, unsigned long long size) {\n    void *ptr = NULL;\n    cudaExternalMemoryBufferDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.size = size;\n\n    cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc);\n\n    // Note: 'ptr' must eventually be freed using cudaFree()\n    return ptr;\n}\n\n6.2.16.5.3. Mapping Mipmapped Arrays onto Imported Memory Objects\uf0c1\n\nA CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions and format can be filled as per the attributes of the allocated NvSciBufObj. All mapped mipmapped arrays must be freed using cudaFreeMipmappedArray(). The following code sample shows how to convert NvSciBuf attributes into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.\n\nNote\n\nThe number of mip levels must be 1.\n\ncudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, cudaChannelFormatDesc *formatDesc, cudaExtent *extent, unsigned int flags, unsigned int numLevels) {\n    cudaMipmappedArray_t mipmap = NULL;\n    cudaExternalMemoryMipmappedArrayDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.offset = offset;\n    desc.formatDesc = *formatDesc;\n    desc.extent = *extent;\n    desc.flags = flags;\n    desc.numLevels = numLevels;\n\n    // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray()\n    cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc);\n\n    return mipmap;\n}\n\n6.2.16.5.4. Importing Synchronization Objects\uf0c1\n\nNvSciSync attributes that are compatible with a given CUDA device can be generated using cudaDeviceGetNvSciSyncAttributes(). The returned attribute list can be used to create a NvSciSyncObj that is guaranteed compatibility with a given CUDA device.\n\nNvSciSyncObj createNvSciSyncObject() {\n    NvSciSyncObj nvSciSyncObj\n    int cudaDev0 = 0;\n    int cudaDev1 = 1;\n    NvSciSyncAttrList signalerAttrList = NULL;\n    NvSciSyncAttrList waiterAttrList = NULL;\n    NvSciSyncAttrList reconciledList = NULL;\n    NvSciSyncAttrList newConflictList = NULL;\n\n    NvSciSyncAttrListCreate(module, &signalerAttrList);\n    NvSciSyncAttrListCreate(module, &waiterAttrList);\n    NvSciSyncAttrList unreconciledList[2] = {NULL, NULL};\n    unreconciledList[0] = signalerAttrList;\n    unreconciledList[1] = waiterAttrList;\n\n    cudaDeviceGetNvSciSyncAttributes(signalerAttrList, cudaDev0, CUDA_NVSCISYNC_ATTR_SIGNAL);\n    cudaDeviceGetNvSciSyncAttributes(waiterAttrList, cudaDev1, CUDA_NVSCISYNC_ATTR_WAIT);\n\n    NvSciSyncAttrListReconcile(unreconciledList, 2, &reconciledList, &newConflictList);\n\n    NvSciSyncObjAlloc(reconciledList, &nvSciSyncObj);\n\n    return nvSciSyncObj;\n}\n\nAn NvSciSync object (created as above) can be imported into CUDA using the NvSciSyncObj handle as shown below. Note that ownership of the NvSciSyncObj handle continues to lie with the application even after it is imported.\n\ncudaExternalSemaphore_t importNvSciSyncObject(void* nvSciSyncObj) {\n    cudaExternalSemaphore_t extSem = NULL;\n    cudaExternalSemaphoreHandleDesc desc = {};\n\n    memset(&desc, 0, sizeof(desc));\n\n    desc.type = cudaExternalSemaphoreHandleTypeNvSciSync;\n    desc.handle.nvSciSyncObj = nvSciSyncObj;\n\n    cudaImportExternalSemaphore(&extSem, &desc);\n\n    // Deleting/Freeing the nvSciSyncObj beyond this point will lead to undefined behavior in CUDA\n\n    return extSem;\n}\n\n6.2.16.5.5. Signaling/Waiting on Imported Synchronization Objects\uf0c1\n\nAn imported NvSciSyncObj object can be signaled as outlined below. Signaling NvSciSync backed semaphore object initializes the fence parameter passed as input. This fence parameter is waited upon by a wait operation that corresponds to the aforementioned signal. Additionally, the wait that waits on this signal must be issued after this signal has been issued. If the flags are set to cudaExternalSemaphoreSignalSkipNvSciBufMemSync then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When NvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency is FALSE, this flag should be set.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream, void *fence) {\n    cudaExternalSemaphoreSignalParams signalParams = {};\n\n    memset(&signalParams, 0, sizeof(signalParams));\n\n    signalParams.params.nvSciSync.fence = (void*)fence;\n    signalParams.flags = 0; //OR cudaExternalSemaphoreSignalSkipNvSciBufMemSync\n\n    cudaSignalExternalSemaphoresAsync(&extSem, &signalParams, 1, stream);\n\n}\n\nAn imported NvSciSyncObj object can be waited upon as outlined below. Waiting on NvSciSync backed semaphore object waits until the input fence parameter is signaled by the corresponding signaler. Additionally, the signal must be issued before the wait can be issued. If the flags are set to cudaExternalSemaphoreWaitSkipNvSciBufMemSync then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When NvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency is FALSE, this flag should be set.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream, void *fence) {\n     cudaExternalSemaphoreWaitParams waitParams = {};\n\n    memset(&waitParams, 0, sizeof(waitParams));\n\n    waitParams.params.nvSciSync.fence = (void*)fence;\n    waitParams.flags = 0; //OR cudaExternalSemaphoreWaitSkipNvSciBufMemSync\n\n    cudaWaitExternalSemaphoresAsync(&extSem, &waitParams, 1, stream);\n}\n\n6.3. Versioning and Compatibility\uf0c1\n\nThere are two version numbers that developers should care about when developing a CUDA application: The compute capability that describes the general specifications and features of the compute device (see Compute Capability) and the version of the CUDA driver API that describes the features supported by the driver API and runtime.\n\nThe version of the driver API is defined in the driver header file as CUDA_VERSION. It allows developers to check whether their application requires a newer device driver than the one currently installed. This is important, because the driver API is backward compatible, meaning that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will continue to work on subsequent device driver releases as illustrated in Figure 26. The driver API is not forward compatible, which means that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will not work on previous versions of the device driver.\n\nIt is important to note that there are limitations on the mixing and matching of versions that is supported:\n\n    Since only one version of the CUDA Driver can be installed at a time on a system, the installed driver must be of the same or higher version than the maximum Driver API version against which any application, plug-ins, or libraries that must run on that system were built.\n\n    All plug-ins and libraries used by an application must use the same version of the CUDA Runtime unless they statically link to the Runtime, in which case multiple versions of the runtime can coexist in the same process space. Note that if nvcc is used to link the application, the static version of the CUDA Runtime library will be used by default, and all CUDA Toolkit libraries are statically linked against the CUDA Runtime.\n\n    All plug-ins and libraries used by an application must use the same version of any libraries that use the runtime (such as cuFFT, cuBLAS, \u2026) unless statically linking to those libraries.\n\nThe Driver API Is Backward but Not Forward Compatible\n\nFigure 26 The Driver API Is Backward but Not Forward Compatible\uf0c1\n\nFor Tesla GPU products, CUDA 10 introduced a new forward-compatible upgrade path for the user-mode components of the CUDA Driver. This feature is described in CUDA Compatibility. The requirements on the CUDA Driver version described here apply to the version of the user-mode components.\n6.4. Compute Modes\uf0c1\n\nOn Tesla solutions running Windows Server 2008 and later or Linux, one can set any device in a system in one of the three following modes using NVIDIA\u2019s System Management Interface (nvidia-smi), which is a tool distributed as part of the driver:\n\n    Default compute mode: Multiple host threads can use the device (by calling cudaSetDevice() on this device, when using the runtime API, or by making current a context associated to the device, when using the driver API) at the same time.\n\n    Exclusive-process compute mode: Only one CUDA context may be created on the device across all processes in the system. The context may be current to as many threads as desired within the process that created that context.\n\n    Prohibited compute mode: No CUDA context can be created on the device.\n\nThis means, in particular, that a host thread using the runtime API without explicitly calling cudaSetDevice() might be associated with a device other than device 0 if device 0 turns out to be in prohibited mode or in exclusive-process mode and used by another process. cudaSetValidDevices() can be used to set a device from a prioritized list of devices.\n\nNote also that, for devices featuring the Pascal architecture onwards (compute capability with major revision number 6 and higher), there exists support for Compute Preemption. This allows compute tasks to be preempted at instruction-level granularity, rather than thread block granularity as in prior Maxwell and Kepler GPU architecture, with the benefit that applications with long-running kernels can be prevented from either monopolizing the system or timing out. However, there will be context switch overheads associated with Compute Preemption, which is automatically enabled on those devices for which support exists. The individual attribute query function cudaDeviceGetAttribute() with the attribute cudaDevAttrComputePreemptionSupported can be used to determine if the device in use supports Compute Preemption. Users wishing to avoid context switch overheads associated with different processes can ensure that only one process is active on the GPU by selecting exclusive-process mode.\n\nApplications may query the compute mode of a device by checking the attribute cudaDevAttrComputeMode.\n6.5. Mode Switches\uf0c1\n\nGPUs that have a display output dedicate some DRAM memory to the so-called primary surface, which is used to refresh the display device whose output is viewed by the user. When users initiate a mode switch of the display by changing the resolution or bit depth of the display (using NVIDIA control panel or the Display control panel on Windows), the amount of memory needed for the primary surface changes. For example, if the user changes the display resolution from 1280x1024x32-bit to 1600x1200x32-bit, the system must dedicate 7.68 MB to the primary surface rather than 5.24 MB. (Full-screen graphics applications running with anti-aliasing enabled may require much more display memory for the primary surface.) On Windows, other events that may initiate display mode switches include launching a full-screen DirectX application, hitting Alt+Tab to task switch away from a full-screen DirectX application, or hitting Ctrl+Alt+Del to lock the computer.\n\nIf a mode switch increases the amount of memory needed for the primary surface, the system may have to cannibalize memory allocations dedicated to CUDA applications. Therefore, a mode switch results in any call to the CUDA runtime to fail and return an invalid context error.\n6.6. Tesla Compute Cluster Mode for Windows\uf0c1\n\nUsing NVIDIA\u2019s System Management Interface (nvidia-smi), the Windows device driver can be put in TCC (Tesla Compute Cluster) mode for devices of the Tesla and Quadro Series.\n\nTCC mode removes support for any graphics functionality.\n7. Hardware Implementation\uf0c1\n\nThe NVIDIA GPU architecture is built around a scalable array of multithreaded Streaming Multiprocessors (SMs). When a CUDA program on the host CPU invokes a kernel grid, the blocks of the grid are enumerated and distributed to multiprocessors with available execution capacity. The threads of a thread block execute concurrently on one multiprocessor, and multiple thread blocks can execute concurrently on one multiprocessor. As thread blocks terminate, new blocks are launched on the vacated multiprocessors.\n\nA multiprocessor is designed to execute hundreds of threads concurrently. To manage such a large number of threads, it employs a unique architecture called SIMT (Single-Instruction, Multiple-Thread) that is described in SIMT Architecture. The instructions are pipelined, leveraging instruction-level parallelism within a single thread, as well as extensive thread-level parallelism through simultaneous hardware multithreading as detailed in Hardware Multithreading. Unlike CPU cores, they are issued in order and there is no branch prediction or speculative execution.\n\nSIMT Architecture and Hardware Multithreading describe the architecture features of the streaming multiprocessor that are common to all devices. Compute Capability 5.x, Compute Capability 6.x, and Compute Capability 7.x provide the specifics for devices of compute capabilities 5.x, 6.x, and 7.x respectively.\n\nThe NVIDIA GPU architecture uses a little-endian representation.\n7.1. SIMT Architecture\uf0c1\n\nThe multiprocessor creates, manages, schedules, and executes threads in groups of 32 parallel threads called warps. Individual threads composing a warp start together at the same program address, but they have their own instruction address counter and register state and are therefore free to branch and execute independently. The term warp originates from weaving, the first parallel thread technology. A half-warp is either the first or second half of a warp. A quarter-warp is either the first, second, third, or fourth quarter of a warp.\n\nWhen a multiprocessor is given one or more thread blocks to execute, it partitions them into warps and each warp gets scheduled by a warp scheduler for execution. The way a block is partitioned into warps is always the same; each warp contains threads of consecutive, increasing thread IDs with the first warp containing thread 0. Thread Hierarchy describes how thread IDs relate to thread indices in the block.\n\nA warp executes one common instruction at a time, so full efficiency is realized when all 32 threads of a warp agree on their execution path. If threads of a warp diverge via a data-dependent conditional branch, the warp executes each branch path taken, disabling threads that are not on that path. Branch divergence occurs only within a warp; different warps execute independently regardless of whether they are executing common or disjoint code paths.\n\nThe SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements. A key difference is that SIMD vector organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution and branching behavior of a single thread. In contrast with SIMD vector machines, SIMT enables programmers to write thread-level parallel code for independent, scalar threads, as well as data-parallel code for coordinated threads. For the purposes of correctness, the programmer can essentially ignore the SIMT behavior; however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge. In practice, this is analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when designing for correctness but must be considered in the code structure when designing for peak performance. Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually.\n\nPrior to NVIDIA Volta, warps used a single program counter shared amongst all 32 threads in the warp together with an active mask specifying the active threads of the warp. As a result, threads from the same warp in divergent regions or different states of execution cannot signal each other or exchange data, and algorithms requiring fine-grained sharing of data guarded by locks or mutexes can easily lead to deadlock, depending on which warp the contending threads come from.\n\nStarting with the NVIDIA Volta architecture, Independent Thread Scheduling allows full concurrency between threads, regardless of warp. With Independent Thread Scheduling, the GPU maintains execution state per thread, including a program counter and call stack, and can yield execution at a per-thread granularity, either to make better use of execution resources or to allow one thread to wait for data to be produced by another. A schedule optimizer determines how to group active threads from the same warp together into SIMT units. This retains the high throughput of SIMT execution as in prior NVIDIA GPUs, but with much more flexibility: threads can now diverge and reconverge at sub-warp granularity.\n\nIndependent Thread Scheduling can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp-synchronicity2 of previous hardware architectures. In particular, any warp-synchronous code (such as synchronization-free, intra-warp reductions) should be revisited to ensure compatibility with NVIDIA Volta and beyond. See Compute Capability 7.x for further details.\n\nNote\n\nThe threads of a warp that are participating in the current instruction are called the active threads, whereas threads not on the current instruction are inactive (disabled). Threads can be inactive for a variety of reasons including having exited earlier than other threads of their warp, having taken a different branch path than the branch path currently executed by the warp, or being the last threads of a block whose number of threads is not a multiple of the warp size.\n\nIf a non-atomic instruction executed by a warp writes to the same location in global or shared memory for more than one of the threads of the warp, the number of serialized writes that occur to that location varies depending on the compute capability of the device (see Compute Capability 5.x, Compute Capability 6.x, and Compute Capability 7.x), and which thread performs the final write is undefined.\n\nIf an atomic instruction executed by a warp reads, modifies, and writes to the same location in global memory for more than one of the threads of the warp, each read/modify/write to that location occurs and they are all serialized, but the order in which they occur is undefined.\n7.2. Hardware Multithreading\uf0c1\n\nThe execution context (program counters, registers, and so on) for each warp processed by a multiprocessor is maintained on-chip during the entire lifetime of the warp. Therefore, switching from one execution context to another has no cost, and at every instruction issue time, a warp scheduler selects a warp that has threads ready to execute its next instruction (the active threads of the warp) and issues the instruction to those threads.\n\nIn particular, each multiprocessor has a set of 32-bit registers that are partitioned among the warps, and a parallel data cache or shared memory that is partitioned among the thread blocks.\n\nThe number of blocks and warps that can reside and be processed together on the multiprocessor for a given kernel depends on the amount of registers and shared memory used by the kernel and the amount of registers and shared memory available on the multiprocessor. There are also a maximum number of resident blocks and a maximum number of resident warps per multiprocessor. These limits as well the amount of registers and shared memory available on the multiprocessor are a function of the compute capability of the device and are given in Compute Capabilities. If there are not enough registers or shared memory available per multiprocessor to process at least one block, the kernel will fail to launch.\n\nThe total number of warps in a block is as follows:\n\n    T is the number of threads per block,\n\n    Wsize is the warp size, which is equal to 32,\n\n    ceil(x, y) is equal to x rounded up to the nearest multiple of y.\n\nThe total number of registers and total amount of shared memory allocated for a block are documented in the CUDA Occupancy Calculator provided in the CUDA Toolkit.\n\n2\n\n    The term warp-synchronous refers to code that implicitly assumes threads in the same warp are synchronized at every instruction.\n\n8. Performance Guidelines\uf0c1\n8.1. Overall Performance Optimization Strategies\uf0c1\n\nPerformance optimization revolves around four basic strategies:\n\n    Maximize parallel execution to achieve maximum utilization;\n\n    Optimize memory usage to achieve maximum memory throughput;\n\n    Optimize instruction usage to achieve maximum instruction throughput;\n\n    Minimize memory thrashing.\n\nWhich strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example. Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler. Also, comparing the floating-point operation throughput or memory throughput\u2014whichever makes more sense\u2014of a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel.\n8.2. Maximize Utilization\uf0c1\n\nTo maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time.\n8.2.1. Application Level\uf0c1\n\nAt a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by using asynchronous functions calls and streams as described in Asynchronous Concurrent Execution. It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices.\n\nFor the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use __syncthreads() and share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory. The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic. Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter-thread communication are performed within a single thread block as much as possible.\n8.2.2. Device Level\uf0c1\n\nAt a lower level, the application should maximize parallel execution between the multiprocessors of a device.\n\nMultiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in Asynchronous Concurrent Execution.\n8.2.3. Multiprocessor Level\uf0c1\n\nAt an even lower level, the application should maximize parallel execution between the various functional units within a multiprocessor.\n\nAs described in Hardware Multithreading, a GPU multiprocessor primarily relies on thread-level parallelism to maximize utilization of its functional units. Utilization is therefore directly linked to the number of resident warps. At every instruction issue time, a warp scheduler selects an instruction that is ready to execute. This instruction can be another independent instruction of the same warp, exploiting instruction-level parallelism, or more commonly an instruction of another warp, exploiting thread-level parallelism. If a ready to execute instruction is selected it is issued to the active threads of the warp. The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the latency, and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely \u201chidden\u201d. The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see the CUDA C++ Best Practices Guide for the throughputs of various arithmetic instructions). If we assume instructions with maximum throughput, it is equal to:\n\n    4L for devices of compute capability 5.x, 6.1, 6.2, 7.x and 8.x since for these devices, a multiprocessor issues one instruction per warp over one clock cycle for four warps at a time, as mentioned in Compute Capabilities.\n\n    2L for devices of compute capability 6.0 since for these devices, the two instructions issued every cycle are one instruction for two different warps.\n\nThe most common reason a warp is not ready to execute its next instruction is that the instruction\u2019s input operands are not available yet.\n\nIf all input operands are registers, latency is caused by register dependencies, i.e., some of the input operands are written by some previous instruction(s) whose execution has not completed yet. In this case, the latency is equal to the execution time of the previous instruction and the warp schedulers must schedule instructions of other warps during that time. Execution time varies depending on the instruction. On devices of compute capability 7.x, for most arithmetic instructions, it is typically 4 clock cycles. This means that 16 active warps per multiprocessor (4 cycles, 4 warp schedulers) are required to hide arithmetic instruction latencies (assuming that warps execute instructions with maximum throughput, otherwise fewer warps are needed). If the individual warps exhibit instruction-level parallelism, i.e. have multiple independent instructions in their instruction stream, fewer warps are needed because multiple independent instructions from a single warp can be issued back to back.\n\nIf some input operand resides in off-chip memory, the latency is much higher: typically hundreds of clock cycles. The number of warps required to keep the warp schedulers busy during such high latency periods depends on the kernel code and its degree of instruction-level parallelism. In general, more warps are required if the ratio of the number of instructions with no off-chip memory operands (i.e., arithmetic instructions most of the time) to the number of instructions with off-chip memory operands is low (this ratio is commonly called the arithmetic intensity of the program).\n\nAnother reason a warp is not ready to execute its next instruction is that it is waiting at some memory fence (Memory Fence Functions) or synchronization point (Synchronization Functions). A synchronization point can force the multiprocessor to idle as more and more warps wait for other warps in the same block to complete execution of instructions prior to the synchronization point. Having multiple resident blocks per multiprocessor can help reduce idling in this case, as warps from different blocks do not need to wait for each other at synchronization points.\n\nThe number of blocks and warps residing on each multiprocessor for a given kernel call depends on the execution configuration of the call (Execution Configuration), the memory resources of the multiprocessor, and the resource requirements of the kernel as described in Hardware Multithreading. Register and shared memory usage are reported by the compiler when compiling with the --ptxas-options=-v option.\n\nThe total amount of shared memory required for a block is equal to the sum of the amount of statically allocated shared memory and the amount of dynamically allocated shared memory.\n\nThe number of registers used by a kernel can have a significant impact on the number of resident warps. For example, for devices of compute capability 6.x, if a kernel uses 64 registers and each block has 512 threads and requires very little shared memory, then two blocks (i.e., 32 warps) can reside on the multiprocessor since they require 2x512x64 registers, which exactly matches the number of registers available on the multiprocessor. But as soon as the kernel uses one more register, only one block (i.e., 16 warps) can be resident since two blocks would require 2x512x65 registers, which are more registers than are available on the multiprocessor. Therefore, the compiler attempts to minimize register usage while keeping register spilling (see Device Memory Accesses) and the number of instructions to a minimum. Register usage can be controlled using the maxrregcount compiler option, the __launch_bounds__() qualifier as described in Launch Bounds, or the __maxnreg__() qualifier as described in Maximum Number of Registers per Thread.\n\nThe register file is organized as 32-bit registers. So, each variable stored in a register needs at least one 32-bit register, for example, a double variable uses two 32-bit registers.\n\nThe effect of execution configuration on performance for a given kernel call generally depends on the kernel code. Experimentation is therefore recommended. Applications can also parametrize execution configurations based on register file size and shared memory size, which depends on the compute capability of the device, as well as on the number of multiprocessors and memory bandwidth of the device, all of which can be queried using the runtime (see reference manual).\n\nThe number of threads per block should be chosen as a multiple of the warp size to avoid wasting computing resources with under-populated warps as much as possible.\n8.2.3.1. Occupancy Calculator\uf0c1\n\nSeveral API functions exist to assist programmers in choosing thread block size and cluster size based on register and shared memory requirements.\n\n    The occupancy calculator API, cudaOccupancyMaxActiveBlocksPerMultiprocessor, can provide an occupancy prediction based on the block size and shared memory usage of a kernel. This function reports occupancy in terms of the number of concurrent thread blocks per multiprocessor.\n\n        Note that this value can be converted to other metrics. Multiplying by the number of warps per block yields the number of concurrent warps per multiprocessor; further dividing concurrent warps by max warps per multiprocessor gives the occupancy as a percentage.\n\n    The occupancy-based launch configurator APIs, cudaOccupancyMaxPotentialBlockSize and cudaOccupancyMaxPotentialBlockSizeVariableSMem, heuristically calculate an execution configuration that achieves the maximum multiprocessor-level occupancy.\n\n    The occupancy calculator API, cudaOccupancyMaxActiveClusters, can provided occupancy prediction based on the cluster size, block size and shared memory usage of a kernel. This function reports occupancy in terms of number of max active clusters of a given size on the GPU present in the system.\n\nThe following code sample calculates the occupancy of MyKernel. It then reports the occupancy level with the ratio between concurrent warps versus maximum warps per multiprocessor.\n\n// Device code\n__global__ void MyKernel(int *d, int *a, int *b)\n{\n    int idx = threadIdx.x + blockIdx.x * blockDim.x;\n    d[idx] = a[idx] * b[idx];\n}\n\n// Host code\nint main()\n{\n    int numBlocks;        // Occupancy in terms of active blocks\n    int blockSize = 32;\n\n    // These variables are used to convert occupancy to warps\n    int device;\n    cudaDeviceProp prop;\n    int activeWarps;\n    int maxWarps;\n\n    cudaGetDevice(&device);\n    cudaGetDeviceProperties(&prop, device);\n\n    cudaOccupancyMaxActiveBlocksPerMultiprocessor(\n        &numBlocks,\n        MyKernel,\n        blockSize,\n        0);\n\n    activeWarps = numBlocks * blockSize / prop.warpSize;\n    maxWarps = prop.maxThreadsPerMultiProcessor / prop.warpSize;\n\n    std::cout << \"Occupancy: \" << (double)activeWarps / maxWarps * 100 << \"%\" << std::endl;\n\n    return 0;\n}\n\nThe following code sample configures an occupancy-based kernel launch of MyKernel according to the user input.\n\n// Device code\n__global__ void MyKernel(int *array, int arrayCount)\n{\n    int idx = threadIdx.x + blockIdx.x * blockDim.x;\n    if (idx < arrayCount) {\n        array[idx] *= array[idx];\n    }\n}\n\n// Host code\nint launchMyKernel(int *array, int arrayCount)\n{\n    int blockSize;      // The launch configurator returned block size\n    int minGridSize;    // The minimum grid size needed to achieve the\n                        // maximum occupancy for a full device\n                        // launch\n    int gridSize;       // The actual grid size needed, based on input\n                        // size\n\n    cudaOccupancyMaxPotentialBlockSize(\n        &minGridSize,\n        &blockSize,\n        (void*)MyKernel,\n        0,\n        arrayCount);\n\n    // Round up according to array size\n    gridSize = (arrayCount + blockSize - 1) / blockSize;\n\n    MyKernel<<<gridSize, blockSize>>>(array, arrayCount);\n    cudaDeviceSynchronize();\n\n    // If interested, the occupancy can be calculated with\n    // cudaOccupancyMaxActiveBlocksPerMultiprocessor\n\n    return 0;\n}\n\nThe following code sample shows how to use the cluster occupancy API to find the max number of active clusters of a given size. Example code below calucaltes occupancy for cluster of size 2 and 128 threads per block.\n\nCluster size of 8 is forward compatible starting compute capability 9.0, except on GPU hardware or MIG configurations which are too small to support 8 multiprocessors in which case the maximum cluster size will be reduced. But it is recommended that the users query the maximum cluster size before launching a cluster kernel. Max cluster size can be queried using cudaOccupancyMaxPotentialClusterSize API.\n\n{\n  cudaLaunchConfig_t config = {0};\n  config.gridDim = number_of_blocks;\n  config.blockDim = 128; // threads_per_block = 128\n  config.dynamicSmemBytes = dynamic_shared_memory_size;\n\n  cudaLaunchAttribute attribute[1];\n  attribute[0].id = cudaLaunchAttributeClusterDimension;\n  attribute[0].val.clusterDim.x = 2; // cluster_size = 2\n  attribute[0].val.clusterDim.y = 1;\n  attribute[0].val.clusterDim.z = 1;\n  config.attrs = attribute;\n  config.numAttrs = 1;\n\n  int max_cluster_size = 0;\n  cudaOccupancyMaxPotentialClusterSize(&max_cluster_size, (void *)kernel, &config);\n\n  int max_active_clusters = 0;\n  cudaOccupancyMaxActiveClusters(&max_active_clusters, (void *)kernel, &config);\n\n  std::cout << \"Max Active Clusters of size 2: \" << max_active_clusters << std::endl;\n}\n\nThe CUDA Nsight Compute User Interface also provides a standalone occupancy calculator and launch configurator implementation in <CUDA_Toolkit_Path>/include/cuda_occupancy.h for any use cases that cannot depend on the CUDA software stack. The Nsight Compute version of the occupancy calculator is particularly useful as a learning tool that visualizes the impact of changes to the parameters that affect occupancy (block size, registers per thread, and shared memory per thread).\n8.3. Maximize Memory Throughput\uf0c1\n\nThe first step in maximizing overall memory throughput for the application is to minimize data transfers with low bandwidth.\n\nThat means minimizing data transfers between the host and the device, as detailed in Data Transfer between Host and Device, since these have much lower bandwidth than data transfers between global memory and the device.\n\nThat also means minimizing data transfers between global memory and the device by maximizing use of on-chip memory: shared memory and caches (i.e., L1 cache and L2 cache available on devices of compute capability 2.x and higher, texture cache and constant cache available on all devices).\n\nShared memory is equivalent to a user-managed cache: The application explicitly allocates and accesses it. As illustrated in CUDA Runtime, a typical programming pattern is to stage data coming from device memory into shared memory; in other words, to have each thread of a block:\n\n    Load data from device memory to shared memory,\n\n    Synchronize with all the other threads of the block so that each thread can safely read shared memory locations that were populated by different threads,\n\n    Process the data in shared memory,\n\n    Synchronize again if necessary to make sure that shared memory has been updated with the results,\n\n    Write the results back to device memory.\n\nFor some applications (for example, for which global memory access patterns are data-dependent), a traditional hardware-managed cache is more appropriate to exploit data locality. As mentioned in Compute Capability 7.x, Compute Capability 8.x and Compute Capability 9.0, for devices of compute capability 7.x, 8.x and 9.0, the same on-chip memory is used for both L1 and shared memory, and how much of it is dedicated to L1 versus shared memory is configurable for each kernel call.\n\nThe throughput of memory accesses by a kernel can vary by an order of magnitude depending on access pattern for each type of memory. The next step in maximizing memory throughput is therefore to organize memory accesses as optimally as possible based on the optimal memory access patterns described in Device Memory Accesses. This optimization is especially important for global memory accesses as global memory bandwidth is low compared to available on-chip bandwidths and arithmetic instruction throughput, so non-optimal global memory accesses generally have a high impact on performance.\n8.3.1. Data Transfer between Host and Device\uf0c1\n\nApplications should strive to minimize data transfer between the host and the device. One way to accomplish this is to move more code from the host to the device, even if that means running kernels that do not expose enough parallelism to execute on the device with full efficiency. Intermediate data structures may be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.\n\nAlso, because of the overhead associated with each transfer, batching many small transfers into a single large transfer always performs better than making each transfer separately.\n\nOn systems with a front-side bus, higher performance for data transfers between host and device is achieved by using page-locked host memory as described in Page-Locked Host Memory.\n\nIn addition, when using mapped page-locked memory (Mapped Memory), there is no need to allocate any device memory and explicitly copy data between device and host memory. Data transfers are implicitly performed each time the kernel accesses the mapped memory. For maximum performance, these memory accesses must be coalesced as with accesses to global memory (see Device Memory Accesses). Assuming that they are and that the mapped memory is read or written only once, using mapped page-locked memory instead of explicit copies between device and host memory can be a win for performance.\n\nOn integrated systems where device memory and host memory are physically the same, any copy between host and device memory is superfluous and mapped page-locked memory should be used instead. Applications may query a device is integrated by checking that the integrated device property (see Device Enumeration) is equal to 1.\n8.3.2. Device Memory Accesses\uf0c1\n\nAn instruction that accesses addressable memory (i.e., global, local, shared, constant, or texture memory) might need to be re-issued multiple times depending on the distribution of the memory addresses across the threads within the warp. How the distribution affects the instruction throughput this way is specific to each type of memory and described in the following sections. For example, for global memory, as a general rule, the more scattered the addresses are, the more reduced the throughput is.\n\nGlobal Memory\n\nGlobal memory resides in device memory and device memory is accessed via 32-, 64-, or 128-byte memory transactions. These memory transactions must be naturally aligned: Only the 32-, 64-, or 128-byte segments of device memory that are aligned to their size (i.e., whose first address is a multiple of their size) can be read or written by memory transactions.\n\nWhen a warp executes an instruction that accesses global memory, it coalesces the memory accesses of the threads within the warp into one or more of these memory transactions depending on the size of the word accessed by each thread and the distribution of the memory addresses across the threads. In general, the more transactions are necessary, the more unused words are transferred in addition to the words accessed by the threads, reducing the instruction throughput accordingly. For example, if a 32-byte memory transaction is generated for each thread\u2019s 4-byte access, throughput is divided by 8.\n\nHow many transactions are necessary and how much throughput is ultimately affected varies with the compute capability of the device. Compute Capability 5.x, Compute Capability 6.x, Compute Capability 7.x, Compute Capability 8.x, Compute Capability 9.0, Compute Capability 10.0, and Compute Capability 12.0 give more details on how global memory accesses are handled for various compute capabilities.\n\nTo maximize global memory throughput, it is therefore important to maximize coalescing by:\n\n    Following the most optimal access patterns based on Compute Capability 5.x, Compute Capability 6.x, Compute Capability 7.x, Compute Capability 8.x, Compute Capability 9.0, Compute Capability 10.0, and Compute Capability 12.0.\n\n    Using data types that meet the size and alignment requirement detailed in the section Size and Alignment Requirement below,\n\n    Padding data in some cases, for example, when accessing a two-dimensional array as described in the section Two-Dimensional Arrays below.\n\nSize and Alignment Requirement\n\nGlobal memory instructions support reading or writing words of size equal to 1, 2, 4, 8, or 16 bytes. Any access (via a variable or a pointer) to data residing in global memory compiles to a single global memory instruction if and only if the size of the data type is 1, 2, 4, 8, or 16 bytes and the data is naturally aligned (i.e., its address is a multiple of that size).\n\nIf this size and alignment requirement is not fulfilled, the access compiles to multiple instructions with interleaved access patterns that prevent these instructions from fully coalescing. It is therefore recommended to use types that meet this requirement for data that resides in global memory.\n\nThe alignment requirement is automatically fulfilled for the Built-in Vector Types.\n\nFor structures, the size and alignment requirements can be enforced by the compiler using the alignment specifiers__align__(8) or __align__(16), such as\n\nstruct __align__(8) {\n    float x;\n    float y;\n};\n\nor\n\nstruct __align__(16) {\n    float x;\n    float y;\n    float z;\n};\n\nAny address of a variable residing in global memory or returned by one of the memory allocation routines from the driver or runtime API is always aligned to at least 256 bytes.\n\nReading non-naturally aligned 8-byte or 16-byte words produces incorrect results (off by a few words), so special care must be taken to maintain alignment of the starting address of any value or array of values of these types. A typical case where this might be easily overlooked is when using some custom global memory allocation scheme, whereby the allocations of multiple arrays (with multiple calls to cudaMalloc() or cuMemAlloc()) is replaced by the allocation of a single large block of memory partitioned into multiple arrays, in which case the starting address of each array is offset from the block\u2019s starting address.\n\nTwo-Dimensional Arrays\n\nA common global memory access pattern is when each thread of index (tx,ty) uses the following address to access one element of a 2D array of width width, located at address BaseAddress of type type* (where type meets the requirement described in Maximize Utilization):\n\nBaseAddress + width * ty + tx\n\nFor these accesses to be fully coalesced, both the width of the thread block and the width of the array must be a multiple of the warp size.\n\nIn particular, this means that an array whose width is not a multiple of this size will be accessed much more efficiently if it is actually allocated with a width rounded up to the closest multiple of this size and its rows padded accordingly. The cudaMallocPitch() and cuMemAllocPitch() functions and associated memory copy functions described in the reference manual enable programmers to write non-hardware-dependent code to allocate arrays that conform to these constraints.\n\nLocal Memory\n\nLocal memory accesses only occur for some automatic variables as mentioned in Variable Memory Space Specifiers. Automatic variables that the compiler is likely to place in local memory are:\n\n    Arrays for which it cannot determine that they are indexed with constant quantities,\n\n    Large structures or arrays that would consume too much register space,\n\n    Any variable if the kernel uses more registers than available (this is also known as register spilling).\n\nInspection of the PTX assembly code (obtained by compiling with the -ptx or-keep option) will tell if a variable has been placed in local memory during the first compilation phases as it will be declared using the .local mnemonic and accessed using the ld.local and st.local mnemonics. Even if it has not, subsequent compilation phases might still decide otherwise though if they find it consumes too much register space for the targeted architecture: Inspection of the cubin object using cuobjdump will tell if this is the case. Also, the compiler reports total local memory usage per kernel (lmem) when compiling with the --ptxas-options=-v option. Note that some mathematical functions have implementation paths that might access local memory.\n\nThe local memory space resides in device memory, so local memory accesses have the same high latency and low bandwidth as global memory accesses and are subject to the same requirements for memory coalescing as described in Device Memory Accesses. Local memory is however organized such that consecutive 32-bit words are accessed by consecutive thread IDs. Accesses are therefore fully coalesced as long as all threads in a warp access the same relative address (for example, same index in an array variable, same member in a structure variable).\n\nOn devices of compute capability 5.x onwards, local memory accesses are always cached in L2 in the same way as global memory accesses (see Compute Capability 5.x and Compute Capability 6.x).\n\nShared Memory\n\nBecause it is on-chip, shared memory has much higher bandwidth and much lower latency than local or global memory.\n\nTo achieve high bandwidth, shared memory is divided into equally-sized memory modules, called banks, which can be accessed simultaneously. Any memory read or write request made of n addresses that fall in n distinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is n times as high as the bandwidth of a single module.\n\nHowever, if two addresses of a memory request fall in the same memory bank, there is a bank conflict and the access has to be serialized. The hardware splits a memory request with bank conflicts into as many separate conflict-free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests. If the number of separate memory requests is n, the initial memory request is said to cause n-way bank conflicts.\n\nTo get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so as to minimize bank conflicts. This is described in Compute Capability 5.x, Compute Capability 6.x, Compute Capability 7.x, Compute Capability 8.x, Compute Capability 9.0, Compute Capability 10.0, and Compute Capability 12.0 for devices of these compute capabilities respectively.\n\nConstant Memory\n\nThe constant memory space resides in device memory and is cached in the constant cache.\n\nA request is then split into as many separate requests as there are different memory addresses in the initial request, decreasing throughput by a factor equal to the number of separate requests.\n\nThe resulting requests are then serviced at the throughput of the constant cache in case of a cache hit, or at the throughput of device memory otherwise.\n\nTexture and Surface Memory\n\nThe texture and surface memory spaces reside in device memory and are cached in texture cache, so a texture fetch or surface read costs one memory read from device memory only on a cache miss, otherwise it just costs one read from texture cache. The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture or surface addresses that are close together in 2D will achieve best performance. Also, it is designed for streaming fetches with a constant latency; a cache hit reduces DRAM bandwidth demand but not fetch latency.\n\nReading device memory through texture or surface fetching present some benefits that can make it an advantageous alternative to reading device memory from global or constant memory:\n\n    If the memory reads do not follow the access patterns that global or constant memory reads must follow to get good performance, higher bandwidth can be achieved providing that there is locality in the texture fetches or surface reads;\n\n    Addressing calculations are performed outside the kernel by dedicated units;\n\n    Packed data may be broadcast to separate variables in a single operation;\n\n    8-bit and 16-bit integer input data may be optionally converted to 32 bit floating-point values in the range [0.0, 1.0] or [-1.0, 1.0] (see Texture Memory).\n\n8.4. Maximize Instruction Throughput\uf0c1\n\nSee the CUDA C++ Best Practices Guide for more details on optimizing instruction throughput.\n8.5. Minimize Memory Thrashing\uf0c1\n\nApplications that constantly allocate and free memory too often may find that the allocation calls tend to get slower over time up to a limit. This is typically expected due to the nature of releasing memory back to the operating system for its own use. For best performance in this regard, we recommend the following:\n\n    Try to size your allocation to the problem at hand. Don\u2019t try to allocate all available memory with cudaMalloc / cudaMallocHost / cuMemCreate, as this forces memory to be resident immediately and prevents other applications from being able to use that memory. This can put more pressure on operating system schedulers, or just prevent other applications using the same GPU from running entirely.\n\n    Try to allocate memory in appropriately sized allocations early in the application and allocations only when the application does not have any use for it. Reduce the number of cudaMalloc+cudaFree calls in the application, especially in performance-critical regions.\n\n    If an application cannot allocate enough device memory, consider falling back on other memory types such as cudaMallocHost or cudaMallocManaged, which may not be as performant, but will enable the application to make progress.\n\n    For platforms that support the feature, cudaMallocManaged allows for oversubscription, and with the correct cudaMemAdvise policies enabled, will allow the application to retain most if not all the performance of cudaMalloc. cudaMallocManaged also won\u2019t force an allocation to be resident until it is needed or prefetched, reducing the overall pressure on the operating system schedulers and better enabling multi-tenet use cases.\n\n9. CUDA-Enabled GPUs\uf0c1\n\nhttps://developer.nvidia.com/cuda-gpus lists all CUDA-enabled devices with their compute capability.\n\nThe compute capability, number of multiprocessors, clock frequency, total amount of device memory, and other properties can be queried using the runtime (see reference manual).\n10. C++ Language Extensions\uf0c1\n10.1. Function Execution Space Specifiers\uf0c1\n\nFunction execution space specifiers denote whether a function executes on the host or on the device and whether it is callable from the host or from the device.\n10.1.1. __global__\uf0c1\n\nThe __global__ execution space specifier declares a function as being a kernel. Such a function is:\n\n    Executed on the device,\n\n    Callable from the host,\n\n    Callable from the device for devices of compute capability 5.0 or higher (see CUDA Dynamic Parallelism for more details).\n\nA __global__ function must have void return type, and cannot be a member of a class.\n\nAny call to a __global__ function must specify its execution configuration as described in Execution Configuration.\n\nA call to a __global__ function is asynchronous, meaning it returns before the device has completed its execution.\n10.1.2. __device__\uf0c1\n\nThe __device__ execution space specifier declares a function that is:\n\n    Executed on the device,\n\n    Callable from the device only.\n\nThe __global__ and __device__ execution space specifiers cannot be used together.\n10.1.3. __host__\uf0c1\n\nThe __host__ execution space specifier declares a function that is:\n\n    Executed on the host,\n\n    Callable from the host only.\n\nIt is equivalent to declare a function with only the __host__ execution space specifier or to declare it without any of the __host__, __device__, or __global__ execution space specifier; in either case the function is compiled for the host only.\n\nThe __global__ and __host__ execution space specifiers cannot be used together.\n\nThe __device__ and __host__ execution space specifiers can be used together however, in which case the function is compiled for both the host and the device. The __CUDA_ARCH__ macro introduced in Application Compatibility can be used to differentiate code paths between host and device:\n\n__host__ __device__ func()\n{\n#if __CUDA_ARCH__ >= 800\n   // Device code path for compute capability 8.x\n#elif __CUDA_ARCH__ >= 700\n   // Device code path for compute capability 7.x\n#elif __CUDA_ARCH__ >= 600\n   // Device code path for compute capability 6.x\n#elif __CUDA_ARCH__ >= 500\n   // Device code path for compute capability 5.x\n#elif !defined(__CUDA_ARCH__)\n   // Host code path\n#endif\n}\n\n10.1.4. Undefined behavior\uf0c1\n\nA \u2018cross-execution space\u2019 call has undefined behavior when:\n\n    __CUDA_ARCH__ is defined, a call from within a __global__, __device__ or __host__ __device__ function to a __host__ function.\n\n    __CUDA_ARCH__ is undefined, a call from within a __host__ function to a __device__ function. 4\n\n10.1.5. __noinline__ and __forceinline__\uf0c1\n\nThe compiler inlines any __device__ function when deemed appropriate.\n\nThe __noinline__ function qualifier can be used as a hint for the compiler not to inline the function if possible.\n\nThe __forceinline__ function qualifier can be used to force the compiler to inline the function.\n\nThe __noinline__ and __forceinline__ function qualifiers cannot be used together, and neither function qualifier can be applied to an inline function.\n10.1.6. __inline_hint__\uf0c1\n\nThe __inline_hint__ qualifier enables more aggressive inlining in the compiler. Unlike __forceinline__, it does not imply that the function is inline. It can be used to improve inlining across modules when using LTO.\n\nNeither the __noinline__ nor the __forceinline__ function qualifier can be used with the __inline_hint__ function qualifier.\n10.2. Variable Memory Space Specifiers\uf0c1\n\nVariable memory space specifiers denote the memory location on the device of a variable.\n\nAn automatic variable declared in device code without any of the __device__, __shared__ and __constant__ memory space specifiers described in this section generally resides in a register. However in some cases the compiler might choose to place it in local memory, which can have adverse performance consequences as detailed in Device Memory Accesses.\n10.2.1. __device__\uf0c1\n\nThe __device__ memory space specifier declares a variable that resides on the device.\n\nAt most one of the other memory space specifiers defined in the next three sections may be used together with __device__ to further denote which memory space the variable belongs to. If none of them is present, the variable:\n\n    Resides in global memory space,\n\n    Has the lifetime of the CUDA context in which it is created,\n\n    Has a distinct object per device,\n\n    Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()).\n\n10.2.2. __constant__\uf0c1\n\nThe __constant__ memory space specifier, optionally used together with __device__, declares a variable that:\n\n    Resides in constant memory space,\n\n    Has the lifetime of the CUDA context in which it is created,\n\n    Has a distinct object per device,\n\n    Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()).\n\nThe behavior of modifying a constant from the host while there is a concurrent grid that access that constant at any point of this grid\u2019s lifetime is undefined.\n10.2.3. __shared__\uf0c1\n\nThe __shared__ memory space specifier, optionally used together with __device__, declares a variable that:\n\n    Resides in the shared memory space of a thread block,\n\n    Has the lifetime of the block,\n\n    Has a distinct object per block,\n\n    Is only accessible from all the threads within the block,\n\n    Does not have a constant address.\n\nWhen declaring a variable in shared memory as an external array such as\n\nextern __shared__ float shared[];\n\nthe size of the array is determined at launch time (see Execution Configuration). All variables declared in this fashion, start at the same address in memory, so that the layout of the variables in the array must be explicitly managed through offsets. For example, if one wants the equivalent of\n\nshort array0[128];\nfloat array1[64];\nint   array2[256];\n\nin dynamically allocated shared memory, one could declare and initialize the arrays the following way:\n\nextern __shared__ float array[];\n__device__ void func()      // __device__ or __global__ function\n{\n    short* array0 = (short*)array;\n    float* array1 = (float*)&array0[128];\n    int*   array2 =   (int*)&array1[64];\n}\n\nNote that pointers need to be aligned to the type they point to, so the following code, for example, does not work since array1 is not aligned to 4 bytes.\n\nextern __shared__ float array[];\n__device__ void func()      // __device__ or __global__ function\n{\n    short* array0 = (short*)array;\n    float* array1 = (float*)&array0[127];\n}\n\nAlignment requirements for the built-in vector types are listed in Table 7.\n10.2.4. __grid_constant__\uf0c1\n\nThe __grid_constant__ annotation for compute architectures greater or equal to 7.0 annotates a const-qualified __global__ function parameter of non-reference type that:\n\n    Has the lifetime of the grid,\n\n    Is private to the grid, i.e., the object is not accessible to host threads and threads from other grids, including sub-grids,\n\n    Has a distinct object per grid, i.e., all threads in the grid see the same address,\n\n    Is read-only, i.e., modifying a __grid_constant__ object or any of its sub-objects is undefined behavior, including mutable members.\n\nRequirements:\n\n    Kernel parameters annotated with __grid_constant__ must have const-qualified non-reference types.\n\n    All function declarations must match with respect to any __grid_constant_ parameters.\n\n    A function template specialization must match the primary template declaration with respect to any __grid_constant__ parameters.\n\n    A function template instantiation directive must match the primary template declaration with respect to any __grid_constant__ parameters.\n\nIf the address of a __global__ function parameter is taken, the compiler will ordinarily make a copy of the kernel parameter in thread local memory and use the address of the copy, to partially support C++ semantics, which allow each thread to modify its own local copy of function parameters. Annotating a __global__ function parameter with __grid_constant__ ensures that the compiler will not create a copy of the kernel parameter in thread local memory, but will instead use the generic address of the parameter itself. Avoiding the local copy may result in improved performance.\n\n__device__ void unknown_function(S const&);\n__global__ void kernel(const __grid_constant__ S s) {\n   s.x += threadIdx.x;  // Undefined Behavior: tried to modify read-only memory\n\n   // Compiler will _not_ create a per-thread thread local copy of \"s\":\n   unknown_function(s);\n}\n\n10.2.5. __managed__\uf0c1\n\nThe __managed__ memory space specifier, optionally used together with __device__, declares a variable that:\n\n    Can be referenced from both device and host code, for example, its address can be taken or it can be read or written directly from a device or host function.\n\n    Has the lifetime of an application.\n\nSee __managed__ Memory Space Specifier for more details.\n10.2.6. __restrict__\uf0c1\n\nnvcc supports restricted pointers via the __restrict__ keyword.\n\nRestricted pointers were introduced in C99 to alleviate the aliasing problem that exists in C-type languages, and which inhibits all kind of optimization from code re-ordering to common sub-expression elimination.\n\nHere is an example subject to the aliasing issue, where use of restricted pointer can help the compiler to reduce the number of instructions:\n\nvoid foo(const float* a,\n         const float* b,\n         float* c)\n{\n    c[0] = a[0] * b[0];\n    c[1] = a[0] * b[0];\n    c[2] = a[0] * b[0] * a[1];\n    c[3] = a[0] * a[1];\n    c[4] = a[0] * b[0];\n    c[5] = b[0];\n    ...\n}\n\nIn C-type languages, the pointers a, b, and c may be aliased, so any write through c could modify elements of a or b. This means that to guarantee functional correctness, the compiler cannot load a[0] and b[0] into registers, multiply them, and store the result to both c[0] and c[1], because the results would differ from the abstract execution model if, say, a[0] is really the same location as c[0]. So the compiler cannot take advantage of the common sub-expression. Likewise, the compiler cannot just reorder the computation of c[4] into the proximity of the computation of c[0] and c[1] because the preceding write to c[3] could change the inputs to the computation of c[4].\n\nBy making a, b, and c restricted pointers, the programmer asserts to the compiler that the pointers are in fact not aliased, which in this case means writes through c would never overwrite elements of a or b. This changes the function prototype as follows:\n\nvoid foo(const float* __restrict__ a,\n         const float* __restrict__ b,\n         float* __restrict__ c);\n\nNote that all pointer arguments need to be made restricted for the compiler optimizer to derive any benefit. With the __restrict__ keywords added, the compiler can now reorder and do common sub-expression elimination at will, while retaining functionality identical with the abstract execution model:\n\nvoid foo(const float* __restrict__ a,\n         const float* __restrict__ b,\n         float* __restrict__ c)\n{\n    float t0 = a[0];\n    float t1 = b[0];\n    float t2 = t0 * t1;\n    float t3 = a[1];\n    c[0] = t2;\n    c[1] = t2;\n    c[4] = t2;\n    c[2] = t2 * t3;\n    c[3] = t0 * t3;\n    c[5] = t1;\n    ...\n}\n\nThe effects here are a reduced number of memory accesses and reduced number of computations. This is balanced by an increase in register pressure due to \u201ccached\u201d loads and common sub-expressions.\n\nSince register pressure is a critical issue in many CUDA codes, use of restricted pointers can have negative performance impact on CUDA code, due to reduced occupancy.\n10.3. Built-in Vector Types\uf0c1\n10.3.1. char, short, int, long, longlong, float, double\uf0c1\n\nThese are vector types derived from the basic integer and floating-point types. They are structures and the 1st, 2nd, 3rd, and 4th components are accessible through the fields x, y, z, and w, respectively. They all come with a constructor function of the form make_<type name>; for example,\n\nint2 make_int2(int x, int y);\n\nwhich creates a vector of type int2 with value(x, y).\n\nThe alignment requirements of the vector types are detailed in Table 7.\nTable 7 Alignment Requirements\uf0c1\n\nType\n\t\n\nAlignment\n\nchar1, uchar1\n\t\n\n1\n\nchar2, uchar2\n\t\n\n2\n\nchar3, uchar3\n\t\n\n1\n\nchar4, uchar4\n\t\n\n4\n\nshort1, ushort1\n\t\n\n2\n\nshort2, ushort2\n\t\n\n4\n\nshort3, ushort3\n\t\n\n2\n\nshort4, ushort4\n\t\n\n8\n\nint1, uint1\n\t\n\n4\n\nint2, uint2\n\t\n\n8\n\nint3, uint3\n\t\n\n4\n\nint4, uint4\n\t\n\n16\n\nlong1, ulong1\n\t\n\n4 if sizeof(long) is equal to sizeof(int) 8, otherwise\n\nlong2, ulong2\n\t\n\n8 if sizeof(long) is equal to sizeof(int), 16, otherwise\n\nlong3, ulong3\n\t\n\n4 if sizeof(long) is equal to sizeof(int), 8, otherwise\n\nlong4 3\n\t\n\n16\n\nlong4_16a\n\nlong4_32a\n\t\n\n32\n\nulong4 3\n\t\n\n16\n\nulong4_16a\n\nulong4_32a\n\t\n\n32\n\nlonglong1, ulonglong1\n\t\n\n8\n\nlonglong2, ulonglong2\n\t\n\n16\n\nlonglong3, ulonglong3\n\t\n\n8\n\nlonglong4 3\n\t\n\n16\n\nlonglong4_16a\n\nlonglong4_32a\n\t\n\n32\n\nulonglong4 3\n\t\n\n16\n\nulonglong4_16a\n\nulonglong4_32a\n\t\n\n32\n\nfloat1\n\t\n\n4\n\nfloat2\n\t\n\n8\n\nfloat3\n\t\n\n4\n\nfloat4\n\t\n\n16\n\ndouble1\n\t\n\n8\n\ndouble2\n\t\n\n16\n\ndouble3\n\t\n\n8\n\ndouble4 3\n\t\n\n16\n\ndouble4_16a\n\ndouble4_32a\n\t\n\n32\n\n3(1,2,3,4,5)\n\n    This vector type was deprecated in CUDA Toolkit 13.0. Please use the _16a or _32a variant instead, depending on your alignment requirements.\n\n10.3.2. dim3\uf0c1\n\nThis type is an integer vector type based on uint3 that is used to specify dimensions. When defining a variable of type dim3, any component left unspecified is initialized to 1.\n10.4. Built-in Variables\uf0c1\n\nBuilt-in variables specify the grid and block dimensions and the block and thread indices. They are only valid within functions that are executed on the device.\n10.4.1. gridDim\uf0c1\n\nThis variable is of type dim3 (see dim3) and contains the dimensions of the grid.\n10.4.2. blockIdx\uf0c1\n\nThis variable is of type uint3 (see char, short, int, long, longlong, float, double) and contains the block index within the grid.\n10.4.3. blockDim\uf0c1\n\nThis variable is of type dim3 (see dim3) and contains the dimensions of the block.\n10.4.4. threadIdx\uf0c1\n\nThis variable is of type uint3 (see char, short, int, long, longlong, float, double) and contains the thread index within the block.\n10.4.5. warpSize\uf0c1\n\nThis variable is of type int and contains the warp size in threads (see SIMT Architecture for the definition of a warp).\n10.5. Memory Fence Functions\uf0c1\n\nThe CUDA programming model assumes a device with a weakly-ordered memory model, that is the order in which a CUDA thread writes data to shared memory, global memory, page-locked host memory, or the memory of a peer device is not necessarily the order in which the data is observed being written by another CUDA or host thread. It is undefined behavior for two threads to read from or write to the same memory location without synchronization.\n\nIn the following example, thread 1 executes writeXY(), while thread 2 executes readXY().\n\n__device__ int X = 1, Y = 2;\n\n__device__ void writeXY()\n{\n    X = 10;\n    Y = 20;\n}\n\n__device__ void readXY()\n{\n    int B = Y;\n    int A = X;\n}\n\nThe two threads read and write from the same memory locations X and Y simultaneously. Any data-race is undefined behavior, and has no defined semantics. The resulting values for A and B can be anything.\n\nMemory fence functions can be used to enforce a sequentially-consistent ordering on memory accesses. The memory fence functions differ in the scope in which the orderings are enforced but they are independent of the accessed memory space (shared memory, global memory, page-locked host memory, and the memory of a peer device).\n\nvoid __threadfence_block();\n\nis equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_block) and ensures that:\n\n    All writes to all memory made by the calling thread before the call to __threadfence_block() are observed by all threads in the block of the calling thread as occurring before all writes to all memory made by the calling thread after the call to __threadfence_block();\n\n    All reads from all memory made by the calling thread before the call to __threadfence_block() are ordered before all reads from all memory made by the calling thread after the call to __threadfence_block().\n\nvoid __threadfence();\n\nis equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_device) and ensures that no writes to all memory made by the calling thread after the call to __threadfence() are observed by any thread in the device as occurring before any write to all memory made by the calling thread before the call to __threadfence().\n\nvoid __threadfence_system();\n\nis equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system) and ensures that all writes to all memory made by the calling thread before the call to __threadfence_system() are observed by all threads in the device, host threads, and all threads in peer devices as occurring before all writes to all memory made by the calling thread after the call to __threadfence_system().\n\n__threadfence_system() is only supported by devices of compute capability 2.x and higher.\n\nIn the previous code sample, we can insert fences in the codes as follows:\n\n__device__ int X = 1, Y = 2;\n\n__device__ void writeXY()\n{\n    X = 10;\n    __threadfence();\n    Y = 20;\n}\n\n__device__ void readXY()\n{\n    int B = Y;\n    __threadfence();\n    int A = X;\n}\n\nFor this code, the following outcomes can be observed:\n\n    A equal to 1 and B equal to 2,\n\n    A equal to 10 and B equal to 2,\n\n    A equal to 10 and B equal to 20.\n\nThe fourth outcome is not possible, because the first write must be visible before the second write. If thread 1 and 2 belong to the same block, it is enough to use __threadfence_block(). If thread 1 and 2 do not belong to the same block, __threadfence() must be used if they are CUDA threads from the same device and __threadfence_system() must be used if they are CUDA threads from two different devices.\n\nA common use case is when threads consume some data produced by other threads as illustrated by the following code sample of a kernel that computes the sum of an array of N numbers in one call. Each block first sums a subset of the array and stores the result in global memory. When all blocks are done, the last block done reads each of these partial sums from global memory and sums them to obtain the final result. In order to determine which block is finished last, each block atomically increments a counter to signal that it is done with computing and storing its partial sum (see Atomic Functions about atomic functions). The last block is the one that receives the counter value equal to gridDim.x-1. If no fence is placed between storing the partial sum and incrementing the counter, the counter might increment before the partial sum is stored and therefore, might reach gridDim.x-1 and let the last block start reading partial sums before they have been actually updated in memory.\n\nMemory fence functions only affect the ordering of memory operations by a thread; they do not, by themselves, ensure that these memory operations are visible to other threads (like __syncthreads() does for threads within a block; see Synchronization Functions). In the code sample below, the visibility of memory operations on the result variable is ensured by declaring it as volatile (see Volatile Qualifier).\n\n__device__ unsigned int count = 0;\n__shared__ bool isLastBlockDone;\n__global__ void sum(const float* array, unsigned int N,\n                    volatile float* result)\n{\n    // Each block sums a subset of the input array.\n    float partialSum = calculatePartialSum(array, N);\n\n    if (threadIdx.x == 0) {\n\n        // Thread 0 of each block stores the partial sum\n        // to global memory. The compiler will use\n        // a store operation that bypasses the L1 cache\n        // since the \"result\" variable is declared as\n        // volatile. This ensures that the threads of\n        // the last block will read the correct partial\n        // sums computed by all other blocks.\n        result[blockIdx.x] = partialSum;\n\n        // Thread 0 makes sure that the incrementing\n        // of the \"count\" variable is only performed after\n        // the partial sum has been written to global memory.\n        __threadfence();\n\n        // Thread 0 signals that it is done.\n        unsigned int value = atomicInc(&count, gridDim.x);\n\n        // Thread 0 determines if its block is the last\n        // block to be done.\n        isLastBlockDone = (value == (gridDim.x - 1));\n    }\n\n    // Synchronize to make sure that each thread reads\n    // the correct value of isLastBlockDone.\n    __syncthreads();\n\n    if (isLastBlockDone) {\n\n        // The last block sums the partial sums\n        // stored in result[0 .. gridDim.x-1]\n        float totalSum = calculateTotalSum(result);\n\n        if (threadIdx.x == 0) {\n\n            // Thread 0 of last block stores the total sum\n            // to global memory and resets the count\n            // variable, so that the next kernel call\n            // works properly.\n            result[0] = totalSum;\n            count = 0;\n        }\n    }\n}\n\n10.6. Synchronization Functions\uf0c1\n\nvoid __syncthreads();\n\nwaits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to __syncthreads() are visible to all threads in the block.\n\n__syncthreads() is used to coordinate communication between the threads of the same block. When some threads within a block access the same addresses in shared or global memory, there are potential read-after-write, write-after-read, or write-after-write hazards for some of these memory accesses. These data hazards can be avoided by synchronizing threads in-between these accesses.\n\n__syncthreads() is allowed in conditional code but only if the conditional evaluates identically across the entire thread block, otherwise the code execution is likely to hang or produce unintended side effects.\n\nDevices of compute capability 2.x and higher support three variations of __syncthreads() described below.\n\nint __syncthreads_count(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non-zero.\n\nint __syncthreads_and(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for all of them.\n\nint __syncthreads_or(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for any of them.\n\nvoid __syncwarp(unsigned mask=0xffffffff);\n\nwill cause the executing thread to wait until all warp lanes named in mask have executed a __syncwarp() (with the same mask) before resuming execution. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute a corresponding __syncwarp() with the same mask, or the result is undefined.\n\nExecuting __syncwarp() guarantees memory ordering among threads participating in the barrier. Thus, threads within a warp that wish to communicate via memory can store to memory, execute __syncwarp(), and then safely read values stored by other threads in the warp.\n\nNote\n\nFor .target sm_6x or below, all threads in mask must execute the same __syncwarp() in convergence, and the union of all values in mask must be equal to the active mask. Otherwise, the behavior is undefined.\n10.7. Mathematical Functions\uf0c1\n\nThe reference manual lists all C/C++ standard library mathematical functions that are supported in device code and all intrinsic functions that are only supported in device code.\n\nMathematical Functions provides accuracy information for some of these functions when relevant.\n10.8. Texture Functions\uf0c1\n\nTexture objects are described in Texture Object API.\n\nTexture fetching is described in Texture Fetching.\n10.8.1. Texture Object API\uf0c1\n10.8.1.1. tex1Dfetch()\uf0c1\n\ntemplate<class T>\nT tex1Dfetch(cudaTextureObject_t texObj, int x);\n\nfetches from the region of linear memory specified by the one-dimensional texture object texObj using integer texture coordinate x. tex1Dfetch() only works with non-normalized coordinates, so only the border and clamp addressing modes are supported. It does not perform any texture filtering. For integer types, it may optionally promote the integer to single-precision floating point.\n10.8.1.2. tex1D()\uf0c1\n\ntemplate<class T>\nT tex1D(cudaTextureObject_t texObj, float x);\n\nfetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x.\n10.8.1.3. tex1DLod()\uf0c1\n\ntemplate<class T>\nT tex1DLod(cudaTextureObject_t texObj, float x, float level);\n\nfetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x at the level-of-detail level.\n10.8.1.4. tex1DGrad()\uf0c1\n\ntemplate<class T>\nT tex1DGrad(cudaTextureObject_t texObj, float x, float dx, float dy);\n\nfetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x. The level-of-detail is derived from the X-gradient dx and Y-gradient dy.\n10.8.1.5. tex2D()\uf0c1\n\ntemplate<class T>\nT tex2D(cudaTextureObject_t texObj, float x, float y);\n\nfetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object texObj using texture coordinate (x,y).\n10.8.1.6. tex2D() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex2D(cudaTextureObject_t texObj, float x, float y, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y). Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.7. tex2Dgather()\uf0c1\n\ntemplate<class T>\nT tex2Dgather(cudaTextureObject_t texObj,\n              float x, float y, int comp = 0);\n\nfetches from the CUDA array specified by the 2D texture object texObj using texture coordinates x and y and the comp parameter as described in Texture Gather.\n10.8.1.8. tex2Dgather() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex2Dgather(cudaTextureObject_t texObj,\n            float x, float y, bool* isResident, int comp = 0);\n\nfetches from the CUDA array specified by the 2D texture object texObj using texture coordinates x and y and the comp parameter as described in Texture Gather. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.9. tex2DGrad()\uf0c1\n\ntemplate<class T>\nT tex2DGrad(cudaTextureObject_t texObj, float x, float y,\n            float2 dx, float2 dy);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y). The level-of-detail is derived from the dx and dy gradients.\n10.8.1.10. tex2DGrad() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex2DGrad(cudaTextureObject_t texObj, float x, float y,\n        float2 dx, float2 dy, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y). The level-of-detail is derived from the dx and dy gradients. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.11. tex2DLod()\uf0c1\n\ntemplate<class T>\ntex2DLod(cudaTextureObject_t texObj, float x, float y, float level);\n\nfetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object texObj using texture coordinate (x,y) at level-of-detail level.\n10.8.1.12. tex2DLod() for sparse CUDA arrays\uf0c1\n\n        template<class T>\ntex2DLod(cudaTextureObject_t texObj, float x, float y, float level, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y) at level-of-detail level. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.13. tex3D()\uf0c1\n\ntemplate<class T>\nT tex3D(cudaTextureObject_t texObj, float x, float y, float z);\n\nfetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z).\n10.8.1.14. tex3D() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex3D(cudaTextureObject_t texObj, float x, float y, float z, bool* isResident);\n\nfetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z). Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.15. tex3DLod()\uf0c1\n\ntemplate<class T>\nT tex3DLod(cudaTextureObject_t texObj, float x, float y, float z, float level);\n\nfetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at level-of-detail level.\n10.8.1.16. tex3DLod() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex3DLod(cudaTextureObject_t texObj, float x, float y, float z, float level, bool* isResident);\n\nfetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at level-of-detail level. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.17. tex3DGrad()\uf0c1\n\ntemplate<class T>\nT tex3DGrad(cudaTextureObject_t texObj, float x, float y, float z,\n            float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at a level-of-detail derived from the X and Y gradients dx and dy.\n10.8.1.18. tex3DGrad() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex3DGrad(cudaTextureObject_t texObj, float x, float y, float z,\n        float4 dx, float4 dy, bool* isResident);\n\nfetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at a level-of-detail derived from the X and Y gradients dx and dy. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.19. tex1DLayered()\uf0c1\n\ntemplate<class T>\nT tex1DLayered(cudaTextureObject_t texObj, float x, int layer);\n\nfetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x and index layer, as described in Layered Textures.\n10.8.1.20. tex1DLayeredLod()\uf0c1\n\ntemplate<class T>\nT tex1DLayeredLod(cudaTextureObject_t texObj, float x, int layer, float level);\n\nfetches from the CUDA array specified by the one-dimensional Layered Textures at layer layer using texture coordinate x and level-of-detail level.\n10.8.1.21. tex1DLayeredGrad()\uf0c1\n\ntemplate<class T>\nT tex1DLayeredGrad(cudaTextureObject_t texObj, float x, int layer,\n                   float dx, float dy);\n\nfetches from the CUDA array specified by the one-dimensional layered texture at layer layer using texture coordinate x and a level-of-detail derived from the dx and dy gradients.\n10.8.1.22. tex2DLayered()\uf0c1\n\ntemplate<class T>\nT tex2DLayered(cudaTextureObject_t texObj,\n               float x, float y, int layer);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y) and index layer, as described in Layered Textures.\n10.8.1.23. tex2DLayered() for Sparse CUDA Arrays\uf0c1\n\n                template<class T>\nT tex2DLayered(cudaTextureObject_t texObj,\n            float x, float y, int layer, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y) and index layer, as described in Layered Textures. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.24. tex2DLayeredLod()\uf0c1\n\ntemplate<class T>\nT tex2DLayeredLod(cudaTextureObject_t texObj, float x, float y, int layer,\n                  float level);\n\nfetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y).\n10.8.1.25. tex2DLayeredLod() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex2DLayeredLod(cudaTextureObject_t texObj, float x, float y, int layer,\n                float level, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y). Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.26. tex2DLayeredGrad()\uf0c1\n\ntemplate<class T>\nT tex2DLayeredGrad(cudaTextureObject_t texObj, float x, float y, int layer,\n                   float2 dx, float2 dy);\n\nfetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y) and a level-of-detail derived from the dx and dy gradients.\n10.8.1.27. tex2DLayeredGrad() for sparse CUDA arrays\uf0c1\n\n                template<class T>\nT tex2DLayeredGrad(cudaTextureObject_t texObj, float x, float y, int layer,\n                float2 dx, float2 dy, bool* isResident);\n\nfetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y) and a level-of-detail derived from the dx and dy gradients. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n10.8.1.28. texCubemap()\uf0c1\n\ntemplate<class T>\nT texCubemap(cudaTextureObject_t texObj, float x, float y, float z);\n\nfetches the CUDA array specified by the cubemap texture object texObj using texture coordinate (x,y,z), as described in Cubemap Textures.\n10.8.1.29. texCubemapGrad()\uf0c1\n\ntemplate<class T>\nT texCubemapGrad(cudaTextureObject_t texObj, float x, float, y, float z,\n                float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the cubemap texture object texObj using texture coordinate (x,y,z) as described in Cubemap Textures. The level-of-detail used is derived from the dx and dy gradients.\n10.8.1.30. texCubemapLod()\uf0c1\n\ntemplate<class T>\nT texCubemapLod(cudaTextureObject_t texObj, float x, float, y, float z,\n                float level);\n\nfetches from the CUDA array specified by the cubemap texture object texObj using texture coordinate (x,y,z) as described in Cubemap Textures. The level-of-detail used is given by level.\n10.8.1.31. texCubemapLayered()\uf0c1\n\ntemplate<class T>\nT texCubemapLayered(cudaTextureObject_t texObj,\n                    float x, float y, float z, int layer);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinates (x,y,z), and index layer, as described in Cubemap Layered Textures.\n10.8.1.32. texCubemapLayeredGrad()\uf0c1\n\ntemplate<class T>\nT texCubemapLayeredGrad(cudaTextureObject_t texObj, float x, float y, float z,\n                       int layer, float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinate (x,y,z) and index layer, as described in Cubemap Layered Textures, at level-of-detail derived from the dx and dy gradients.\n10.8.1.33. texCubemapLayeredLod()\uf0c1\n\ntemplate<class T>\nT texCubemapLayeredLod(cudaTextureObject_t texObj, float x, float y, float z,\n                       int layer, float level);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinate (x,y,z) and index layer, as described in Cubemap Layered Textures, at level-of-detail level level.\n10.9. Surface Functions\uf0c1\n\nSurface functions are only supported by devices of compute capability 2.0 and higher.\n\nSurface objects are described in described in Surface Object API.\n\nIn the sections below, boundaryMode specifies the boundary mode, that is how out-of-range surface coordinates are handled; it is equal to either cudaBoundaryModeClamp, in which case out-of-range coordinates are clamped to the valid range, or cudaBoundaryModeZero, in which case out-of-range reads return zero and out-of-range writes are ignored, or cudaBoundaryModeTrap, in which case out-of-range accesses cause the kernel execution to fail.\n10.9.1. Surface Object API\uf0c1\n10.9.1.1. surf1Dread()\uf0c1\n\ntemplate<class T>\nT surf1Dread(cudaSurfaceObject_t surfObj, int x,\n               boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the one-dimensional surface object surfObj using byte coordinate x.\n10.9.1.2. surf1Dwrite\uf0c1\n\ntemplate<class T>\nvoid surf1Dwrite(T data,\n                  cudaSurfaceObject_t surfObj,\n                  int x,\n                  boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the one-dimensional surface object surfObj at byte coordinate x.\n10.9.1.3. surf2Dread()\uf0c1\n\ntemplate<class T>\nT surf2Dread(cudaSurfaceObject_t surfObj,\n              int x, int y,\n              boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surf2Dread(T* data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the two-dimensional surface object surfObj using byte coordinates x and y.\n10.9.1.4. surf2Dwrite()\uf0c1\n\ntemplate<class T>\nvoid surf2Dwrite(T data,\n                  cudaSurfaceObject_t surfObj,\n                  int x, int y,\n                  boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the two-dimensional surface object surfObj at byte coordinate x and y.\n10.9.1.5. surf3Dread()\uf0c1\n\ntemplate<class T>\nT surf3Dread(cudaSurfaceObject_t surfObj,\n              int x, int y, int z,\n              boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surf3Dread(T* data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y, int z,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the three-dimensional surface object surfObj using byte coordinates x, y, and z.\n10.9.1.6. surf3Dwrite()\uf0c1\n\ntemplate<class T>\nvoid surf3Dwrite(T data,\n                  cudaSurfaceObject_t surfObj,\n                  int x, int y, int z,\n                  boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the three-dimensional object surfObj at byte coordinate x, y, and z.\n10.9.1.7. surf1DLayeredread()\uf0c1\n\ntemplate<class T>\nT surf1DLayeredread(\n                 cudaSurfaceObject_t surfObj,\n                 int x, int layer,\n                 boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surf1DLayeredread(T data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int layer,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the one-dimensional layered surface object surfObj using byte coordinate x and index layer.\n10.9.1.8. surf1DLayeredwrite()\uf0c1\n\ntemplate<class Type>\nvoid surf1DLayeredwrite(T data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int layer,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the two-dimensional layered surface object surfObj at byte coordinate x and index layer.\n10.9.1.9. surf2DLayeredread()\uf0c1\n\ntemplate<class T>\nT surf2DLayeredread(\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y, int layer,\n                 boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surf2DLayeredread(T data,\n                         cudaSurfaceObject_t surfObj,\n                         int x, int y, int layer,\n                         boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the two-dimensional layered surface object surfObj using byte coordinate x and y, and index layer.\n10.9.1.10. surf2DLayeredwrite()\uf0c1\n\ntemplate<class T>\nvoid surf2DLayeredwrite(T data,\n                          cudaSurfaceObject_t surfObj,\n                          int x, int y, int layer,\n                          boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the one-dimensional layered surface object surfObj at byte coordinate x and y, and index layer.\n10.9.1.11. surfCubemapread()\uf0c1\n\ntemplate<class T>\nT surfCubemapread(\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y, int face,\n                 boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surfCubemapread(T data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y, int face,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the cubemap surface object surfObj using byte coordinate x and y, and face index face.\n10.9.1.12. surfCubemapwrite()\uf0c1\n\ntemplate<class T>\nvoid surfCubemapwrite(T data,\n                 cudaSurfaceObject_t surfObj,\n                 int x, int y, int face,\n                 boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the cubemap object surfObj at byte coordinate x and y, and face index face.\n10.9.1.13. surfCubemapLayeredread()\uf0c1\n\ntemplate<class T>\nT surfCubemapLayeredread(\n             cudaSurfaceObject_t surfObj,\n             int x, int y, int layerFace,\n             boundaryMode = cudaBoundaryModeTrap);\ntemplate<class T>\nvoid surfCubemapLayeredread(T data,\n             cudaSurfaceObject_t surfObj,\n             int x, int y, int layerFace,\n             boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the cubemap layered surface object surfObj using byte coordinate x and y, and index layerFace.\n10.9.1.14. surfCubemapLayeredwrite()\uf0c1\n\ntemplate<class T>\nvoid surfCubemapLayeredwrite(T data,\n             cudaSurfaceObject_t surfObj,\n             int x, int y, int layerFace,\n             boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the cubemap layered object surfObj at byte coordinate x and y, and index layerFace.\n10.10. Read-Only Data Cache Load Function\uf0c1\n\nThe read-only data cache load function is only supported by devices of compute capability 5.0 and higher.\n\nT __ldg(const T* address);\n\nreturns the data of type T located at address address, where T is char, signed char, short, int, long, long longunsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16.h header included, T can be __half or __half2. Similarly, with the cuda_bf16.h header included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is cached in the read-only data cache (see Global Memory).\n10.11. Load Functions Using Cache Hints\uf0c1\n\nThese load functions are only supported by devices of compute capability 5.0 and higher.\n\nT __ldcg(const T* address);\nT __ldca(const T* address);\nT __ldcs(const T* address);\nT __ldlu(const T* address);\nT __ldcv(const T* address);\n\nreturns the data of type T located at address address, where T is char, signed char, short, int, long, long longunsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16.h header included, T can be __half or __half2. Similarly, with the cuda_bf16.h header included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is using the corresponding cache operator (see PTX ISA)\n10.12. Store Functions Using Cache Hints\uf0c1\n\nThese store functions are only supported by devices of compute capability 5.0 and higher.\n\nvoid __stwb(T* address, T value);\nvoid __stcg(T* address, T value);\nvoid __stcs(T* address, T value);\nvoid __stwt(T* address, T value);\n\nstores the value argument of type T to the location at address address, where T is char, signed char, short, int, long, long longunsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16.h header included, T can be __half or __half2. Similarly, with the cuda_bf16.h header included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is using the corresponding cache operator (see PTX ISA )\n10.13. Time Function\uf0c1\n\nclock_t clock();\nlong long int clock64();\n\nwhen executed in device code, returns the value of a per-multiprocessor counter that is incremented every clock cycle. Sampling this counter at the beginning and at the end of a kernel, taking the difference of the two samples, and recording the result per thread provides a measure for each thread of the number of clock cycles taken by the device to completely execute the thread, but not of the number of clock cycles the device actually spent executing thread instructions. The former number is greater than the latter since threads are time sliced.\n10.14. Atomic Functions\uf0c1\n\nAn atomic function performs a read-modify-write atomic operation on one 32-bit, 64-bit, or 128-bit word residing in global or shared memory. In the case of float2 or float4, the read-modify-write operation is performed on each element of the vector residing in global memory. For example, atomicAdd() reads a word at some address in global or shared memory, adds a number to it, and writes the result back to the same address. Atomic functions can only be used in device functions.\n\nThe atomic functions described in this section have ordering cuda::memory_order_relaxed and are only atomic at a particular scope:\n\n    Atomic APIs with _system suffix (example: atomicAdd_system) are atomic at scope cuda::thread_scope_system if they meet particular conditions.\n\n    Atomic APIs without a suffix (example: atomicAdd) are atomic at scope cuda::thread_scope_device.\n\n    Atomic APIs with _block suffix (example: atomicAdd_block) are atomic at scope cuda::thread_scope_block.\n\nIn the following example both the CPU and the GPU atomically update an integer value at address addr:\n\n__global__ void mykernel(int *addr) {\n  atomicAdd_system(addr, 10);       // only available on devices with compute capability 6.x\n}\n\nvoid foo() {\n  int *addr;\n  cudaMallocManaged(&addr, 4);\n  *addr = 0;\n\n   mykernel<<<...>>>(addr);\n   __sync_fetch_and_add(addr, 10);  // CPU atomic operation\n}\n\nNote that any atomic operation can be implemented based on atomicCAS() (Compare And Swap). For example, atomicAdd() for double-precision floating-point numbers is not available on devices with compute capability lower than 6.0 but it can be implemented as follows:\n\n#if __CUDA_ARCH__ < 600\n__device__ double atomicAdd(double* address, double val)\n{\n    unsigned long long int* address_as_ull =\n                              (unsigned long long int*)address;\n    unsigned long long int old = *address_as_ull, assumed;\n\n    do {\n        assumed = old;\n        old = atomicCAS(address_as_ull, assumed,\n                        __double_as_longlong(val +\n                               __longlong_as_double(assumed)));\n\n    // Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN)\n    } while (assumed != old);\n\n    return __longlong_as_double(old);\n}\n#endif\n\nThere are system-wide and block-wide variants of the following device-wide atomic APIs, with the following exceptions:\n\n    Devices with compute capability less than 6.0 only support device-wide atomic operations,\n\n    Tegra devices with compute capability less than 7.2 do not support system-wide atomic operations.\n\nCUDA 12.8 and later support CUDA compiler builtin functions for atomic operations with memory order and thread scope. We follows the GNU\u2019s atomic built-in function signature with an extra argument of thread scope. We use the following atomic operation memory orders and thread scopes:\n\nenum {\n   __NV_ATOMIC_RELAXED,\n   __NV_ATOMIC_CONSUME,\n   __NV_ATOMIC_ACQUIRE,\n   __NV_ATOMIC_RELEASE,\n   __NV_ATOMIC_ACQ_REL,\n   __NV_ATOMIC_SEQ_CST\n};\n\nenum {\n   __NV_THREAD_SCOPE_THREAD,\n   __NV_THREAD_SCOPE_BLOCK,\n   __NV_THREAD_SCOPE_CLUSTER,\n   __NV_THREAD_SCOPE_DEVICE,\n   __NV_THREAD_SCOPE_SYSTEM\n};\n\nExample:\n\n__device__ T __nv_atomic_load_n(T* ptr, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nT can be any integral type that is size of 1, 2, 4, 8 and 16 bytes.\n\nThese atomic functions cannot operate on local memory. For example:\n\n__device__ void foo() {\n   int a = 1; // defined in local memory\n   int b;\n   __nv_atomic_load(&a, &b, __NV_ATOMIC_RELAXED, __NV_THREAD_SCOPE_SYSTEM);\n}\n\nThese functions must only be used within the block scope of a __device__ function. For example:\n\n__device__ void foo() {\n   __shared__ unsigned int u1 = 1;\n   __shared__ unsigned int u2 = 2;\n   __nv_atomic_load(&u1, &u2, __NV_ATOMIC_RELAXED, __NV_THREAD_SCOPE_SYSTEM);\n}\n\nAnd these functions\u2019 address cannot be taken. Here are three unsupported examples:\n\n// Not permitted to be used in a host function\n__host__ void bar() {\n   __shared__ unsigned int u1 = 1;\n   __shared__ unsigned int u2 = 2;\n   __nv_atomic_load(&u1, &u2, __NV_ATOMIC_RELAXED, __NV_THREAD_SCOPE_SYSTEM);\n}\n\n// Not permitted to be used as a template default argument.\n// The function address cannot be taken.\ntemplate<void *F = __nv_atomic_load_n>\nclass X {\n   void *f = F;\n};\n\n// Not permitted to be called in a constructor initialization list.\nclass Y {\n   int a;\npublic:\n   __device__ Y(int *b): a(__nv_atomic_load_n(b, __NV_ATOMIC_RELAXED)) {}\n};\n\nThe memory order corresponds to C++ standard atomic operation\u2019s memory order. And for thread scope, we follows cuda::thread_scope\u2019s definition.\n\n__NV_ATOMIC_CONSUME memory order is currently implemented using stronger __NV_ATOMIC_ACQUIRE memory order.\n\n__NV_THREAD_SCOPE_THREAD thread scope is currently implemented using wider __NV_THREAD_SCOPE_BLOCK thread scope.\n\nFor the supported data types, please refer to the corresponding section of different atomic operations.\n10.14.1. Arithmetic Functions\uf0c1\n10.14.1.1. atomicAdd()\uf0c1\n\nint atomicAdd(int* address, int val);\nunsigned int atomicAdd(unsigned int* address,\n                       unsigned int val);\nunsigned long long int atomicAdd(unsigned long long int* address,\n                                 unsigned long long int val);\nfloat atomicAdd(float* address, float val);\ndouble atomicAdd(double* address, double val);\n__half2 atomicAdd(__half2 *address, __half2 val);\n__half atomicAdd(__half *address, __half val);\n__nv_bfloat162 atomicAdd(__nv_bfloat162 *address, __nv_bfloat162 val);\n__nv_bfloat16 atomicAdd(__nv_bfloat16 *address, __nv_bfloat16 val);\nfloat2 atomicAdd(float2* address, float2 val);\nfloat4 atomicAdd(float4* address, float4 val);\n\nreads the 16-bit, 32-bit or 64-bit old located at the address address in global or shared memory, computes (old + val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 32-bit floating-point version of atomicAdd() is only supported by devices of compute capability 2.x and higher.\n\nThe 64-bit floating-point version of atomicAdd() is only supported by devices of compute capability 6.x and higher.\n\nThe 32-bit __half2 floating-point version of atomicAdd() is only supported by devices of compute capability 6.x and higher. The atomicity of the __half2 or __nv_bfloat162 add operation is guaranteed separately for each of the two __half or __nv_bfloat16 elements; the entire __half2 or __nv_bfloat162 is not guaranteed to be atomic as a single 32-bit access.\n\nThe float2 and float4 floating-point vector versions of atomicAdd() are only supported by devices of compute capability 9.x and higher. The atomicity of the float2 or float4 add operation is guaranteed separately for each of the two or four float elements; the entire float2 or float4 is not guaranteed to be atomic as a single 64-bit or 128-bit access.\n\nThe 16-bit __half floating-point version of atomicAdd() is only supported by devices of compute capability 7.x and higher.\n\nThe 16-bit __nv_bfloat16 floating-point version of atomicAdd() is only supported by devices of compute capability 8.x and higher.\n\nThe float2 and float4 floating-point vector versions of atomicAdd() are only supported by devices of compute capability 9.x and higher.\n\nThe float2 and float4 floating-point vector versions of atomicAdd() are only supported for global memory addresses.\n10.14.1.2. atomicSub()\uf0c1\n\nint atomicSub(int* address, int val);\nunsigned int atomicSub(unsigned int* address,\n                       unsigned int val);\n\nreads the 32-bit word old located at the address address in global or shared memory, computes (old - val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n10.14.1.3. atomicExch()\uf0c1\n\nint atomicExch(int* address, int val);\nunsigned int atomicExch(unsigned int* address,\n                        unsigned int val);\nunsigned long long int atomicExch(unsigned long long int* address,\n                                  unsigned long long int val);\nfloat atomicExch(float* address, float val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory and stores val back to memory at the same address. These two operations are performed in one atomic transaction. The function returns old.\n\ntemplate<typename T> T atomicExch(T* address, T val);\n\nreads the 128-bit word old located at the address address in global or shared memory and stores val back to memory at the same address. These two operations are performed in one atomic transaction. The function returns old. The type T must meet the following requirements:\n\nsizeof(T) == 16\nalignof(T) >= 16\nstd::is_trivially_copyable<T>::value == true\n// for C++03 and older\nstd::is_default_constructible<T>::value == true\n\nSo, T must be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.\n\nThe 128-bit atomicExch() is only supported by devices of compute capability 9.x and higher.\n10.14.1.4. atomicMin()\uf0c1\n\nint atomicMin(int* address, int val);\nunsigned int atomicMin(unsigned int* address,\n                       unsigned int val);\nunsigned long long int atomicMin(unsigned long long int* address,\n                                 unsigned long long int val);\nlong long int atomicMin(long long int* address,\n                                long long int val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes the minimum of old and val, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64-bit version of atomicMin() is only supported by devices of compute capability 5.0 and higher.\n10.14.1.5. atomicMax()\uf0c1\n\nint atomicMax(int* address, int val);\nunsigned int atomicMax(unsigned int* address,\n                       unsigned int val);\nunsigned long long int atomicMax(unsigned long long int* address,\n                                 unsigned long long int val);\nlong long int atomicMax(long long int* address,\n                                 long long int val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes the maximum of old and val, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64-bit version of atomicMax() is only supported by devices of compute capability 5.0 and higher.\n10.14.1.6. atomicInc()\uf0c1\n\nunsigned int atomicInc(unsigned int* address,\n                       unsigned int val);\n\nreads the 32-bit word old located at the address address in global or shared memory, computes ((old >= val) ? 0 : (old+1)), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n10.14.1.7. atomicDec()\uf0c1\n\nunsigned int atomicDec(unsigned int* address,\n                       unsigned int val);\n\nreads the 32-bit word old located at the address address in global or shared memory, computes (((old == 0) || (old > val)) ? val : (old-1) ), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n10.14.1.8. atomicCAS()\uf0c1\n\nint atomicCAS(int* address, int compare, int val);\nunsigned int atomicCAS(unsigned int* address,\n                       unsigned int compare,\n                       unsigned int val);\nunsigned long long int atomicCAS(unsigned long long int* address,\n                                 unsigned long long int compare,\n                                 unsigned long long int val);\nunsigned short int atomicCAS(unsigned short int *address,\n                             unsigned short int compare,\n                             unsigned short int val);\n\nreads the 16-bit, 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old == compare ? val : old), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old (Compare And Swap).\n\ntemplate<typename T> T atomicCAS(T* address, T compare, T val);\n\nreads the 128-bit word old located at the address address in global or shared memory, computes (old == compare ? val : old), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old (Compare And Swap). The type T must meet the following requirements:\n\nsizeof(T) == 16\nalignof(T) >= 16\nstd::is_trivially_copyable<T>::value == true\n// for C++03 and older\nstd::is_default_constructible<T>::value == true\n\nSo, T must be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.\n\nThe 128-bit atomicCAS() is only supported by devices of compute capability 9.x and higher.\n10.14.1.9. __nv_atomic_exchange()\uf0c1\n\n__device__ void __nv_atomic_exchange(T* ptr, T* val, T *ret, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It reads the value where ptr points to and stores the value to where ret points to. And it reads the value where val points to and stores the value to where ptr points to.\n\nThis is a generic atomic exchange, which means that T can be any data type that is size of 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_90 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.10. __nv_atomic_exchange_n()\uf0c1\n\n__device__ T __nv_atomic_exchange_n(T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It reads the value where ptr points to and use this value as the return value. And it stores val to where ptr points to.\n\nThis is a non-generic atomic exchange, which means that T can only be an integral type that is size of 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_90 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.11. __nv_atomic_compare_exchange()\uf0c1\n\n__device__ bool __nv_atomic_compare_exchange (T* ptr, T* expected, T* desired, bool weak, int success_order, int failure_order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It reads the value where ptr points to and compare it with the value where expected points to. If they are equal, the return value is true and the value where desired points to is stored to where ptr points to. Otherwise, it returns false and the value where ptr points to is stored to where expected points to. The parameter weak is ignored and it picks the stronger memory order between success_order and failure_order to execute the compare-and-exchange operation.\n\nThis is a generic atomic compare-and-exchange, which means that T can be any data type that is size of 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_90 and higher.\n\n2-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.12. __nv_atomic_compare_exchange_n()\uf0c1\n\n__device__ bool __nv_atomic_compare_exchange_n (T* ptr, T* expected, T desired, bool weak, int success_order, int failure_order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It reads the value where ptr points to and compare it with the value where expected points to. If they are equal, the return value is true and desired is stored to where ptr points to. Otherwise, it returns false and the value where ptr points to is stored to where expected points to. The parameter weak is ignored and it picks the stronger memory order between success_order and failure_order to execute the compare-and-exchange operation.\n\nThis is a non-generic atomic compare-and-exchange, which means that T can only be an integral type that is size of 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_90 and higher.\n\n2-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.13. __nv_atomic_fetch_add() and __nv_atomic_add()\uf0c1\n\n__device__ T __nv_atomic_fetch_add (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_add (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, adds with val, and stores the result back to where ptr points to. __nv_atomic_fetch_add returns the old value where ptr points to. __nv_atomic_add does not have return value.\n\nT can only be unsigned int, int, unsigned long long, float or double.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.14. __nv_atomic_fetch_sub() and __nv_atomic_sub()\uf0c1\n\n__device__ T __nv_atomic_fetch_sub (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_sub (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, subtracts with val, and stores the result back to where ptr points to. __nv_atomic_fetch_sub returns the old value where ptr points to. __nv_atomic_sub does not have return value.\n\nT can only be unsigned int, int, unsigned long long, float or double.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.15. __nv_atomic_fetch_min() and __nv_atomic_min()\uf0c1\n\n__device__ T __nv_atomic_fetch_min (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_min (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, compares with val, and stores the smaller value back to where ptr points to. __nv_atomic_fetch_min returns the old value where ptr points to. __nv_atomic_min does not have return value.\n\nT can only be unsigned int, int, unsigned long long or long long.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.1.16. __nv_atomic_fetch_max() and __nv_atomic_max()\uf0c1\n\n__device__ T __nv_atomic_fetch_max (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_max (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, compares with val, and stores the bigger value back to where ptr points to. __nv_atomic_fetch_max returns the old value where ptr points to. __nv_atomic_max does not have return value.\n\nT can only be unsigned int, int, unsigned long long or long long.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.2. Bitwise Functions\uf0c1\n10.14.2.1. atomicAnd()\uf0c1\n\nint atomicAnd(int* address, int val);\nunsigned int atomicAnd(unsigned int* address,\n                       unsigned int val);\nunsigned long long int atomicAnd(unsigned long long int* address,\n                                 unsigned long long int val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old & val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64-bit version of atomicAnd() is only supported by devices of compute capability 5.0 and higher.\n10.14.2.2. atomicOr()\uf0c1\n\nint atomicOr(int* address, int val);\nunsigned int atomicOr(unsigned int* address,\n                      unsigned int val);\nunsigned long long int atomicOr(unsigned long long int* address,\n                                unsigned long long int val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old | val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64-bit version of atomicOr() is only supported by devices of compute capability 5.0 and higher.\n10.14.2.3. atomicXor()\uf0c1\n\nint atomicXor(int* address, int val);\nunsigned int atomicXor(unsigned int* address,\n                       unsigned int val);\nunsigned long long int atomicXor(unsigned long long int* address,\n                                 unsigned long long int val);\n\nreads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old ^ val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64-bit version of atomicXor() is only supported by devices of compute capability 5.0 and higher.\n10.14.2.4. __nv_atomic_fetch_or() and __nv_atomic_or()\uf0c1\n\n__device__ T __nv_atomic_fetch_or (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_or (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, or with val, and stores the result back to where ptr points to. __nv_atomic_fetch_or returns the old value where ptr points to. __nv_atomic_or does not have return value.\n\nT can only be an integral type that is size of 4 or 8 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.2.5. __nv_atomic_fetch_xor() and __nv_atomic_xor()\uf0c1\n\n__device__ T __nv_atomic_fetch_xor (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_xor (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, xor with val, and stores the result back to where ptr points to. __nv_atomic_fetch_xor returns the old value where ptr points to. __nv_atomic_xor does not have return value.\n\nT can only be an integral type that is size of 4 or 8 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.2.6. __nv_atomic_fetch_and() and __nv_atomic_and()\uf0c1\n\n__device__ T __nv_atomic_fetch_and (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n__device__ void __nv_atomic_and (T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThese two atomic functions are introduced in CUDA 12.8. It reads the value where ptr points to, and with val, and stores the result back to where ptr points to. __nv_atomic_fetch_and returns the old value where ptr points to. __nv_atomic_and does not have return value.\n\nT can only be an integral type that is size of 4 or 8 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.14.3. Other atomic functions\uf0c1\n10.14.3.1. __nv_atomic_load()\uf0c1\n\n__device__ void __nv_atomic_load(T* ptr, T* ret, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It loads the value where ptr points to and writes the value to where ret points to.\n\nThis is a generic atomic load, which means that T can be any data type that is size of 1, 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables. order cannot be __NV_ATOMIC_RELEASE or __NV_ATOMIC_ACQ_REL.\n10.14.3.2. __nv_atomic_load_n()\uf0c1\n\n__device__ T __nv_atomic_load_n(T* ptr, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It loads the value where ptr points to and returns this value.\n\nThis is a non-generic atomic load, which means that T can only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables. order cannot be __NV_ATOMIC_RELEASE or __NV_ATOMIC_ACQ_REL.\n10.14.3.3. __nv_atomic_store()\uf0c1\n\n__device__ void __nv_atomic_store(T* ptr, T* val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It reads the value where val points to and stores to where ptr points to.\n\nThis is a generic atomic load, which means that T can be any data type that is size of 1, 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables. order cannot be __NV_ATOMIC_CONSUME, __NV_ATOMIC_ACQUIRE or __NV_ATOMIC_ACQ_REL.\n10.14.3.4. __nv_atomic_store_n()\uf0c1\n\n__device__ void __nv_atomic_store_n(T* ptr, T val, int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function is introduced in CUDA 12.8. It stores val to where ptr points to.\n\nThis is a non-generic atomic load, which means that T can only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.\n\nThe atomic operation with memory order and thread scope is supported on the architecture sm_60 and higher.\n\n16-byte data type is supported on the architecture sm_70 and higher.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables. order cannot be __NV_ATOMIC_CONSUME, __NV_ATOMIC_ACQUIRE or __NV_ATOMIC_ACQ_REL.\n10.14.3.5. __nv_atomic_thread_fence()\uf0c1\n\n__device__ void __nv_atomic_thread_fence (int order, int scope = __NV_THREAD_SCOPE_SYSTEM);\n\nThis atomic function establishes an ordering between memory accesses requested by this thread based on the specified memory order. And the thread scope parameter specifies the set of threads that may observe the ordering effect of this operation.\n\nThe thread scope of cluster is supported on the architecture sm_90 and higher.\n\nThe arguments order and scope need to be integer literals, i.e., the arguments cannot be variables.\n10.15. Address Space Predicate Functions\uf0c1\n\nThe functions described in this section have unspecified behavior if the argument is a null pointer.\n10.15.1. __isGlobal()\uf0c1\n\n__device__ unsigned int __isGlobal(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in global memory space, otherwise returns 0.\n10.15.2. __isShared()\uf0c1\n\n__device__ unsigned int __isShared(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in shared memory space, otherwise returns 0.\n10.15.3. __isConstant()\uf0c1\n\n__device__ unsigned int __isConstant(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in constant memory space, otherwise returns 0.\n10.15.4. __isGridConstant()\uf0c1\n\n__device__ unsigned int __isGridConstant(const void *ptr);\n\nReturns 1 if ptr contains the generic address of a kernel parameter annotated with __grid_constant__, otherwise returns 0. Only supported for compute architectures greater than or equal to 7.x or later.\n10.15.5. __isLocal()\uf0c1\n\n__device__ unsigned int __isLocal(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in local memory space, otherwise returns 0.\n10.16. Address Space Conversion Functions\uf0c1\n10.16.1. __cvta_generic_to_global()\uf0c1\n\n__device__ size_t __cvta_generic_to_global(const void *ptr);\n\nReturns the result of executing the PTXcvta.to.global instruction on the generic address denoted by ptr.\n10.16.2. __cvta_generic_to_shared()\uf0c1\n\n__device__ size_t __cvta_generic_to_shared(const void *ptr);\n\nReturns the result of executing the PTXcvta.to.shared instruction on the generic address denoted by ptr.\n10.16.3. __cvta_generic_to_constant()\uf0c1\n\n__device__ size_t __cvta_generic_to_constant(const void *ptr);\n\nReturns the result of executing the PTXcvta.to.const instruction on the generic address denoted by ptr.\n10.16.4. __cvta_generic_to_local()\uf0c1\n\n__device__ size_t __cvta_generic_to_local(const void *ptr);\n\nReturns the result of executing the PTXcvta.to.local instruction on the generic address denoted by ptr.\n10.16.5. __cvta_global_to_generic()\uf0c1\n\n__device__ void * __cvta_global_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta.global instruction on the value provided by rawbits.\n10.16.6. __cvta_shared_to_generic()\uf0c1\n\n__device__ void * __cvta_shared_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta.shared instruction on the value provided by rawbits.\n10.16.7. __cvta_constant_to_generic()\uf0c1\n\n__device__ void * __cvta_constant_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta.const instruction on the value provided by rawbits.\n10.16.8. __cvta_local_to_generic()\uf0c1\n\n__device__ void * __cvta_local_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta.local instruction on the value provided by rawbits.\n10.17. Alloca Function\uf0c1\n10.17.1. Synopsis\uf0c1\n\n__host__ __device__ void * alloca(size_t size);\n\n10.17.2. Description\uf0c1\n\nThe alloca() function allocates size bytes of memory in the stack frame of the caller. The returned value is a pointer to allocated memory, the beginning of the memory is 16 bytes aligned when the function is invoked from device code. The allocated memory is automatically freed when the caller to alloca() is returned.\n\nNote\n\nOn Windows platform, <malloc.h> must be included before using alloca(). Using alloca() may cause the stack to overflow, user needs to adjust stack size accordingly.\n\nIt is supported with compute capability 5.2 or higher.\n10.17.3. Example\uf0c1\n\n__device__ void foo(unsigned int num) {\n    int4 *ptr = (int4 *)alloca(num * sizeof(int4));\n    // use of ptr\n    ...\n}\n\n10.18. Compiler Optimization Hint Functions\uf0c1\n\nThe functions described in this section can be used to provide additional information to the compiler optimizer.\n10.18.1. __builtin_assume_aligned()\uf0c1\n\nvoid * __builtin_assume_aligned (const void *exp, size_t align)\n\nAllows the compiler to assume that the argument pointer is aligned to at least align bytes, and returns the argument pointer.\n\nExample:\n\nvoid *res = __builtin_assume_aligned(ptr, 32); // compiler can assume 'res' is\n                                               // at least 32-byte aligned\n\nThree parameter version:\n\nvoid * __builtin_assume_aligned (const void *exp, size_t align,\n                                 <integral type> offset)\n\nAllows the compiler to assume that (char *)exp - offset is aligned to at least align bytes, and returns the argument pointer.\n\nExample:\n\nvoid *res = __builtin_assume_aligned(ptr, 32, 8); // compiler can assume\n                                                  // '(char *)res - 8' is\n                                                  // at least 32-byte aligned.\n\n10.18.2. __builtin_assume()\uf0c1\n\nvoid __builtin_assume(bool exp)\n\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\n\nExample:\n\n __device__ int get(int *ptr, int idx) {\n   __builtin_assume(idx <= 2);\n   return ptr[idx];\n}\n\n10.18.3. __assume()\uf0c1\n\nvoid __assume(bool exp)\n\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\n\nExample:\n\n __device__ int get(int *ptr, int idx) {\n   __assume(idx <= 2);\n   return ptr[idx];\n}\n\n10.18.4. __builtin_expect()\uf0c1\n\nlong __builtin_expect (long exp, long c)\n\nIndicates to the compiler that it is expected that exp == c, and returns the value of exp. Typically used to indicate branch prediction information to the compiler.\n\nExample:\n\n// indicate to the compiler that likely \"var == 0\",\n// so the body of the if-block is unlikely to be\n// executed at run time.\nif (__builtin_expect (var, 0))\n  doit ();\n\n10.18.5. __builtin_unreachable()\uf0c1\n\nvoid __builtin_unreachable(void)\n\nIndicates to the compiler that control flow never reaches the point where this function is being called from. The program has undefined behavior if the control flow does actually reach this point at run time.\n\nExample:\n\n// indicates to the compiler that the default case label is never reached.\nswitch (in) {\ncase 1: return 4;\ncase 2: return 10;\ndefault: __builtin_unreachable();\n}\n\n10.18.6. Restrictions\uf0c1\n\n__assume() is only supported when using cl.exe host compiler. The other functions are supported on all platforms, subject to the following restrictions:\n\n    If the host compiler supports the function, the function can be invoked from anywhere in translation unit.\n\n    Otherwise, the function must be invoked from within the body of a __device__/ __global__function, or only when the __CUDA_ARCH__ macro is defined5.\n\n10.19. Warp Vote Functions\uf0c1\n\nint __all_sync(unsigned mask, int predicate);\nint __any_sync(unsigned mask, int predicate);\nunsigned __ballot_sync(unsigned mask, int predicate);\nunsigned __activemask();\n\nDeprecation notice: __any, __all, and __ballot have been deprecated in CUDA 9.0 for all devices.\n\nRemoval notice: When targeting devices with compute capability 7.x or higher, __any, __all, and __ballot are no longer available and their sync variants should be used instead.\n\nThe warp vote functions allow the threads of a given warp to perform a reduction-and-broadcast operation. These functions take as input an integer predicate from each thread in the warp and compare those values with zero. The results of the comparisons are combined (reduced) across the active threads of the warp in one of the following ways, broadcasting a single return value to each participating thread:\n\n__all_sync(unsigned mask, predicate):\n\n    Evaluate predicate for all non-exited threads in mask and return non-zero if and only if predicate evaluates to non-zero for all of them.\n__any_sync(unsigned mask, predicate):\n\n    Evaluate predicate for all non-exited threads in mask and return non-zero if and only if predicate evaluates to non-zero for any of them.\n__ballot_sync(unsigned mask, predicate):\n\n    Evaluate predicate for all non-exited threads in mask and return an integer whose Nth bit is set if and only if predicate evaluates to non-zero for the Nth thread of the warp and the Nth thread is active.\n__activemask():\n\n    Returns a 32-bit integer mask of all currently active threads in the calling warp. The Nth bit is set if the Nth lane in the warp is active when __activemask() is called. Inactive threads are represented by 0 bits in the returned mask. Threads which have exited the program are always marked as inactive. Note that threads that are convergent at an __activemask() call are not guaranteed to be convergent at subsequent instructions unless those instructions are synchronizing warp-builtin functions.\n\nFor __all_sync, __any_sync, and __ballot_sync, a mask must be passed that specifies the threads participating in the call. A bit, representing the thread\u2019s lane ID, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.20. Warp Match Functions\uf0c1\n\n__match_any_sync and __match_all_sync perform a broadcast-and-compare operation of a variable between threads within a warp.\n\nSupported by devices of compute capability 7.x or higher.\n10.20.1. Synopsis\uf0c1\n\nunsigned int __match_any_sync(unsigned mask, T value);\nunsigned int __match_all_sync(unsigned mask, T value, int *pred);\n\nT can be int, unsigned int, long, unsigned long, long long, unsigned long long, float or double.\n10.20.2. Description\uf0c1\n\nThe __match_sync() intrinsics permit a broadcast-and-compare of a value value across threads in a warp after synchronizing threads named in mask.\n\n__match_any_sync\n\n    Returns mask of threads that have same value of value in mask\n__match_all_sync\n\n    Returns mask if all threads in mask have the same value for value; otherwise 0 is returned. Predicate pred is set to true if all threads in mask have the same value of value; otherwise the predicate is set to false.\n\nThe new *_sync match intrinsics take in a mask indicating the threads participating in the call. A bit, representing the thread\u2019s lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.21. Warp Reduce Functions\uf0c1\n\nThe __reduce_sync(unsigned mask, T value) intrinsics perform a reduction operation on the data provided in value after synchronizing threads named in mask. T can be unsigned or signed for {add, min, max} and unsigned only for {and, or, xor} operations.\n\nSupported by devices of compute capability 8.x or higher.\n10.21.1. Synopsis\uf0c1\n\n// add/min/max\nunsigned __reduce_add_sync(unsigned mask, unsigned value);\nunsigned __reduce_min_sync(unsigned mask, unsigned value);\nunsigned __reduce_max_sync(unsigned mask, unsigned value);\nint __reduce_add_sync(unsigned mask, int value);\nint __reduce_min_sync(unsigned mask, int value);\nint __reduce_max_sync(unsigned mask, int value);\n\n// and/or/xor\nunsigned __reduce_and_sync(unsigned mask, unsigned value);\nunsigned __reduce_or_sync(unsigned mask, unsigned value);\nunsigned __reduce_xor_sync(unsigned mask, unsigned value);\n\n10.21.2. Description\uf0c1\n\n__reduce_add_sync, __reduce_min_sync, __reduce_max_sync\n\n    Returns the result of applying an arithmetic add, min, or max reduction operation on the values provided in value by each thread named in mask.\n__reduce_and_sync, __reduce_or_sync, __reduce_xor_sync\n\n    Returns the result of applying a logical AND, OR, or XOR reduction operation on the values provided in value by each thread named in mask.\n\nThe mask indicates the threads participating in the call. A bit, representing the thread\u2019s lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.22. Warp Shuffle Functions\uf0c1\n\n__shfl_sync, __shfl_up_sync, __shfl_down_sync, and __shfl_xor_sync exchange a variable between threads within a warp.\n\nSupported by devices of compute capability 5.0 or higher.\n\nDeprecation Notice: __shfl, __shfl_up, __shfl_down, and __shfl_xor have been deprecated in CUDA 9.0 for all devices.\n\nRemoval Notice: When targeting devices with compute capability 7.x or higher, __shfl, __shfl_up, __shfl_down, and __shfl_xor are no longer available and their sync variants should be used instead.\n10.22.1. Synopsis\uf0c1\n\nT __shfl_sync(unsigned mask, T var, int srcLane, int width=warpSize);\nT __shfl_up_sync(unsigned mask, T var, unsigned int delta, int width=warpSize);\nT __shfl_down_sync(unsigned mask, T var, unsigned int delta, int width=warpSize);\nT __shfl_xor_sync(unsigned mask, T var, int laneMask, int width=warpSize);\n\nT can be int, unsigned int, long, unsigned long, long long, unsigned long long, float or double. With the cuda_fp16.h header included, T can also be __half or __half2. Similarly, with the cuda_bf16.h header included, T can also be __nv_bfloat16 or __nv_bfloat162.\n10.22.2. Description\uf0c1\n\nThe __shfl_sync() intrinsics permit exchanging of a variable between threads within a warp without use of shared memory. The exchange occurs simultaneously for all active threads within the warp (and named in mask), moving 4 or 8 bytes of data per thread depending on the type.\n\nThreads within a warp are referred to as lanes, and may have an index between 0 and warpSize-1 (inclusive). Four source-lane addressing modes are supported:\n\n__shfl_sync()\n\n    Direct copy from indexed lane\n__shfl_up_sync()\n\n    Copy from a lane with lower ID relative to caller\n__shfl_down_sync()\n\n    Copy from a lane with higher ID relative to caller\n__shfl_xor_sync()\n\n    Copy from a lane based on bitwise XOR of own lane ID\n\nThreads may only read data from another thread which is actively participating in the __shfl_sync() command. If the target thread is inactive, the retrieved value is undefined.\n\nAll of the __shfl_sync() intrinsics take an optional width parameter which alters the behavior of the intrinsic. width must have a value which is a power of two in the range [1, warpSize] (i.e., 1, 2, 4, 8, 16 or 32). Results are undefined for other values.\n\n__shfl_sync() returns the value of var held by the thread whose ID is given by srcLane. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by the srcLane modulo width (i.e. within the same subsection).\n\n__shfl_up_sync() calculates a source lane ID by subtracting delta from the caller\u2019s lane ID. The value of var held by the resulting lane ID is returned: in effect, var is shifted up the warp by delta lanes. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. The source lane index will not wrap around the value of width, so effectively the lower delta lanes will be unchanged.\n\n__shfl_down_sync() calculates a source lane ID by adding delta to the caller\u2019s lane ID. The value of var held by the resulting lane ID is returned: this has the effect of shifting var down the warp by delta lanes. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. As for __shfl_up_sync(), the ID number of the source lane will not wrap around the value of width and so the upper delta lanes will remain unchanged.\n\n__shfl_xor_sync() calculates a source line ID by performing a bitwise XOR of the caller\u2019s lane ID with laneMask: the value of var held by the resulting lane ID is returned. If width is less than warpSize then each group of width consecutive threads are able to access elements from earlier groups of threads, however if they attempt to access elements from later groups of threads their own value of var will be returned. This mode implements a butterfly addressing pattern such as is used in tree reduction and broadcast.\n\nThe new *_sync shfl intrinsics take in a mask indicating the threads participating in the call. A bit, representing the thread\u2019s lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThreads may only read data from another thread which is actively participating in the __shfl_sync() command. If the target thread is inactive, the retrieved value is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n10.22.3. Examples\uf0c1\n10.22.3.1. Broadcast of a single value across a warp\uf0c1\n\n#include <stdio.h>\n\n__global__ void bcast(int arg) {\n    int laneId = threadIdx.x & 0x1f;\n    int value;\n    if (laneId == 0)        // Note unused variable for\n        value = arg;        // all threads except lane 0\n    value = __shfl_sync(0xffffffff, value, 0);   // Synchronize all threads in warp, and get \"value\" from lane 0\n    if (value != arg)\n        printf(\"Thread %d failed.\\n\", threadIdx.x);\n}\n\nint main() {\n    bcast<<< 1, 32 >>>(1234);\n    cudaDeviceSynchronize();\n\n    return 0;\n}\n\n10.22.3.2. Inclusive plus-scan across sub-partitions of 8 threads\uf0c1\n\n#include <stdio.h>\n\n__global__ void scan4() {\n    int laneId = threadIdx.x & 0x1f;\n    // Seed sample starting value (inverse of lane ID)\n    int value = 31 - laneId;\n\n    // Loop to accumulate scan within my partition.\n    // Scan requires log2(n) == 3 steps for 8 threads\n    // It works by an accumulated sum up the warp\n    // by 1, 2, 4, 8 etc. steps.\n    for (int i=1; i<=4; i*=2) {\n        // We do the __shfl_sync unconditionally so that we\n        // can read even from threads which won't do a\n        // sum, and then conditionally assign the result.\n        int n = __shfl_up_sync(0xffffffff, value, i, 8);\n        if ((laneId & 7) >= i)\n            value += n;\n    }\n\n    printf(\"Thread %d final value = %d\\n\", threadIdx.x, value);\n}\n\nint main() {\n    scan4<<< 1, 32 >>>();\n    cudaDeviceSynchronize();\n\n    return 0;\n}\n\n10.22.3.3. Reduction across a warp\uf0c1\n\n#include <stdio.h>\n\n__global__ void warpReduce() {\n    int laneId = threadIdx.x & 0x1f;\n    // Seed starting value as inverse lane ID\n    int value = 31 - laneId;\n\n    // Use XOR mode to perform butterfly reduction\n    for (int i=16; i>=1; i/=2)\n        value += __shfl_xor_sync(0xffffffff, value, i, 32);\n\n    // \"value\" now contains the sum across all threads\n    printf(\"Thread %d final value = %d\\n\", threadIdx.x, value);\n}\n\nint main() {\n    warpReduce<<< 1, 32 >>>();\n    cudaDeviceSynchronize();\n\n    return 0;\n}\n\n10.23. Nanosleep Function\uf0c1\n10.23.1. Synopsis\uf0c1\n\nvoid __nanosleep(unsigned ns);\n\n10.23.2. Description\uf0c1\n\n__nanosleep(ns) suspends the thread for a sleep duration of approximately ns nanoseconds. The maximum sleep duration is approximately 1 millisecond.\n\nIt is supported with compute capability 7.0 or higher.\n10.23.3. Example\uf0c1\n\nThe following code implements a mutex with exponential back-off.\n\n__device__ void mutex_lock(unsigned int *mutex) {\n    unsigned int ns = 8;\n    while (atomicCAS(mutex, 0, 1) == 1) {\n        __nanosleep(ns);\n        if (ns < 256) {\n            ns *= 2;\n        }\n    }\n}\n\n__device__ void mutex_unlock(unsigned int *mutex) {\n    atomicExch(mutex, 0);\n}\n\n10.24. Warp Matrix Functions\uf0c1\n\nC++ warp matrix operations leverage Tensor Cores to accelerate matrix problems of the form D=A*B+C. These operations are supported on mixed-precision floating point data for devices of compute capability 7.0 or higher. This requires co-operation from all threads in a warp. In addition, these operations are allowed in conditional code only if the condition evaluates identically across the entire warp, otherwise the code execution is likely to hang.\n10.24.1. Description\uf0c1\n\nAll following functions and types are defined in the namespace nvcuda::wmma. Sub-byte operations are considered preview, i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This extra functionality is defined in the nvcuda::wmma::experimental namespace.\n\ntemplate<typename Use, int m, int n, int k, typename T, typename Layout=void> class fragment;\n\nvoid load_matrix_sync(fragment<...> &a, const T* mptr, unsigned ldm);\nvoid load_matrix_sync(fragment<...> &a, const T* mptr, unsigned ldm, layout_t layout);\nvoid store_matrix_sync(T* mptr, const fragment<...> &a, unsigned ldm, layout_t layout);\nvoid fill_fragment(fragment<...> &a, const T& v);\nvoid mma_sync(fragment<...> &d, const fragment<...> &a, const fragment<...> &b, const fragment<...> &c, bool satf=false);\n\nfragment\n\n    An overloaded class containing a section of a matrix distributed across all threads in the warp. The mapping of matrix elements into fragment internal storage is unspecified and subject to change in future architectures.\n\nOnly certain combinations of template arguments are allowed. The first template parameter specifies how the fragment will participate in the matrix operation. Acceptable values for Use are:\n\n    matrix_a when the fragment is used as the first multiplicand, A,\n\n    matrix_b when the fragment is used as the second multiplicand, B, or\n\n    accumulator when the fragment is used as the source or destination accumulators (C or D, respectively).\n\n    The m, n and k sizes describe the shape of the warp-wide matrix tiles participating in the multiply-accumulate operation. The dimension of each tile depends on its role. For matrix_a the tile takes dimension m x k; for matrix_b the dimension is k x n, and accumulator tiles are m x n.\n\n    The data type, T, may be double, float, __half, __nv_bfloat16, char, or unsigned char for multiplicands and double, float, int, or __half for accumulators. As documented in Element Types and Matrix Sizes, limited combinations of accumulator and multiplicand types are supported. The Layout parameter must be specified for matrix_a and matrix_b fragments. row_major or col_major indicate that elements within a matrix row or column are contiguous in memory, respectively. The Layout parameter for an accumulator matrix should retain the default value of void. A row or column layout is specified only when the accumulator is loaded or stored as described below.\n\nload_matrix_sync\n\n    Waits until all warp lanes have arrived at load_matrix_sync and then loads the matrix fragment a from memory. mptr must be a 256-bit aligned pointer pointing to the first element of the matrix in memory. ldm describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for __half element type or multiple of 4 for float element type. (i.e., multiple of 16 bytes in both cases). If the fragment is an accumulator, the layout argument must be specified as either mem_row_major or mem_col_major. For matrix_a and matrix_b fragments, the layout is inferred from the fragment\u2019s layout parameter. The values of mptr, ldm, layout and all template parameters for a must be the same for all threads in the warp. This function must be called by all threads in the warp, or the result is undefined.\nstore_matrix_sync\n\n    Waits until all warp lanes have arrived at store_matrix_sync and then stores the matrix fragment a to memory. mptr must be a 256-bit aligned pointer pointing to the first element of the matrix in memory. ldm describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for __half element type or multiple of 4 for float element type. (i.e., multiple of 16 bytes in both cases). The layout of the output matrix must be specified as either mem_row_major or mem_col_major. The values of mptr, ldm, layout and all template parameters for a must be the same for all threads in the warp.\nfill_fragment\n\n    Fill a matrix fragment with a constant value v. Because the mapping of matrix elements to each fragment is unspecified, this function is ordinarily called by all threads in the warp with a common value for v.\nmma_sync\n\n    Waits until all warp lanes have arrived at mma_sync, and then performs the warp-synchronous matrix multiply-accumulate operation D=A*B+C. The in-place operation, C=A*B+C, is also supported. The value of satf and template parameters for each matrix fragment must be the same for all threads in the warp. Also, the template parameters m, n and k must match between fragments A, B, C and D. This function must be called by all threads in the warp, or the result is undefined.\n\nIf satf (saturate to finite value) mode is true, the following additional numerical properties apply for the destination accumulator:\n\n    If an element result is +Infinity, the corresponding accumulator will contain +MAX_NORM\n\n    If an element result is -Infinity, the corresponding accumulator will contain -MAX_NORM\n\n    If an element result is NaN, the corresponding accumulator will contain +0\n\nBecause the map of matrix elements into each thread\u2019s fragment is unspecified, individual matrix elements must be accessed from memory (shared or global) after calling store_matrix_sync. In the special case where all threads in the warp will apply an element-wise operation uniformly to all fragment elements, direct element access can be implemented using the following fragment class members.\n\nenum fragment<Use, m, n, k, T, Layout>::num_elements;\nT fragment<Use, m, n, k, T, Layout>::x[num_elements];\n\nAs an example, the following code scales an accumulator matrix tile by half.\n\nwmma::fragment<wmma::accumulator, 16, 16, 16, float> frag;\nfloat alpha = 0.5f; // Same value for all threads in warp\n/*...*/\nfor(int t=0; t<frag.num_elements; t++)\nfrag.x[t] *= alpha;\n\n10.24.2. Alternate Floating Point\uf0c1\n\nTensor Cores support alternate types of floating point operations on devices with compute capability 8.0 and higher.\n\n__nv_bfloat16\n\n    This data format is an alternate fp16 format that has the same range as f32 but reduced precision (7 bits). You can use this data format directly with the __nv_bfloat16 type available in cuda_bf16.h. Matrix fragments with __nv_bfloat16 data types are required to be composed with accumulators of float type. The shapes and operations supported are the same as with __half.\ntf32\n\n    This data format is a special floating point format supported by Tensor Cores, with the same range as f32 and reduced precision (>=10 bits). The internal layout of this format is implementation defined. In order to use this floating point format with WMMA operations, the input matrices must be manually converted to tf32 precision.\n\n    To facilitate conversion, a new intrinsic __float_to_tf32 is provided. While the input and output arguments to the intrinsic are of float type, the output will be tf32 numerically. This new precision is intended to be used with Tensor Cores only, and if mixed with other floattype operations, the precision and range of the result will be undefined.\n\n    Once an input matrix (matrix_a or matrix_b) is converted to tf32 precision, the combination of a fragment with precision::tf32 precision, and a data type of float to load_matrix_sync will take advantage of this new capability. Both the accumulator fragments must have float data types. The only supported matrix size is 16x16x8 (m-n-k).\n\n    The elements of the fragment are represented as float, hence the mapping from element_type<T> to storage_element_type<T> is:\n\n    precision::tf32 -> float\n\n10.24.3. Double Precision\uf0c1\n\nTensor Cores support double-precision floating point operations on devices with compute capability 8.0 and higher. To use this new functionality, a fragment with the double type must be used. The mma_sync operation will be performed with the .rn (rounds to nearest even) rounding modifier.\n10.24.4. Sub-byte Operations\uf0c1\n\nSub-byte WMMA operations provide a way to access the low-precision capabilities of Tensor Cores. They are considered a preview feature i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This functionality is available via the nvcuda::wmma::experimental namespace:\n\nnamespace experimental {\n    namespace precision {\n        struct u4; // 4-bit unsigned\n        struct s4; // 4-bit signed\n        struct b1; // 1-bit\n   }\n    enum bmmaBitOp {\n        bmmaBitOpXOR = 1, // compute_75 minimum\n        bmmaBitOpAND = 2  // compute_80 minimum\n    };\n    enum bmmaAccumulateOp { bmmaAccumulateOpPOPC = 1 };\n}\n\nFor 4 bit precision, the APIs available remain the same, but you must specify experimental::precision::u4 or experimental::precision::s4 as the fragment data type. Since the elements of the fragment are packed together, num_storage_elements will be smaller than num_elements for that fragment. The num_elements variable for a sub-byte fragment, hence returns the number of elements of sub-byte type element_type<T>. This is true for single bit precision as well, in which case, the mapping from element_type<T> to storage_element_type<T> is as follows:\n\nexperimental::precision::u4 -> unsigned (8 elements in 1 storage element)\nexperimental::precision::s4 -> int (8 elements in 1 storage element)\nexperimental::precision::b1 -> unsigned (32 elements in 1 storage element)\nT -> T  //all other types\n\nThe allowed layouts for sub-byte fragments is always row_major for matrix_a and col_major for matrix_b.\n\nFor sub-byte operations the value of ldm in load_matrix_sync should be a multiple of 32 for element type experimental::precision::u4 and experimental::precision::s4 or a multiple of 128 for element type experimental::precision::b1 (i.e., multiple of 16 bytes in both cases).\n\nNote\n\nSupport for the following variants for MMA instructions is deprecated and will be removed in sm_90:\n\n        experimental::precision::u4\n\n        experimental::precision::s4\n\n        experimental::precision::b1 with bmmaBitOp set to bmmaBitOpXOR\n\nbmma_sync\n\n    Waits until all warp lanes have executed bmma_sync, and then performs the warp-synchronous bit matrix multiply-accumulate operation D = (A op B) + C, where op consists of a logical operation bmmaBitOp followed by the accumulation defined by bmmaAccumulateOp. The available operations are:\n\n    bmmaBitOpXOR, a 128-bit XOR of a row in matrix_a with the 128-bit column of matrix_b\n\n    bmmaBitOpAND, a 128-bit AND of a row in matrix_a with the 128-bit column of matrix_b, available on devices with compute capability 8.0 and higher.\n\n    The accumulate op is always bmmaAccumulateOpPOPC which counts the number of set bits.\n\n10.24.5. Restrictions\uf0c1\n\nThe special format required by tensor cores may be different for each major and minor device architecture. This is further complicated by threads holding only a fragment (opaque architecture-specific ABI data structure) of the overall matrix, with the developer not allowed to make assumptions on how the individual parameters are mapped to the registers participating in the matrix multiply-accumulate.\n\nSince fragments are architecture-specific, it is unsafe to pass them from function A to function B if the functions have been compiled for different link-compatible architectures and linked together into the same device executable. In this case, the size and layout of the fragment will be specific to one architecture and using WMMA APIs in the other will lead to incorrect results or potentially, corruption.\n\nAn example of two link-compatible architectures, where the layout of the fragment differs, is sm_70 and sm_75.\n\nfragA.cu: void foo() { wmma::fragment<...> mat_a; bar(&mat_a); }\nfragB.cu: void bar(wmma::fragment<...> *mat_a) { // operate on mat_a }\n\n// sm_70 fragment layout\n$> nvcc -dc -arch=compute_70 -code=sm_70 fragA.cu -o fragA.o\n// sm_75 fragment layout\n$> nvcc -dc -arch=compute_75 -code=sm_75 fragB.cu -o fragB.o\n// Linking the two together\n$> nvcc -dlink -arch=sm_75 fragA.o fragB.o -o frag.o\n\nThis undefined behavior might also be undetectable at compilation time and by tools at runtime, so extra care is needed to make sure the layout of the fragments is consistent. This linking hazard is most likely to appear when linking with a legacy library that is both built for a different link-compatible architecture and expecting to be passed a WMMA fragment.\n\nNote that in the case of weak linkages (for example, a CUDA C++ inline function), the linker may choose any available function definition which may result in implicit passes between compilation units.\n\nTo avoid these sorts of problems, the matrix should always be stored out to memory for transit through external interfaces (e.g. wmma::store_matrix_sync(dst, \u2026);) and then it can be safely passed to bar() as a pointer type [e.g. float *dst].\n\nNote that since sm_70 can run on sm_75, the above example sm_75 code can be changed to sm_70 and correctly work on sm_75. However, it is recommended to have sm_75 native code in your application when linking with other sm_75 separately compiled binaries.\n10.24.6. Element Types and Matrix Sizes\uf0c1\n\nTensor Cores support a variety of element types and matrix sizes. The following table presents the various combinations of matrix_a, matrix_b and accumulator matrix supported:\n\nMatrix A\n\t\n\nMatrix B\n\t\n\nAccumulator\n\t\n\nMatrix Size (m-n-k)\n\n__half\n\t\n\n__half\n\t\n\nfloat\n\t\n\n16x16x16\n\n__half\n\t\n\n__half\n\t\n\nfloat\n\t\n\n32x8x16\n\n__half\n\t\n\n__half\n\t\n\nfloat\n\t\n\n8x32x16\n\n__half\n\t\n\n__half\n\t\n\n__half\n\t\n\n16x16x16\n\n__half\n\t\n\n__half\n\t\n\n__half\n\t\n\n32x8x16\n\n__half\n\t\n\n__half\n\t\n\n__half\n\t\n\n8x32x16\n\nunsigned char\n\t\n\nunsigned char\n\t\n\nint\n\t\n\n16x16x16\n\nunsigned char\n\t\n\nunsigned char\n\t\n\nint\n\t\n\n32x8x16\n\nunsigned char\n\t\n\nunsigned char\n\t\n\nint\n\t\n\n8x32x16\n\nsigned char\n\t\n\nsigned char\n\t\n\nint\n\t\n\n16x16x16\n\nsigned char\n\t\n\nsigned char\n\t\n\nint\n\t\n\n32x8x16\n\nsigned char\n\t\n\nsigned char\n\t\n\nint\n\t\n\n8x32x16\n\nAlternate Floating Point support:\n\nMatrix A\n\t\n\nMatrix B\n\t\n\nAccumulator\n\t\n\nMatrix Size (m-n-k)\n\n__nv_bfloat16\n\t\n\n__nv_bfloat16\n\t\n\nfloat\n\t\n\n16x16x16\n\n__nv_bfloat16\n\t\n\n__nv_bfloat16\n\t\n\nfloat\n\t\n\n32x8x16\n\n__nv_bfloat16\n\t\n\n__nv_bfloat16\n\t\n\nfloat\n\t\n\n8x32x16\n\nprecision::tf32\n\t\n\nprecision::tf32\n\t\n\nfloat\n\t\n\n16x16x8\n\nDouble Precision Support:\n\nMatrix A\n\t\n\nMatrix B\n\t\n\nAccumulator\n\t\n\nMatrix Size (m-n-k)\n\ndouble\n\t\n\ndouble\n\t\n\ndouble\n\t\n\n8x8x4\n\nExperimental support for sub-byte operations:\n\nMatrix A\n\t\n\nMatrix B\n\t\n\nAccumulator\n\t\n\nMatrix Size (m-n-k)\n\nprecision::u4\n\t\n\nprecision::u4\n\t\n\nint\n\t\n\n8x8x32\n\nprecision::s4\n\t\n\nprecision::s4\n\t\n\nint\n\t\n\n8x8x32\n\nprecision::b1\n\t\n\nprecision::b1\n\t\n\nint\n\t\n\n8x8x128\n10.24.7. Example\uf0c1\n\nThe following code implements a 16x16x16 matrix multiplication in a single warp.\n\n#include <mma.h>\nusing namespace nvcuda;\n\n__global__ void wmma_ker(half *a, half *b, float *c) {\n   // Declare the fragments\n   wmma::fragment<wmma::matrix_a, 16, 16, 16, half, wmma::col_major> a_frag;\n   wmma::fragment<wmma::matrix_b, 16, 16, 16, half, wmma::row_major> b_frag;\n   wmma::fragment<wmma::accumulator, 16, 16, 16, float> c_frag;\n\n   // Initialize the output to zero\n   wmma::fill_fragment(c_frag, 0.0f);\n\n   // Load the inputs\n   wmma::load_matrix_sync(a_frag, a, 16);\n   wmma::load_matrix_sync(b_frag, b, 16);\n\n   // Perform the matrix multiplication\n   wmma::mma_sync(c_frag, a_frag, b_frag, c_frag);\n\n   // Store the output\n   wmma::store_matrix_sync(c, c_frag, 16, wmma::mem_row_major);\n}\n\n10.25. DPX\uf0c1\n\nDPX is a set of functions that enable finding min and max values, as well as fused addition and min/max, for up to three 16 and 32-bit signed or unsigned integer parameters, with optional ReLU (clamping to zero):\n\n    three parameters: __vimax3_s32, __vimax3_s16x2, __vimax3_u32, __vimax3_u16x2, __vimin3_s32, __vimin3_s16x2, __vimin3_u32, __vimin3_u16x2\n\n    two parameters, with ReLU: __vimax_s32_relu, __vimax_s16x2_relu, __vimin_s32_relu, __vimin_s16x2_relu\n\n    three parameters, with ReLU: __vimax3_s32_relu, __vimax3_s16x2_relu, __vimin3_s32_relu, __vimin3_s16x2_relu\n\n    two parameters, also returning which parameter was smaller/larger: __vibmax_s32, __vibmax_u32, __vibmin_s32, __vibmin_u32, __vibmax_s16x2, __vibmax_u16x2, __vibmin_s16x2, __vibmin_u16x2\n\n    three parameters, comparing (first + second) with the third: __viaddmax_s32, __viaddmax_s16x2, __viaddmax_u32, __viaddmax_u16x2, __viaddmin_s32, __viaddmin_s16x2, __viaddmin_u32, __viaddmin_u16x2\n\n    three parameters, with ReLU, comparing (first + second) with the third and a zero: __viaddmax_s32_relu, __viaddmax_s16x2_relu, __viaddmin_s32_relu, __viaddmin_s16x2_relu\n\nThese instructions are hardware-accelerated on devices with compute capability 9 and higher, and software emulation on older devices.\n\nFull API can be found in CUDA Math API documentation.\n\nDPX is exceptionally useful when implementing dynamic programming algorithms, such as Smith-Waterman or Needleman\u2013Wunsch in genomics and Floyd-Warshall in route optimization.\n10.25.1. Examples\uf0c1\n\nMax value of three signed 32-bit integers, with ReLU\n\nconst int a = -15;\nconst int b = 8;\nconst int c = 5;\nint max_value_0 = __vimax3_s32_relu(a, b, c); // max(-15, 8, 5, 0) = 8\nconst int d = -2;\nconst int e = -4;\nint max_value_1 = __vimax3_s32_relu(a, d, e); // max(-15, -2, -4, 0) = 0\n\nMin value of the sum of two 32-bit signed integers, another 32-bit signed integer and a zero (ReLU)\n\nconst int a = -5;\nconst int b = 6;\nconst int c = -2;\nint max_value_0 = __viaddmax_s32_relu(a, b, c); // max(-5 + 6, -2, 0) = max(1, -2, 0) = 1\nconst int d = 4;\nint max_value_1 = __viaddmax_s32_relu(a, d, c); // max(-5 + 4, -2, 0) = max(-1, -2, 0) = 0\n\nMin value of two unsigned 32-bit integers and determining which value is smaller\n\nconst unsigned int a = 9;\nconst unsigned int b = 6;\nbool smaller_value;\nunsigned int min_value = __vibmin_u32(a, b, &smaller_value); // min_value is 6, smaller_value is true\n\nMax values of three pairs of unsigned 16-bit integers\n\nconst unsigned a = 0x00050002;\nconst unsigned b = 0x00070004;\nconst unsigned c = 0x00020006;\nunsigned int max_value = __vimax3_u16x2(a, b, c); // max(5, 7, 2) and max(2, 4, 6), so max_value is 0x00070006\n\n10.26. Asynchronous Barrier\uf0c1\n\nThe NVIDIA C++ standard library introduces a GPU implementation of std::barrier. Along with the implementation of std::barrier the library provides extensions that allow users to specify the scope of barrier objects. The barrier API scopes are documented under Thread Scopes. Devices of compute capability 8.0 or higher provide hardware acceleration for barrier operations and integration of these barriers with the memcpy_async feature. On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.\n\nnvcuda::experimental::awbarrier is deprecated in favor of cuda::barrier.\n10.26.1. Simple Synchronization Pattern\uf0c1\n\nWithout the arrive/wait barrier, synchronization is achieved using __syncthreads() (to synchronize all threads in a block) or group.sync() when using Cooperative Groups.\n\n#include <cooperative_groups.h>\n\n__global__ void simple_sync(int iteration_count) {\n    auto block = cooperative_groups::this_thread_block();\n\n    for (int i = 0; i < iteration_count; ++i) {\n        /* code before arrive */\n        block.sync(); /* wait for all threads to arrive here */\n        /* code after wait */\n    }\n}\n\nThreads are blocked at the synchronization point (block.sync()) until all threads have reached the synchronization point. In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block) as well as the sync.\n\nThis pattern has three stages:\n\n    Code before sync performs memory updates that will be read after the sync.\n\n    Synchronization point\n\n    Code after sync point with visibility of memory updates that happened before sync point.\n\n10.26.2. Temporal Splitting and Five Stages of Synchronization\uf0c1\n\nThe temporally-split synchronization pattern with the std::barrier is as follows.\n\n#include <cuda/barrier>\n#include <cooperative_groups.h>\n\n__device__ void compute(float* data, int curr_iteration);\n\n__global__ void split_arrive_wait(int iteration_count, float *data) {\n    using barrier = cuda::barrier<cuda::thread_scope_block>;\n    __shared__  barrier bar;\n    auto block = cooperative_groups::this_thread_block();\n\n    if (block.thread_rank() == 0) {\n        init(&bar, block.size()); // Initialize the barrier with expected arrival count\n    }\n    block.sync();\n\n    for (int curr_iter = 0; curr_iter < iteration_count; ++curr_iter) {\n        /* code before arrive */\n       barrier::arrival_token token = bar.arrive(); /* this thread arrives. Arrival does not block a thread */\n       compute(data, curr_iter);\n       bar.wait(std::move(token)); /* wait for all threads participating in the barrier to complete bar.arrive()*/\n        /* code after wait */\n    }\n}\n\nIn this pattern, the synchronization point (block.sync()) is split into an arrive point (bar.arrive()) and a wait point (bar.wait(std::move(token))). A thread begins participating in a cuda::barrier with its first call to bar.arrive(). When a thread calls bar.wait(std::move(token)) it will be blocked until participating threads have completed bar.arrive() the expected number of times as specified by the expected arrival count argument passed to init(). Memory updates that happen before participating threads\u2019 call to bar.arrive() are guaranteed to be visible to participating threads after their call to bar.wait(std::move(token)). Note that the call to bar.arrive() does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threads\u2019 call to bar.arrive().\n\nThe arrive and then wait pattern has five stages which may be iteratively repeated:\n\n    Code before arrive performs memory updates that will be read after the wait.\n\n    Arrive point with implicit memory fence (i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block)).\n\n    Code between arrive and wait.\n\n    Wait point.\n\n    Code after the wait, with visibility of updates that were performed before the arrive.\n\n10.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation\uf0c1\n\nInitialization must happen before any thread begins participating in a cuda::barrier.\n\n#include <cuda/barrier>\n#include <cooperative_groups.h>\n\n__global__ void init_barrier() {\n    __shared__ cuda::barrier<cuda::thread_scope_block> bar;\n    auto block = cooperative_groups::this_thread_block();\n\n    if (block.thread_rank() == 0) {\n        init(&bar, block.size()); // Single thread initializes the total expected arrival count.\n    }\n    block.sync();\n}\n\nBefore any thread can participate in cuda::barrier, the barrier must be initialized using init() with an expected arrival count, block.size() in this example. Initialization must happen before any thread calls bar.arrive(). This poses a bootstrapping challenge in that threads must synchronize before participating in the cuda::barrier, but threads are creating a cuda::barrier in order to synchronize. In this example, threads that will participate are part of a cooperative group and use block.sync() to bootstrap initialization. In this example a whole thread block is participating in initialization, hence __syncthreads() could also be used.\n\nThe second parameter of init() is the expected arrival count, i.e., the number of times bar.arrive() will be called by participating threads before a participating thread is unblocked from its call to bar.wait(std::move(token)). In the prior example the cuda::barrier is initialized with the number of threads in the thread block i.e., cooperative_groups::this_thread_block().size(), and all threads within the thread block participate in the barrier.\n\nA cuda::barrier is flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast this_thread_block.sync() from cooperative groups or __syncthreads() is applicable to whole-thread-block and __syncwarp(mask) is a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using __syncthreads() and __syncwarp(mask) respectively for performance reasons.\n10.26.4. A Barrier\u2019s Phase: Arrival, Countdown, Completion, and Reset\uf0c1\n\nA cuda::barrier counts down from the expected arrival count to zero as participating threads call bar.arrive(). When the countdown reaches zero, a cuda::barrier is complete for the current phase. When the last call to bar.arrive() causes the countdown to reach zero, the countdown is automatically and atomically reset. The reset assigns the countdown to the expected arrival count, and moves the cuda::barrier to the next phase.\n\nA token object of class cuda::barrier::arrival_token, as returned from token=bar.arrive(), is associated with the current phase of the barrier. A call to bar.wait(std::move(token)) blocks the calling thread while the cuda::barrier is in the current phase, i.e., while the phase associated with the token matches the phase of the cuda::barrier. If the phase is advanced (because the countdown reaches zero) before the call to bar.wait(std::move(token)) then the thread does not block; if the phase is advanced while the thread is blocked in bar.wait(std::move(token)), the thread is unblocked.\n\nIt is essential to know when a reset could or could not occur, especially in non-trivial arrive/wait synchronization patterns.\n\n    A thread\u2019s calls to token=bar.arrive() and bar.wait(std::move(token)) must be sequenced such that token=bar.arrive() occurs during the cuda::barrier\u2019s current phase, and bar.wait(std::move(token)) occurs during the same or next phase.\n\n    A thread\u2019s call to bar.arrive() must occur when the barrier\u2019s counter is non-zero. After barrier initialization, if a thread\u2019s call to bar.arrive() causes the countdown to reach zero then a call to bar.wait(std::move(token)) must happen before the barrier can be reused for a subsequent call to bar.arrive().\n\n    bar.wait() must only be called using a token object of the current phase or the immediately preceding phase. For any other values of the token object, the behavior is undefined.\n\nFor simple arrive/wait synchronization patterns, compliance with these usage rules is straightforward.\n10.26.5. Spatial Partitioning (also known as Warp Specialization)\uf0c1\n\nA thread block can be spatially partitioned such that warps are specialized to perform independent computations. Spatial partitioning is used in a producer or consumer pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.\n\nA producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.\n\nProducer\n\t\n\nConsumer\n\nwait for buffer to be ready to be filled\n\t\n\nsignal buffer is ready to be filled\n\nproduce data and fill the buffer\n\t\n\nsignal buffer is filled\n\t\n\nwait for buffer to be filled\n\t\n\nconsume data in filled buffer\n\nProducer threads wait for consumer threads to signal that the buffer is ready to be filled; however, consumer threads do not wait for this signal. Consumer threads wait for producer threads to signal that the buffer is filled; however, producer threads do not wait for this signal. For full producer/consumer concurrency this pattern has (at least) double buffering where each buffer requires two cuda::barriers.\n\n#include <cuda/barrier>\n#include <cooperative_groups.h>\n\nusing barrier = cuda::barrier<cuda::thread_scope_block>;\n\n__device__ void producer(barrier ready[], barrier filled[], float* buffer, float* in, int N, int buffer_len)\n{\n    for (int i = 0; i < (N/buffer_len); ++i) {\n        ready[i%2].arrive_and_wait(); /* wait for buffer_(i%2) to be ready to be filled */\n        /* produce, i.e., fill in, buffer_(i%2)  */\n        barrier::arrival_token token = filled[i%2].arrive(); /* buffer_(i%2) is filled */\n    }\n}\n\n__device__ void consumer(barrier ready[], barrier filled[], float* buffer, float* out, int N, int buffer_len)\n{\n    barrier::arrival_token token1 = ready[0].arrive(); /* buffer_0 is ready for initial fill */\n    barrier::arrival_token token2 = ready[1].arrive(); /* buffer_1 is ready for initial fill */\n    for (int i = 0; i < (N/buffer_len); ++i) {\n        filled[i%2].arrive_and_wait(); /* wait for buffer_(i%2) to be filled */\n        /* consume buffer_(i%2) */\n        barrier::arrival_token token = ready[i%2].arrive(); /* buffer_(i%2) is ready to be re-filled */\n    }\n}\n\n//N is the total number of float elements in arrays in and out\n__global__ void producer_consumer_pattern(int N, int buffer_len, float* in, float* out) {\n\n    // Shared memory buffer declared below is of size 2 * buffer_len\n    // so that we can alternatively work between two buffers.\n    // buffer_0 = buffer and buffer_1 = buffer + buffer_len\n    __shared__ extern float buffer[];\n\n    // bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled,\n    // while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled-in respectively\n    __shared__ barrier bar[4];\n\n\n    auto block = cooperative_groups::this_thread_block();\n    if (block.thread_rank() < 4)\n        init(bar + block.thread_rank(), block.size());\n    block.sync();\n\n    if (block.thread_rank() < warpSize)\n        producer(bar, bar+2, buffer, in, N, buffer_len);\n    else\n        consumer(bar, bar+2, buffer, out, N, buffer_len);\n}\n\nIn this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call bar.arrive() or bar.arrive_and_wait()) in each of the four cuda::barriers so the expected arrival counts are equal to block.size().\n\nA producer thread waits for the consumer threads to signal that the shared memory buffer can be filled. In order to wait for a cuda::barrier a producer thread must first arrive on that ready[i%2].arrive() to get a token and then ready[i%2].wait(token) with that token. For simplicity ready[i%2].arrive_and_wait() combines these operations.\n\nbar.arrive_and_wait();\n/* is equivalent to */\nbar.wait(bar.arrive());\n\nProducer threads compute and fill the ready buffer, they then signal that the buffer is filled by arriving on the filled barrier, filled[i%2].arrive(). A producer thread does not wait at this point, instead it waits until the next iteration\u2019s buffer (double buffering) is ready to be filled.\n\nA consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iteration\u2019s buffer to be filled, filled[i%2].arrive_and_wait(). After the consumer threads consume the buffer they signal that the buffer is ready to be filled again, ready[i%2].arrive(), and then wait for the next iteration\u2019s buffer to be filled.\n10.26.6. Early Exit (Dropping out of Participation)\uf0c1\n\nWhen a thread that is participating in a sequence of synchronizations must exit early from that sequence, that thread must explicitly drop out of participation before exiting. The remaining participating threads can proceed normally with subsequent cuda::barrier arrive and wait operations.\n\n#include <cuda/barrier>\n#include <cooperative_groups.h>\n\n__device__ bool condition_check();\n\n__global__ void early_exit_kernel(int N) {\n    using barrier = cuda::barrier<cuda::thread_scope_block>;\n    __shared__ barrier bar;\n    auto block = cooperative_groups::this_thread_block();\n\n    if (block.thread_rank() == 0)\n        init(&bar , block.size());\n    block.sync();\n\n    for (int i = 0; i < N; ++i) {\n        if (condition_check()) {\n          bar.arrive_and_drop();\n          return;\n        }\n        /* other threads can proceed normally */\n        barrier::arrival_token token = bar.arrive();\n        /* code between arrive and wait */\n        bar.wait(std::move(token)); /* wait for all threads to arrive */\n        /* code after wait */\n    }\n}\n\nThis operation arrives on the cuda::barrier to fulfill the participating thread\u2019s obligation to arrive in the current phase, and then decrements the expected arrival count for the next phase so that this thread is no longer expected to arrive on the barrier.\n10.26.7. Completion Function\uf0c1\n\nThe CompletionFunction of cuda::barrier<Scope, CompletionFunction> is executed once per phase, after the last thread arrives and before any thread is unblocked from the wait. Memory operations performed by the threads that arrived at the barrier during the phase are visible to the thread executing the CompletionFunction, and all memory operations performed within the CompletionFunction are visible to all threads waiting at the barrier once they are unblocked from the wait.\n\n#include <cuda/barrier>\n#include <cooperative_groups.h>\n#include <functional>\nnamespace cg = cooperative_groups;\n\n__device__ int divergent_compute(int*, int);\n__device__ int independent_computation(int*, int);\n\n__global__ void psum(int* data, int n, int* acc) {\n  auto block = cg::this_thread_block();\n\n  constexpr int BlockSize = 128;\n  __shared__ int smem[BlockSize];\n  assert(BlockSize == block.size());\n  assert(n % 128 == 0);\n\n  auto completion_fn = [&] {\n    int sum = 0;\n    for (int i = 0; i < 128; ++i) sum += smem[i];\n    *acc += sum;\n  };\n\n  // Barrier storage\n  // Note: the barrier is not default-constructible because\n  //       completion_fn is not default-constructible due\n  //       to the capture.\n  using completion_fn_t = decltype(completion_fn);\n  using barrier_t = cuda::barrier<cuda::thread_scope_block,\n                                  completion_fn_t>;\n  __shared__ std::aligned_storage<sizeof(barrier_t),\n                                  alignof(barrier_t)> bar_storage;\n\n  // Initialize barrier:\n  barrier_t* bar = (barrier_t*)&bar_storage;\n  if (block.thread_rank() == 0) {\n    assert(*acc == 0);\n    assert(blockDim.x == blockDim.y == blockDim.y == 1);\n    new (bar) barrier_t{block.size(), completion_fn};\n    // equivalent to: init(bar, block.size(), completion_fn);\n  }\n  block.sync();\n\n  // Main loop\n  for (int i = 0; i < n; i += block.size()) {\n    smem[block.thread_rank()] = data[i] + *acc;\n    auto t = bar->arrive();\n    // We can do independent computation here\n    bar->wait(std::move(t));\n    // shared-memory is safe to re-use in the next iteration\n    // since all threads are done with it, including the one\n    // that did the reduction\n  }\n}\n\n10.26.8. Memory Barrier Primitives Interface\uf0c1\n\nMemory barrier primitives are C-like interfaces to cuda::barrier functionality. These primitives are available through including the <cuda_awbarrier_primitives.h> header.\n10.26.8.1. Data Types\uf0c1\n\ntypedef /* implementation defined */ __mbarrier_t;\ntypedef /* implementation defined */ __mbarrier_token_t;\n\n10.26.8.2. Memory Barrier Primitives API\uf0c1\n\nuint32_t __mbarrier_maximum_count();\nvoid __mbarrier_init(__mbarrier_t* bar, uint32_t expected_count);\n\n    bar must be a pointer to __shared__ memory.\n\n    expected_count <= __mbarrier_maximum_count()\n\n    Initialize *bar expected arrival count for the current and next phase to expected_count.\n\nvoid __mbarrier_inval(__mbarrier_t* bar);\n\n    bar must be a pointer to the mbarrier object residing in shared memory.\n\n    Invalidation of *bar is required before the corresponding shared memory can be repurposed.\n\n__mbarrier_token_t __mbarrier_arrive(__mbarrier_t* bar);\n\n    Initialization of *bar must happen before this call.\n\n    Pending count must not be zero.\n\n    Atomically decrement the pending count for the current phase of the barrier.\n\n    Return an arrival token associated with the barrier state immediately prior to the decrement.\n\n__mbarrier_token_t __mbarrier_arrive_and_drop(__mbarrier_t* bar);\n\n    Initialization of *bar must happen before this call.\n\n    Pending count must not be zero.\n\n    Atomically decrement the pending count for the current phase and expected count for the next phase of the barrier.\n\n    Return an arrival token associated with the barrier state immediately prior to the decrement.\n\nbool __mbarrier_test_wait(__mbarrier_t* bar, __mbarrier_token_t token);\n\n    token must be associated with the immediately preceding phase or current phase of *this.\n\n    Returns true if token is associated with the immediately preceding phase of *bar, otherwise returns false.\n\n//Note: This API has been deprecated in CUDA 11.1\nuint32_t __mbarrier_pending_count(__mbarrier_token_t token);\n\n10.27. Asynchronous Data Copies\uf0c1\n\nCUDA 11 introduces Asynchronous Data operations with memcpy_async API to allow device code to explicitly manage the asynchronous copying of data. The memcpy_async feature enables CUDA kernels to overlap computation with data movement.\n10.27.1. memcpy_async API\uf0c1\n\nThe memcpy_async APIs are provided in the cuda/barrier, cuda/pipeline, and cooperative_groups/memcpy_async.h header files.\n\nThe cuda::memcpy_async APIs work with cuda::barrier and cuda::pipeline synchronization primitives, while the cooperative_groups::memcpy_async synchronizes using coopertive_groups::wait.\n\nThese APIs have very similar semantics: copy objects from src to dst as-if performed by another thread which, on completion of the copy, can be synchronized through cuda::pipeline, cuda::barrier, or cooperative_groups::wait.\n\nThe complete API documentation of the cuda::memcpy_async overloads for cuda::barrier and cuda::pipeline is provided in the libcudacxx API documentation along with some examples.\n\nThe API documentation of cooperative_groups::memcpy_async is provided in the Cooperative Groups section.\n\nThe memcpy_async APIs that use cuda::barrier and cuda::pipeline require compute capability 7.0 or higher. On devices with compute capability 8.0 or higher, memcpy_async operations from global to shared memory can benefit from hardware acceleration.\n10.27.2. Copy and Compute Pattern - Staging Data Through Shared Memory\uf0c1\n\nCUDA applications often employ a copy and compute pattern that:\n\n    fetches data from global memory,\n\n    stores data to shared memory, and\n\n    performs computations on shared memory data, and potentially writes results back to global memory.\n\nThe following sections illustrate how this pattern can be expressed without and with the memcpy_async feature:\n\n    Without memcpy_async introduces an example that does not overlap computation with data movement and uses an intermediate register to copy data.\n\n    With memcpy_async improves the previous example by introducing the memcpy_async and the cuda::memcpy_async APIs to directly copy data from global to shared memory without using intermediate registers.\n\n    Asynchronous Data Copies using cuda::barrier shows memcpy with cooperative groups and barrier.\n\n    Single-Stage Asynchronous Data Copies using cuda::pipeline shows memcpy with single stage pipeline.\n\n    Multi-Stage Asynchronous Data Copies using cuda::pipeline shows memcpy with multi stage pipeline.\n\n10.27.3. Without memcpy_async\uf0c1\n\nWithout memcpy_async, the copy phase of the copy and compute pattern is expressed as shared[local_idx] = global[global_idx]. This global to shared memory copy is expanded to a read from global memory into a register, followed by a write to shared memory from the register.\n\nWhen this pattern occurs within an iterative algorithm, each thread block needs to synchronize after the shared[local_idx] = global[global_idx] assignment, to ensure all writes to shared memory have completed before the compute phase can begin. The thread block also needs to synchronize again after the compute phase, to prevent overwriting shared memory before all threads have completed their computations. This pattern is illustrated in the following code snippet.\n\n#include <cooperative_groups.h>\n__device__ void compute(int* global_out, int const* shared_in) {\n    // Computes using all values of current batch from shared memory.\n    // Stores this thread's result back to global memory.\n}\n\n__global__ void without_memcpy_async(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n  auto grid = cooperative_groups::this_grid();\n  auto block = cooperative_groups::this_thread_block();\n  assert(size == batch_sz * grid.size()); // Exposition: input size fits batch_sz * grid_size\n\n  extern __shared__ int shared[]; // block.size() * sizeof(int) bytes\n\n  size_t local_idx = block.thread_rank();\n\n  for (size_t batch = 0; batch < batch_sz; ++batch) {\n    // Compute the index of the current batch for this block in global memory:\n    size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * batch;\n    size_t global_idx = block_batch_idx + threadIdx.x;\n    shared[local_idx] = global_in[global_idx];\n\n    block.sync(); // Wait for all copies to complete\n\n    compute(global_out + block_batch_idx, shared); // Compute and write result to global memory\n\n    block.sync(); // Wait for compute using shared memory to finish\n  }\n}\n\n10.27.4. With memcpy_async\uf0c1\n\nWith memcpy_async, the assignment of shared memory from global memory\n\nshared[local_idx] = global_in[global_idx];\n\nis replaced with an asynchronous copy operation from cooperative groups\n\ncooperative_groups::memcpy_async(group, shared, global_in + batch_idx, sizeof(int) * block.size());\n\nThe cooperative_groups::memcpy_async API copies sizeof(int) * block.size() bytes from global memory starting at global_in + batch_idx to the shared data. This operation happens as-if performed by another thread, which synchronizes with the current thread\u2019s call to cooperative_groups::wait after the copy has completed. Until the copy operation completes, modifying the global data or reading or writing the shared data introduces a data race.\n\nOn devices with compute capability 8.0 or higher, memcpy_async transfers from global to shared memory can benefit from hardware acceleration, which avoids transfering the data through an intermediate register.\n\n#include <cooperative_groups.h>\n#include <cooperative_groups/memcpy_async.h>\n\n__device__ void compute(int* global_out, int const* shared_in);\n\n__global__ void with_memcpy_async(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n  auto grid = cooperative_groups::this_grid();\n  auto block = cooperative_groups::this_thread_block();\n  assert(size == batch_sz * grid.size()); // Exposition: input size fits batch_sz * grid_size\n\n  extern __shared__ int shared[]; // block.size() * sizeof(int) bytes\n\n  for (size_t batch = 0; batch < batch_sz; ++batch) {\n    size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * batch;\n    // Whole thread-group cooperatively copies whole batch to shared memory:\n    cooperative_groups::memcpy_async(block, shared, global_in + block_batch_idx, sizeof(int) * block.size());\n\n    cooperative_groups::wait(block); // Joins all threads, waits for all copies to complete\n\n    compute(global_out + block_batch_idx, shared);\n\n    block.sync();\n  }\n}}\n\n10.27.5. Asynchronous Data Copies using cuda::barrier\uf0c1\n\nThe cuda::memcpy_async overload for cuda::barrier enables synchronizing asynchronous data transfers using a barrier. This overloads executes the copy operation as-if performed by another thread bound to the barrier by: incrementing the expected count of the current phase on creation, and decrementing it on completion of the copy operation, such that the phase of the barrier will only advance when all threads participating in the barrier have arrived, and all memcpy_async bound to the current phase of the barrier have completed. The following example uses a block-wide barrier, where all block threads participate, and swaps the wait operation with a barrier arrive_and_wait, while providing the same functionality as the previous example:\n\n#include <cooperative_groups.h>\n#include <cuda/barrier>\n__device__ void compute(int* global_out, int const* shared_in);\n\n__global__ void with_barrier(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n  auto grid = cooperative_groups::this_grid();\n  auto block = cooperative_groups::this_thread_block();\n  assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size\n\n  extern __shared__ int shared[]; // block.size() * sizeof(int) bytes\n\n  // Create a synchronization object (C++20 barrier)\n  __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;\n  if (block.thread_rank() == 0) {\n    init(&barrier, block.size()); // Friend function initializes barrier\n  }\n  block.sync();\n\n  for (size_t batch = 0; batch < batch_sz; ++batch) {\n    size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * batch;\n    cuda::memcpy_async(block, shared, global_in + block_batch_idx, sizeof(int) * block.size(), barrier);\n\n    barrier.arrive_and_wait(); // Waits for all copies to complete\n\n    compute(global_out + block_batch_idx, shared);\n\n    block.sync();\n  }\n}\n\n10.27.6. Performance Guidance for memcpy_async\uf0c1\n\nFor compute capability 8.x, the pipeline mechanism is shared among CUDA threads in the same CUDA warp. This sharing causes batches of memcpy_async to be entangled within a warp, which can impact performance under certain circumstances.\n\nThis section highlights the warp-entanglement effect on commit, wait, and arrive operations. Please refer to Pipeline Interface and the Pipeline Primitives Interface for an overview of the individual operations.\n10.27.6.1. Alignment\uf0c1\n\nOn devices with compute capability 8.0, the cp.async family of instructions allows copying data from global to shared memory asynchronously. These instructions support copying 4, 8, and 16 bytes at a time. If the size provided to memcpy_async is a multiple of 4, 8, or 16, and both pointers passed to memcpy_async are aligned to a 4, 8, or 16 alignment boundary, then memcpy_async can be implemented using exclusively asynchronous memory operations.\n\nAdditionally for achieving best performance when using memcpy_async API, an alignment of 128 Bytes for both shared memory and global memory is required.\n\nFor pointers to values of types with an alignment requirement of 1 or 2, it is often not possible to prove that the pointers are always aligned to a higher alignment boundary. Determining whether the cp.async instructions can or cannot be used must be delayed until run-time. Performing such a runtime alignment check increases code-size and adds runtime overhead.\n\nThe cuda::aligned_size_t<size_t Align>(size_t size)Shape can be used to supply a proof that both pointers passed to memcpy_async are aligned to an Align alignment boundary and that size is a multiple of Align, by passing it as an argument where the memcpy_async APIs expect a Shape:\n\ncuda::memcpy_async(group, dst, src, cuda::aligned_size_t<16>(N * block.size()), pipeline);\n\nIf the proof is incorrect, the behavior is undefined.\n10.27.6.2. Trivially copyable\uf0c1\n\nOn devices with compute capability 8.0, the cp.async family of instructions allows copying data from global to shared memory asynchronously. If the pointer types passed to memcpy_async do not point to TriviallyCopyable types, the copy constructor of each output element needs to be invoked, and these instructions cannot be used to accelerate memcpy_async.\n10.27.6.3. Warp Entanglement - Commit\uf0c1\n\nThe sequence of memcpy_async batches is shared across the warp. The commit operation is coalesced such that the sequence is incremented once for all converged threads that invoke the commit operation. If the warp is fully converged, the sequence is incremented by one; if the warp is fully diverged, the sequence is incremented by 32.\n\n    Let PB be the warp-shared pipeline\u2019s actual sequence of batches.\n\n    PB = {BP0, BP1, BP2, \u2026, BPL}\n\n    Let TB be a thread\u2019s perceived sequence of batches, as if the sequence were only incremented by this thread\u2019s invocation of the commit operation.\n\n    TB = {BT0, BT1, BT2, \u2026, BTL}\n\n    The pipeline::producer_commit() return value is from the thread\u2019s perceived batch sequence.\n\n    An index in a thread\u2019s perceived sequence always aligns to an equal or larger index in the actual warp-shared sequence. The sequences are equal only when all commit operations are invoked from converged threads.\n\n    BTn \u2261 BPm where n <= m\n\nFor example, when a warp is fully diverged:\n\n    The warp-shared pipeline\u2019s actual sequence would be: PB = {0, 1, 2, 3, ..., 31} (PL=31).\n\n    The perceived sequence for each thread of this warp would be:\n\n        Thread 0: TB = {0} (TL=0)\n\n        Thread 1: TB = {0} (TL=0)\n\n        \u2026\n\n        Thread 31: TB = {0} (TL=0)\n\n10.27.6.4. Warp Entanglement - Wait\uf0c1\n\nA CUDA thread invokes either pipeline_consumer_wait_prior<N>() or pipeline::consumer_wait() to wait for batches in the perceived sequence TB to complete. Note that pipeline::consumer_wait() is equivalent to pipeline_consumer_wait_prior<N>(), where N =                                        PL.\n\nThe pipeline_consumer_wait_prior<N>() function waits for batches in the actual sequence at least up to and including PL-N. Since TL <= PL, waiting for batch up to and including PL-N includes waiting for batch TL-N. Thus, when TL < PL, the thread will unintentionally wait for additional, more recent batches.\n\nIn the extreme fully-diverged warp example above, each thread could wait for all 32 batches.\n10.27.6.5. Warp Entanglement - Arrive-On\uf0c1\n\nWarp-divergence affects the number of times an arrive_on(bar) operation updates the barrier. If the invoking warp is fully converged, then the barrier is updated once. If the invoking warp is fully diverged, then 32 individual updates are applied to the barrier.\n10.27.6.6. Keep Commit and Arrive-On Operations Converged\uf0c1\n\nIt is recommended that commit and arrive-on invocations are by converged threads:\n\n    to not over-wait, by keeping threads\u2019 perceived sequence of batches aligned with the actual sequence, and\n\n    to minimize updates to the barrier object.\n\nWhen code preceding these operations diverges threads, then the warp should be re-converged, via __syncwarp before invoking commit or arrive-on operations.\n10.28. Asynchronous Data Copies using cuda::pipeline\uf0c1\n\nCUDA provides the cuda::pipeline synchronization object to manage and overlap asynchronous data movement with computation.\n\nThe API documentation for cuda::pipeline is provided in the libcudacxx API. A pipeline object is a double-ended N stage queue with a head and a tail, and is used to process work in a first-in first-out (FIFO) order. The pipeline object has following member functions to manage the stages of the pipeline.\n\nPipeline Class Member Function\n\t\n\nDescription\n\nproducer_acquire\n\t\n\nAcquires an available stage in the pipeline internal queue.\n\nproducer_commit\n\t\n\nCommits the asynchronous operations issued after the producer_acquire call on the currently acquired stage of the pipeline.\n\nconsumer_wait\n\t\n\nWait for completion of all asynchronous operations on the oldest stage of the pipeline.\n\nconsumer_release\n\t\n\nRelease the oldest stage of the pipeline to the pipeline object for reuse. The released stage can be then acquired by the producer.\n10.28.1. Single-Stage Asynchronous Data Copies using cuda::pipeline\uf0c1\n\nIn previous examples we showed how to use cooperative_groups and cuda::barrier to do asynchronous data transfers. In this section, we will use the cuda::pipeline API with a single stage to schedule asynchronous copies. And later we will expand this example to show multi staged overlapped compute and copy.\n\n#include <cooperative_groups/memcpy_async.h>\n#include <cuda/pipeline>\n\n__device__ void compute(int* global_out, int const* shared_in);\n__global__ void with_single_stage(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n    auto grid = cooperative_groups::this_grid();\n    auto block = cooperative_groups::this_thread_block();\n    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size\n\n    constexpr size_t stages_count = 1; // Pipeline with one stage\n    // One batch must fit in shared memory:\n    extern __shared__ int shared[];  // block.size() * sizeof(int) bytes\n\n    // Allocate shared storage for a single stage cuda::pipeline:\n    __shared__ cuda::pipeline_shared_state<\n        cuda::thread_scope::thread_scope_block,\n        stages_count\n    > shared_state;\n    auto pipeline = cuda::make_pipeline(block, &shared_state);\n\n    // Each thread processes `batch_sz` elements.\n    // Compute offset of the batch `batch` of this thread block in global memory:\n    auto block_batch = [&](size_t batch) -> int {\n      return block.group_index().x * block.size() + grid.size() * batch;\n    };\n\n    for (size_t batch = 0; batch < batch_sz; ++batch) {\n        size_t global_idx = block_batch(batch);\n\n        // Collectively acquire the pipeline head stage from all producer threads:\n        pipeline.producer_acquire();\n\n        // Submit async copies to the pipeline's head stage to be\n        // computed in the next loop iteration\n        cuda::memcpy_async(block, shared, global_in + global_idx, sizeof(int) * block.size(), pipeline);\n        // Collectively commit (advance) the pipeline's head stage\n        pipeline.producer_commit();\n\n        // Collectively wait for the operations committed to the\n        // previous `compute` stage to complete:\n        pipeline.consumer_wait();\n\n        // Computation overlapped with the memcpy_async of the \"copy\" stage:\n        compute(global_out + global_idx, shared);\n\n        // Collectively release the stage resources\n        pipeline.consumer_release();\n    }\n}\n\n10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline\uf0c1\n\nIn the previous examples with cooperative_groups::wait and cuda::barrier, the kernel threads immediately wait for the data transfer to shared memory to complete. This avoids data transfers from global memory into registers, but does not hide the latency of the memcpy_async operation by overlapping computation.\n\nFor that we use the CUDA pipeline feature in the following example. It provides a mechanism for managing a sequence of memcpy_async batches, enabling CUDA kernels to overlap memory transfers with computation. The following example implements a two-stage pipeline that overlaps data-transfer with computation. It:\n\n    Initializes the pipeline shared state (more below)\n\n    Kickstarts the pipeline by scheduling a memcpy_async for the first batch.\n\n    Loops over all the batches: it schedules memcpy_async for the next batch, blocks all threads on the completion of the memcpy_async for the previous batch, and then overlaps the computation on the previous batch with the asynchronous copy of the memory for the next batch.\n\n    Finally, it drains the pipeline by performing the computation on the last batch.\n\nNote that, for interoperability with cuda::pipeline, cuda::memcpy_async from the cuda/pipeline header is used here.\n\n#include <cooperative_groups/memcpy_async.h>\n#include <cuda/pipeline>\n\n__device__ void compute(int* global_out, int const* shared_in);\n__global__ void with_staging(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n    auto grid = cooperative_groups::this_grid();\n    auto block = cooperative_groups::this_thread_block();\n    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size\n\n    constexpr size_t stages_count = 2; // Pipeline with two stages\n    // Two batches must fit in shared memory:\n    extern __shared__ int shared[];  // stages_count * block.size() * sizeof(int) bytes\n    size_t shared_offset[stages_count] = { 0, block.size() }; // Offsets to each batch\n\n    // Allocate shared storage for a two-stage cuda::pipeline:\n    __shared__ cuda::pipeline_shared_state<\n        cuda::thread_scope::thread_scope_block,\n        stages_count\n    > shared_state;\n    auto pipeline = cuda::make_pipeline(block, &shared_state);\n\n    // Each thread processes `batch_sz` elements.\n    // Compute offset of the batch `batch` of this thread block in global memory:\n    auto block_batch = [&](size_t batch) -> int {\n      return block.group_index().x * block.size() + grid.size() * batch;\n    };\n\n    // Initialize first pipeline stage by submitting a `memcpy_async` to fetch a whole batch for the block:\n    if (batch_sz == 0) return;\n    pipeline.producer_acquire();\n    cuda::memcpy_async(block, shared + shared_offset[0], global_in + block_batch(0), sizeof(int) * block.size(), pipeline);\n    pipeline.producer_commit();\n\n    // Pipelined copy/compute:\n    for (size_t batch = 1; batch < batch_sz; ++batch) {\n        // Stage indices for the compute and copy stages:\n        size_t compute_stage_idx = (batch - 1) % 2;\n        size_t copy_stage_idx = batch % 2;\n\n        size_t global_idx = block_batch(batch);\n\n        // Collectively acquire the pipeline head stage from all producer threads:\n        pipeline.producer_acquire();\n\n        // Submit async copies to the pipeline's head stage to be\n        // computed in the next loop iteration\n        cuda::memcpy_async(block, shared + shared_offset[copy_stage_idx], global_in + global_idx, sizeof(int) * block.size(), pipeline);\n        // Collectively commit (advance) the pipeline's head stage\n        pipeline.producer_commit();\n\n        // Collectively wait for the operations commited to the\n        // previous `compute` stage to complete:\n        pipeline.consumer_wait();\n\n        // Computation overlapped with the memcpy_async of the \"copy\" stage:\n        compute(global_out + global_idx, shared + shared_offset[compute_stage_idx]);\n\n        // Collectively release the stage resources\n        pipeline.consumer_release();\n    }\n\n    // Compute the data fetch by the last iteration\n    pipeline.consumer_wait();\n    compute(global_out + block_batch(batch_sz-1), shared + shared_offset[(batch_sz - 1) % 2]);\n    pipeline.consumer_release();\n}\n\nA pipeline object is a double-ended queue with a head and a tail, and is used to process work in a first-in first-out (FIFO) order. Producer threads commit work to the pipeline\u2019s head, while consumer threads pull work from the pipeline\u2019s tail. In the example above, all threads are both producer and consumer threads. The threads first commitmemcpy_async operations to fetch the next batch while they wait on the previous batch of memcpy_async operations to complete.\n\n    Committing work to a pipeline stage involves:\n\n        Collectively acquiring the pipeline head from a set of producer threads using pipeline.producer_acquire().\n\n        Submitting memcpy_async operations to the pipeline head.\n\n        Collectively commiting (advancing) the pipeline head using pipeline.producer_commit().\n\n    Using a previously commited stage involves:\n\n        Collectively waiting for the stage to complete, e.g., using pipeline.consumer_wait() to wait on the tail (oldest) stage.\n\n        Collectively releasing the stage using pipeline.consumer_release().\n\ncuda::pipeline_shared_state<scope, count> encapsulates the finite resources that allow a pipeline to process up to count concurrent stages. If all resources are in use, pipeline.producer_acquire() blocks producer threads until the resources of the next pipeline stage are released by consumer threads.\n\nThis example can be written in a more concise manner by merging the prolog and epilog of the loop with the loop itself as follows:\n\ntemplate <size_t stages_count = 2 /* Pipeline with stages_count stages */>\n__global__ void with_staging_unified(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n    auto grid = cooperative_groups::this_grid();\n    auto block = cooperative_groups::this_thread_block();\n    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size\n\n    extern __shared__ int shared[]; // stages_count * block.size() * sizeof(int) bytes\n    size_t shared_offset[stages_count];\n    for (int s = 0; s < stages_count; ++s) shared_offset[s] = s * block.size();\n\n    __shared__ cuda::pipeline_shared_state<\n        cuda::thread_scope::thread_scope_block,\n        stages_count\n    > shared_state;\n    auto pipeline = cuda::make_pipeline(block, &shared_state);\n\n    auto block_batch = [&](size_t batch) -> int {\n        return block.group_index().x * block.size() + grid.size() * batch;\n    };\n\n    // compute_batch: next batch to process\n    // fetch_batch:  next batch to fetch from global memory\n    for (size_t compute_batch = 0, fetch_batch = 0; compute_batch < batch_sz; ++compute_batch) {\n        // The outer loop iterates over the computation of the batches\n        for (; fetch_batch < batch_sz && fetch_batch < (compute_batch + stages_count); ++fetch_batch) {\n            // This inner loop iterates over the memory transfers, making sure that the pipeline is always full\n            pipeline.producer_acquire();\n            size_t shared_idx = fetch_batch % stages_count;\n            size_t batch_idx = fetch_batch;\n            size_t block_batch_idx = block_batch(batch_idx);\n            cuda::memcpy_async(block, shared + shared_offset[shared_idx], global_in + block_batch_idx, sizeof(int) * block.size(), pipeline);\n            pipeline.producer_commit();\n        }\n        pipeline.consumer_wait();\n        int shared_idx = compute_batch % stages_count;\n        int batch_idx = compute_batch;\n        compute(global_out + block_batch(batch_idx), shared + shared_offset[shared_idx]);\n        pipeline.consumer_release();\n    }\n}\n\nThe pipeline<thread_scope_block> primitive used above is very flexible, and supports two features that our examples above are not using: any arbitrary subset of threads in the block can participate in the pipeline, and from the threads that participate, any subsets can be producers, consumers, or both. In the following example, threads with an \u201ceven\u201d thread rank are producers, while other threads are consumers:\n\n__device__ void compute(int* global_out, int shared_in);\n\ntemplate <size_t stages_count = 2>\n__global__ void with_specialized_staging_unified(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n    auto grid = cooperative_groups::this_grid();\n    auto block = cooperative_groups::this_thread_block();\n\n    // In this example, threads with \"even\" thread rank are producers, while threads with \"odd\" thread rank are consumers:\n    const cuda::pipeline_role thread_role\n      = block.thread_rank() % 2 == 0? cuda::pipeline_role::producer : cuda::pipeline_role::consumer;\n\n    // Each thread block only has half of its threads as producers:\n    auto producer_threads = block.size() / 2;\n\n    // Map adjacent even and odd threads to the same id:\n    const int thread_idx = block.thread_rank() / 2;\n\n    auto elements_per_batch = size / batch_sz;\n    auto elements_per_batch_per_block = elements_per_batch / grid.group_dim().x;\n\n    extern __shared__ int shared[]; // stages_count * elements_per_batch_per_block * sizeof(int) bytes\n    size_t shared_offset[stages_count];\n    for (int s = 0; s < stages_count; ++s) shared_offset[s] = s * elements_per_batch_per_block;\n\n    __shared__ cuda::pipeline_shared_state<\n        cuda::thread_scope::thread_scope_block,\n        stages_count\n    > shared_state;\n    cuda::pipeline pipeline = cuda::make_pipeline(block, &shared_state, thread_role);\n\n    // Each thread block processes `batch_sz` batches.\n    // Compute offset of the batch `batch` of this thread block in global memory:\n    auto block_batch = [&](size_t batch) -> int {\n      return elements_per_batch * batch + elements_per_batch_per_block * blockIdx.x;\n    };\n\n    for (size_t compute_batch = 0, fetch_batch = 0; compute_batch < batch_sz; ++compute_batch) {\n        // The outer loop iterates over the computation of the batches\n        for (; fetch_batch < batch_sz && fetch_batch < (compute_batch + stages_count); ++fetch_batch) {\n            // This inner loop iterates over the memory transfers, making sure that the pipeline is always full\n            if (thread_role == cuda::pipeline_role::producer) {\n                // Only the producer threads schedule asynchronous memcpys:\n                pipeline.producer_acquire();\n                size_t shared_idx = fetch_batch % stages_count;\n                size_t batch_idx = fetch_batch;\n                size_t global_batch_idx = block_batch(batch_idx) + thread_idx;\n                size_t shared_batch_idx = shared_offset[shared_idx] + thread_idx;\n                cuda::memcpy_async(shared + shared_batch_idx, global_in + global_batch_idx, sizeof(int), pipeline);\n                pipeline.producer_commit();\n            }\n        }\n        if (thread_role == cuda::pipeline_role::consumer) {\n            // Only the consumer threads compute:\n            pipeline.consumer_wait();\n            size_t shared_idx = compute_batch % stages_count;\n            size_t global_batch_idx = block_batch(compute_batch) + thread_idx;\n            size_t shared_batch_idx = shared_offset[shared_idx] + thread_idx;\n            compute(global_out + global_batch_idx, *(shared + shared_batch_idx));\n            pipeline.consumer_release();\n        }\n    }\n}\n\nThere are some optimizations that pipeline performs, for example, when all threads are both producers and consumers, but in general, the cost of supporting all these features cannot be fully eliminated. For example, pipeline stores and uses a set of barriers in shared memory for synchronization, which is not really necessary if all threads in the block participate in the pipeline.\n\nFor the particular case in which all threads in the block participate in the pipeline, we can do better than pipeline<thread_scope_block> by using a pipeline<thread_scope_thread> combined with __syncthreads():\n\ntemplate<size_t stages_count>\n__global__ void with_staging_scope_thread(int* global_out, int const* global_in, size_t size, size_t batch_sz) {\n    auto grid = cooperative_groups::this_grid();\n    auto block = cooperative_groups::this_thread_block();\n    auto thread = cooperative_groups::this_thread();\n    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size\n\n    extern __shared__ int shared[]; // stages_count * block.size() * sizeof(int) bytes\n    size_t shared_offset[stages_count];\n    for (int s = 0; s < stages_count; ++s) shared_offset[s] = s * block.size();\n\n    // No pipeline::shared_state needed\n    cuda::pipeline<cuda::thread_scope_thread> pipeline = cuda::make_pipeline();\n\n    auto block_batch = [&](size_t batch) -> int {\n        return block.group_index().x * block.size() + grid.size() * batch;\n    };\n\n    for (size_t compute_batch = 0, fetch_batch = 0; compute_batch < batch_sz; ++compute_batch) {\n        for (; fetch_batch < batch_sz && fetch_batch < (compute_batch + stages_count); ++fetch_batch) {\n            pipeline.producer_acquire();\n            size_t shared_idx = fetch_batch % stages_count;\n            size_t batch_idx = fetch_batch;\n            // Each thread fetches its own data:\n            size_t thread_batch_idx = block_batch(batch_idx) + threadIdx.x;\n            // The copy is performed by a single `thread` and the size of the batch is now that of a single element:\n            cuda::memcpy_async(thread, shared + shared_offset[shared_idx] + threadIdx.x, global_in + thread_batch_idx, sizeof(int), pipeline);\n            pipeline.producer_commit();\n        }\n        pipeline.consumer_wait();\n        block.sync(); // __syncthreads: All memcpy_async of all threads in the block for this stage have completed here\n        int shared_idx = compute_batch % stages_count;\n        int batch_idx = compute_batch;\n        compute(global_out + block_batch(batch_idx), shared + shared_offset[shared_idx]);\n        pipeline.consumer_release();\n    }\n}\n\nIf the compute operation only reads shared memory written to by other threads in the same warp as the current thread, __syncwarp() suffices.\n10.28.3. Pipeline Interface\uf0c1\n\nThe complete API documentation for cuda::memcpy_async is provided in the libcudacxx API documentation along with some examples.\n\nThe pipeline interface requires\n\n    at least CUDA 11.0,\n\n    at least ISO C++ 2011 compatibility, e.g., to be compiled with -std=c++11, and\n\n    #include <cuda/pipeline>.\n\nFor a C-like interface, when compiling without ISO C++ 2011 compatibility, see Pipeline Primitives Interface.\n10.28.4. Pipeline Primitives Interface\uf0c1\n\nPipeline primitives are a C-like interface for memcpy_async functionality. The pipeline primitives interface is available by including the <cuda_pipeline.h> header. When compiling without ISO C++ 2011 compatibility, include the <cuda_pipeline_primitives.h> header.\n10.28.4.1. memcpy_async Primitive\uf0c1\n\nvoid __pipeline_memcpy_async(void* __restrict__ dst_shared,\n                             const void* __restrict__ src_global,\n                             size_t size_and_align,\n                             size_t zfill=0);\n\nRequest that the following operation be submitted for asynchronous evaluation:\n\nsize_t i = 0;\nfor (; i < size_and_align - zfill; ++i) ((char*)dst_shared)[i] = ((char*)src_global)[i]; /* copy */\nfor (; i < size_and_align; ++i) ((char*)dst_shared)[i] = 0; /* zero-fill */\n\n    Requirements:\n\n        dst_shared must be a pointer to the shared memory destination for the memcpy_async.\n\n        src_global must be a pointer to the global memory source for the memcpy_async.\n\n        size_and_align must be 4, 8, or 16.\n\n        zfill <= size_and_align.\n\n        size_and_align must be the alignment of dst_shared and src_global.\n\n    It is a race condition for any thread to modify the source memory or observe the destination memory prior to waiting for the memcpy_async operation to complete. Between submitting a memcpy_async operation and waiting for its completion, any of the following actions introduces a race condition:\n\n        Loading from dst_shared.\n\n        Storing to dst_shared or src_global.\n\n        Applying an atomic update to dst_shared or src_global.\n\n10.28.4.2. Commit Primitive\uf0c1\n\nvoid __pipeline_commit();\n\n    Commit submitted memcpy_async to the pipeline as the current batch.\n\n10.28.4.3. Wait Primitive\uf0c1\n\nvoid __pipeline_wait_prior(size_t N);\n\n    Let {0, 1, 2, ..., L} be the sequence of indices associated with invocations of __pipeline_commit() by a given thread.\n\n    Wait for completion of batches at least up to and including L-N.\n\n10.28.4.4. Arrive On Barrier Primitive\uf0c1\n\nvoid __pipeline_arrive_on(__mbarrier_t* bar);\n\n    bar points to a barrier in shared memory.\n\n    Increments the barrier arrival count by one, when all memcpy_async operations sequenced before this call have completed, the arrival count is decremented by one and hence the net effect on the arrival count is zero. It is user\u2019s responsibility to make sure that the increment on the arrival count does not exceed __mbarrier_maximum_count().\n\n\nCan you please provide a few sentence summary of the above document?\n"]
